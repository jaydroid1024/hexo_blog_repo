---
title: 筑基系列-计算机基础知识小抄版
date: 2021-05-31 14:16:55
cover: true
tags: 
    - 计算机基础
    - 组成原理
    - CPU
    - 存储器
    - 位运算
category: 
	- 计算机
summary: 计算机基础知识提纲挈领，包括发展史、CPU、总线、存储器、指令系统、控制器、运算器、位运算等

---

![](https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/post_banner_jay.png)

# 筑基系列-计算机基础知识小抄版



> 计算机基础知识筑基三部曲：
>
> - **[第一部：筑基系列-计算机基础知识小抄版](https://juejin.cn/post/6991367806772052004)**
>   - 包括发展史、CPU、总线、存储器、指令系统、控制器、运算器、位运算等
> - **[第二部：筑基系列-操作系统基础知识小抄版](https://juejin.cn/post/6991385109509193764)**
>   - 包括进程与线程同步管理、作业管理、存储管理、虚拟内存、Linux、文件管理等
> - **[第三部：筑基系列-计算机网络基础知识小抄版](https://juejin.cn/post/6991397445251334151)**
>   - 包括OSI七层模型各层详解、IP协议、TCP\IP协议、Http协议、DNS协议等



## 目录

- [1.背景篇](#1.背景篇)
  - [1.1 计算机发展史](#11-计算机发展史)
  - [1.2 CPU发展史](#12-cpu发展史)
  - [1.3 32 位 VS 64 位](#13-32-位-vs-64-位)
  - [1.4 计算机的分类](#14-计算机的分类)
  - [1.5 计算机的体系与结构](#15-计算机的体系与结构)
  - [1.6 程序翻译与解释](#16-程序翻译与解释)
  - [1.7 计算机的层次](#17-计算机的层次)
  - [1.8 计算机的计算单位](#18-计算机的计算单位)
  - [1.9 计算机的字符与编码集](#19-计算机的字符与编码集)
- [2.组成篇](#2.组成篇)
  - [2.1 计算机的总线](#21-计算机的总线)
  - [2.2 计算机的输入输出设备](#22-计算机的输入输出设备)
  - [2.3 计算机存储器](#23-计算机存储器)
  - [2.4 主存储器与辅助存储器](#24-主存储器与辅助存储器)
  - [2.5 高速缓存](#25-高速缓存)
  - [2.6 计算机的指令系统](#26-计算机的指令系统)
  - [2.7 计算机的控制器](#27-计算机的控制器)
  - [2.8 计算机的运算器](#28-计算机的运算器)
  - [2.9 计算机指令的执行过程](#29-计算机指令的执行过程)
- [3.计算篇](#3.计算篇)
  - [3.1 进制运算的基础](#31-进制运算的基础)
  - [3.2 原码&反码&补码](#32-原码反码补码)
  - [3.3 定点数与浮点数](#33-定点数与浮点数)
  - [3.4 定点数的加减法运算](#34-定点数的加减法运算)
  - [3.5 浮点数的加减法运算](#35-浮点数的加减法运算)
  - [3.6 浮点数的乘除法运算](#36-浮点数的乘除法运算)
- [4.关于我](#4.关于我)
- [5.参考](#5.参考)



## 1.背景篇

### 1.1 计算机发展史

- 电子管计算机 (1946-1957)
  - 埃尼阿克(ENIAC)
- 晶体管计算机(1957-1964)
  - 贝尔实验室、MIT林肯实验室的TX-0、PDP-1配备4k内存和显示器
- 集成电路计算机 (1964-1980)
  - 德州仪器的工程师发明了集成电路(IC)、IBM(7094,1401) 、System/360 操作系统
- 超大规模集成电路计算机 (1980-现在)
  - 乔布斯 Apple 和 Apple二代
- 未来的计算机 
  - 生物计算机
  - 量子计算机



### 1.2 CPU发展史

- 摩尔定律
  - 定义：当价格不变时，集成电路中可容纳的晶体管数目约每隔 18～24 个月就会增加一倍，性能也将提升一倍。
  - 这一定律揭示了信息技术发展的速度，但到今天，摩尔定律失效了。因为随着芯片越来越小，在尺寸和散热等方面已经挑战了人类的极限，芯片中无法再放入更多的电子元件了。
  - 所以计算能力又开始以另一种方式发展，那就是多核心，比如一个普普通通的 NVIDA 显卡中就拥有了几百个核心，这样就可以进行大量的并发计算；另外，一个分布式的大数据集群，里面就可能有上千个核心。
- 单核CPU发展史
  - （1971～ 1973） 500KHz频率的微型计算机（字长8位）
  - （1978～ 1985） 500MHz频率的微型计算机（字长16位）
  - （1985～ 2000） 高于1GHz频率的微型计算机（字长32位）
  - （1973～ 1978） 高于1MHz频率的微型计算机（字长8位）
  - （2000～ 现在） 高于2GHz频率的微型计算机（字长为64位）
- 多核CPU发展史
  - （2005） Intel奔腾系列双核CPU、 AMD速龙系列
  - （2006） Intel酷睿四核CPU
  - Intel酷睿系列十六核CPU
  - Intel至强系列五十六核CPU
- CPU数字能量是如何产生的
  - 时间是最重要的输入：晶振
  - 电能供给给芯片，芯片中的一种电子元件晶振（也就是石英晶体）通电后产生震荡
  - 震荡会产生频率稳定的脉冲信号，通常这是一种高频的脉冲信号，每秒可达百万次
  - 然后通过谐振效应发放这个信号，形成方波
  - 再通过电子元件调整这种脉冲的频率，把脉冲信号转换为需要的频率，这就形成了驱动芯片工作的时钟信号
  - 最后，时钟信号驱动着芯片工作，就像人体的脉搏一样，每一次脉冲到来，都让芯片的状态发生一次变化，最终存储器中的指令被一行行执行



### 1.3 32 位 VS 64 位

-  32、64 位可以表示操作系统、软件、 CPU等
-  32位的容量：2^32 = 4 × 2^30 = 4𝐺𝐵 
-  64位的容量：2^64 = 2^34 × 2^30 = 2^34𝐺𝐵=2^24T𝐵=2^14EB=2^4EB
-  如果是 CPU，那么有 32 位 CPU，也有 64 位 CPU
   - 如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU
   - 如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU
   - 这里的 32 和 64，称作 CPU 的位宽
   - 64 位 CPU 可以执行更大数字的运算，这个优势在普通应用上不明显，但是对于数值计算较多的应用就非常明显。
   - 64 位 CPU 可以寻址更大的内存空间
-  如果 32 位/64 位说的是程序，那么说的是指令是 64 位还是 32 位的。
   - 32 位指令在 64 位机器上执行，困难不大，可以兼容。 
   - 如果是 64 位指令，在 32 位机器上执行就困难了，32 位的寄存器都存不下指令的参数。
-  如果 32 位/64 位说的是操作系统
   - 操作系统也是一种程序，如果是 64 位操作系统，也就是操作系统中程序的指令都是 64 位指令，因此不能安装在 32 位机器上。



### 1.4 计算机的分类

- 超级计算机
  - 功能最强
  - 运算速度的单位是TFlop/s（1TFlop/s=每秒一万亿次浮点计算）
  - Intel(R) Core(TM) i7-6700K CPU @ 4.00GHz： 44.87 GFlop/s（  0.04487TFlop/s）
  - 世界排名：Summit IBM（美国) > 神威太湖之光(中国)  > Sierra IBM（美国） 
  - 中国排名：神威 太湖之光 > 天河二号>  天河一号
- 大型机 (又称大型机、大型主机、主机等)
  - IBM Z9 
  - 大型机造价高昂
  - 去“IOE”行动 (I(IBM) O(Oracle) E(EMC)) --阿里云
- 迷你计算机（服务器）
  - 普通服务器已经代替了传统的大型机，成为大规模企业计算的中枢
- 工作站
  - 高端的通用微型计算机，提供比个人计算机更强大的性能
  - 类似于普通台式电脑，体积较大，但性能强劲
- 微型计算机
  - 麻雀虽小、五脏俱全
  - 从构成的本质上来讲，个人计算机与前面的分类无异



### 1.5 计算机的体系与结构

- 阿兰.图灵
  - 英国(1912-1954) 数学家成逻辑学家网密肯进分析家和理论生物学家，被誉为计算机科学和人工智能之父。
  - 图灵机
  - 图灵测试
  - 图灵完备
  - 可判定性

- 图灵机
  - 图灵机拥有一条无限长的纸带，纸带上是一个格子挨着一个格子，格子中可以写字符，你可以把纸带看作内存，而这些字符可以看作是内存中的数据或者程序。

  - 图灵机有一个读写头，读写头可以读取任意格子上的字符，也可以改写任意格子的字符。

  - 读写头上面的盒子里是一些精密的零件，包括图灵机的存储、控制单元和运算单元。
  - 图灵通过数学证明了，一个问题如果可以拆解成图灵机的可执行步骤，那问题就是可计算的。
  - 另一方面，图灵机定义了计算机的组成以及工作原理，但是没有给出具体的实现。

- 冯诺依曼体系
  - 将程序指令和数据一起存储的计算机设计概念结构,现代计算机都是冯诺依曼机
  - 能够长期记忆程序、数据、中间结果及最终运算结果的能力

  - 能够把需要的程序和数据送至计算机中
  - 能够具备算术、逻辑运算和数据传送等数据加工处理的能力
  - 能够按照要求将处理结果输出给用户

  - 冯诺依曼瓶颈：CPU和存储器速率之间的问题无法调和导致CPU经常空转等待数据传输

- 冯诺依曼机组成结构
  - 输入设备
    - 鼠标、键盘
  - 输出设备
    - 显示器
  - 存储器
    - CPU、内存、硬盘
  - 控制器
    - CPU
  - 运算器
    - CPU



### 1.6 程序翻译与解释

- 人类语言与计算机语言需要进行语言之间的转换

- 程序翻译
  - L1是描述程序逻辑的高级语言
  - L0是计算机实际执行的低级语言
  - 编译器：高级语言对应的编译器
  - 程序翻译就是编译器将L1语言翻译并生成L0语言
  - 翻译过程生成新的L0程序
  - 通过编译器执行的相关语言

    - C/C++
    - Object-C
    - Go

- 程序解释
  - L1是描述程序逻辑的高级语言
  - L0是计算机实际执行的低级语言
  - 解释器：使用L0语言实现的程序
  - 程序解释的过程就是解释器将L1语言解释为L0语言
  - 解释过程不生成新的L0程序
  - 相关语言

    - Python
    - Php
    - Javascript

- 混合型语言 

  - Java （java程序翻译成字节码， 字节码解释成机器码）
  - C#




### 1.7 计算机的层次

- 硬件逻辑层
  - 门、触发器等逻辑电路组成
  - 属于电子工程的领域
- 微程序机器层
  - 编程语言是微指令集
  - 微指令所组成的微程序直接交由硬件执行
  - 一般是硬件厂商公司处理该层
- 传统机器层
  - 编程语言是CPU指令集（机器指令）
  - 一条机器指令对应一个微程序，一个微程序对应一组微指令
  - 编程语言和硬件是直接相关
  - 不同架构的CPU使用不同的CPU指令集 （英特尔、AMD、x86/X86_64）
- 操作系统层
  - 向上提供了简易的操作界面
  - 向下对接了指令系统，管理硬件资源
  - 操作系统层是在软件和硬件之间的适配层
- 汇编语言层
  - 编程语言是汇编语言（PUSH DS/PUSH DS）
  - 汇编语言可以翻译成可直接执行的机器语言
  - 完成翻译的过程的程序就是汇编器
- 高级语言层
  - 高级语言的类别非常多，由几百种
  - 常见的高级语言有： Python、 Java、 C/C++、 Golang等
- 应用层
  - 满足计算机针对某种用途而专门设计
  - WPS、IDE



### 1.8 计算机的计算单位

- 容量单位
  - 在物理层面，高低电平记录信息
  - 理论上只认识0/1两种状态，0/1称为bit（比特位）
  - 0/1能够表示的内容太少了，需要更大的容量表示方法
  - 更大的容量单位：字节、千字节、兆字节、吉字节、太字节、拍字节、艾字节
  - 为什么网上买的移动硬盘500G，格式化之后就只剩465G了？

    - 硬盘商一般用10进位标记容量 𝟓𝟎𝟎 ∗ 𝟏𝟎𝟎𝟎^3/𝟏𝟎𝟐𝟒^3约等于𝟒𝟔𝟓
    - 厂商采用十进制更好沟通

| 容量单位 |  bit   | Byte  |         KB         |             MB              |             GB              |            TB             |              PB               |             EB             |
| :------: | :----: | :---: | :----------------: | :-------------------------: | :-------------------------: | :-----------------------: | :---------------------------: | :------------------------: |
|   名字   | 比特位 | 字节  | 千字节（kilobyte） | 兆字节=百万字节（megabyte） | 吉字节=十亿字节（GigaByte） | 太字节=万亿字节(terabyte) | 拍字节=千万亿字节（petabyte） | 艾字节=2^60字节（ExaByte） |
|   换算   |   -    | 8bits |       1024B        |            1024K            |            1024M            |           1024G           |             1024T             |           1024P            |
| 常见设备 | 门电路 |       |       寄存器       |          高速缓存           |          内存/硬盘          |           硬盘            |            云硬盘             |          数据仓库          |

- 速度单位
  - 网络速度
    - 100M带宽=100M/s
    - 为什么电信拉的100M光纤，测试峰值速度只有12M每秒？
      - 网络常用单位为(Mbps) 
      - bps(bits per second):每秒传送位数 
      - 100M/s = 100Mbps = 100Mbit/s
      - 100Mbit/s=(100/8)MB/s=12.5MB/s
  - 计算速度
    - CPU的速度一般体现为CPU的时钟频率
    - CPU的时钟频率的单位一般是赫兹Hz（hertz）
    - 目前主流CPU的时钟频率都在2GHz以上
    - Hz其实就是秒分之，并不只是描述计算机领域所专有的单位
    - Hz它是每秒中的周期性变动重复次数的计量
    - 在CPU中就表示高低电瓶在每秒中变化的次数，2GHz = 2*1000^3Hz = 每秒20亿次



### 1.9 计算机的字符与编码集

- 早期英美的ASCII码

  - 美国信息交换标准码（American Standard Code for Information Interchange）

  - 使用7个bits就可以完全表示ASCII码

  - 包含95个可打印字符，33个不可打印字符（包括控制字符）

  - 很多应用或者国家中的符号都无法表示

  - 无法表示数学符号：“÷ ≠ ≥ ≈ π”

  - 𝟑𝟑 + 𝟗𝟓 = 𝟏𝟐𝟖 = 𝟐^7

    ![](https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801143402.jpg)

- Externed ASCII码

  - 第一次对ASCII码进行扩充， 7bits => 8bits

  - 常见数学运算符

  - 带音标的欧洲字符

  - 其他常用符、表格符等

    ![](https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801143429.jpg)

- 国际化

  - 欧洲、中亚、东亚、拉丁美洲国家的语言多样性
  - 语言体系不一样，不以有限字符组合的语言
  - 中国、韩国、日本等的语言最为复杂
  - 中文编码集
    - GB2312
      - 《信息交换用汉字编码字符集——基本集》
      - 一共收录了 7445 个字符
      - 包括 6763 个汉字和 682 个其它符号
      - 不兼容国际标准
    - GBK
      - 向下兼容GB2312，向上支持国际ISO标准
      - 《汉字内码扩展规范》
      - 收录了21003个汉字，支持全部中日韩汉字
      - 国际电脑不安装GBK编码就会显示乱码
      - 国内的Windows系统默认使用GBK编码
  - Unicode
    - Unicode：统一码、万国码、单一码，兼容全球的字符集
    - Unicode定义了世界通用的符号集， UTF-*实现了编码
    - UTF-8以字节为单位对Unicode进行编码

## 2.组成篇

### 2.1 计算机的总线

- 总线的概述
  - USB = Universal Serial Bus ，通用串行总线
    - 提供了对外连接的接口
    - 不同设备可以通过USB接口进行连接
    - 连接的标准，促使外围设备接口的统一
  - 总线的分类

    - 片内总线
      - 芯片内部的总线
      - 寄存器与寄存器之间
      - 寄存器与控制器、运算器之间
    - 系统总线
      - CPU、主内存、 IO设备、各组件之间的信息传输线
      - 数据总线
        - 双向传输各个部件的数据信息
        - 一般与CPU位数相同（32位、 64位）
        - 数据总线的位数（总线宽度）是数据总线的重要参数，64位总线一次可传输8个字节的数据
      - 地址总线
        - 指定源数据或目的数据在内存中的地址
        - 地址总线位数=n，寻址范围： 0~𝟐^n
        - 地址总线的位数与存储单元有关
      - 控制总线
        - 控制总线是用来发出各种控制信号的传输线
        - 控制信号经由控制总线从一个组件发给另外一个组件
        - 控制总线可以监视不同组件之间的状态（就绪/未就绪）

- 总线的仲裁
  - 为了解决总线使用权的冲突问题
  - 总线的仲裁的方法
    - 链式查询-串联
      - 所有设备都可想仲裁器发出使用权申请，仲裁器在分配使用权时是按照链式顺序逐个询问，轮到谁就是谁
      - 好处：电路复杂度低，仲裁方式简单
      - 坏处：优先级低的设备难以获得总线使用权
      - 坏处：优先级低的设备难以获得总线使用权
    - 计时器定时查询-并联
      - 仲裁控制器对设备编号并使用计数器累计计数
      - 接收到仲裁信号后，往所有设备同时发出计数值
      - 计数值与设备编号一致则获得总线使用权
    - 独立请求-循环
      -  每个设备均有总线独立连接仲裁器
      -  设备可单独向仲裁器发送请求和接收请求
      -  当同时收到多个请求信号，仲裁器有权按优先级分配使用权
      -  好处：响应速度快，优先顺序可动态改变
      -  好处：响应速度快，优先顺序可动态改变



### 2.2 计算机的输入输出设备

- 常见输入输出设备

  - 输入设备

    - 字符输入设备
      - 键盘：
        - 薄膜键盘
        - 机械键盘（根据段落感、声音、压力、键程的不同分为：黑轴、红轴、青轴、茶轴）
        - 电容键盘
    - 图像输入设备
      - 鼠标
      - 数位板：常用于绘图设计创作，输入板和压感笔
      - 扫描仪：将图形信息转换为数字信号
  - 输出设备
    - 显示器
      - CRT显示器
      - 液晶显示器
    - 打印机
    - 投影仪

- 输入输出接口的通用设计

  - 通用设计考虑的问题：读取数据、向设备发送数据、设备有没有被占用？、设备是否已经启动？、设备是否已经连接？
  - 数据线
    - 是I/O设备与主机之间进行数据交换的传送线
    - 单向传输数据线
    - 双向传输数据线
  - 状态线
    - IO设备状态向主机报告的信号线
    - 查询设备是否已经正常连接并就绪
    - 查询设备是否已经被占用
  - 命令线
    - CPU向设备发送命令的信号线
    - 发送读写信号
    - 发送启动停止信号
  - 设备选择线
    - 主机选择I/O设备进行操作的信号线
    - 对连在总线上的设备进行选择

- CPU与IO设备的通信

  - CPU速度与IO设备速度不一致

  - 程序中断

    - 当外围IO设备就绪时，向CPU发出中断信号

    - CPU有专门的电路响应中断信号

    - 中断的意义

      - 提供低速设备通知CPU的一种异步的方式
      - CPU可以高速运转同时兼顾低速设备的响应
      - 提高工作效率(polling的问题) 
      - 故障恢复(异常处理、紧急事件等)
      - 简化编程模型(try/cache, 计时器等)

  - 例如通过电脑打印资料的过程

    - 中断相应过程

      ![](https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801143825.jpg)

    - 中断请求类型

      - 硬件设备发给主板(打印机、键盘、鼠标等)
      - 硬件中断: CPU异常(除以0), 时钟信号等
      - 软件中断:发出(异常、切换到内核态等)

    - 中断向量表

      - (一般在内存中) 一块块区域，存储了中断类型和中断响应程序的对应关系。每一行叫做一个中断向量。

        | 中断类型 | ISR地址 | 描述   |
        | -------- | ------- | ------ |
        | 00       | 0x0000  | 除以0  |
        | 01       | 0x0004  | 单步   |
        | 09       | 0x0024  | 键盘   |
        | 18       | 0x0048  | 打印机 |
        | 100      | 0x0190  | 自定义 |

    - 中断QA

      - 32位机器上的中断响应路径(ISR) 只有4个字节，怎么实现复杂的程序?
      - 按键程序中断响应路径到操作系统再到应用， 但是到底哪些键被按了怎么知道?
      - 中断响应后，如何恢复到中断执行前的状态?
      - 既然出错了?为什么不出错了直接跳转到错误处理位置?

  - DMA（direct memory access）直接存储器存取

    - DMA直接连接主存与IO设备
    - DMA直接连接主存与IO设备
    - 当主存与IO设备交换信息时，不需要中断CPU
    - 可以提高CPU的效率
    - 硬盘和外置显卡中都有DMA设备

  

### 2.3 计算机存储器

- 存储器的分类

  - 按存储介质分类
    - 半导体存储器 ：内存条、 U盘、 固态硬盘
    - 磁存储器：磁带、磁盘
  - 按存取方式分类
    - 随机存储器(RAM)： 随机读取 与位置无关
    - 串行存储器 ：与位置有关 按顺序查找
    - 只读存储器(ROM）：只读不写

- 存储器指标

  - 读写速度：7200转
  - 存储容量：2T
  - 价格：容量+价格=>位价：每比特位价格

- 层次结构

  - 高速缓存：速度快，位格高
  - 主存：速度适中，位格适中
  - 辅存：速度慢，位格低
  - 缓存-主存层次
    - 原理：局部性原理
    - 实现：在CPU与主存之间增加一层速度快（容量小）的Cache
    - 目的：解决主存速度不足的问题
  - 主存-辅存层次
    - 原理：局部性原理
    - 实现：主存之外增加辅助存储器（磁盘、 SD卡、 U盘等）
    - 目的：解决主存容量不足的问题
  - 局部性原理
    - 局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。

  

### 2.4 主存储器与辅助存储器

- 计算机断电，内存数据丢失

- 计算机断电，磁盘数据不会丢失

- 主存

  - RAM（随机存取存储器： Random Access Memory）
  - RAM 通过电容存储数据，必须隔一段时间刷新一次
  - 如果掉电，那么一段时间后将丢失所有数据
  - 内存与CPU如何交互的

  ![](https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801143858.jpg)

  - 32位系统：2^32 = 4 × 2^30 = 4𝐺𝐵 
  - 64位系统：2^64 = 2^34 × 2^30 = 2^34𝐺𝐵=2^24T𝐵=2^14EB=2^4EB
  - 32位的系统最大支持4GB的内存寻址范围，每一个字节都对应一个内存地址。内存地址由 0 开始编号，比如第 1 个地址是 0，第 2 个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。
  - 工作原理
    - 字：是指存放在一个存储单元中的二进制代码组合
    - 字块：存储在连续的存储单元中而被看作是一个单元的一组字
    - 假设一个字有32位，一个字块共B个字，主存共M个字块
      - B×M = 主存总字数；B×M×32 = 主存总容量(bits)
    - 字的地址包含两个部分，前m位指定字块的地址，后b位指定字在字块中的地址
      - 2^𝑚 = 𝑀 , 前m位能表示出的寻址范围是0--2^𝑚
      - 2^𝒃 = 𝐵，后b位能表示出的寻址范围是0--2^b

- 辅存：磁盘

  - 表面是可磁化的硬磁特性材料
  - 移动磁头径向运动读取磁道信息
  - 磁道、扇区、磁头位置、磁头方向
  - 寻道调度算法

    - 先来先服务算法
      - 按顺序访问进程的磁道读写需求
    - 最短寻道时间优先
      - 与磁头当前位置有关
      - 优先访问离磁头最近的磁道
    - 扫描算法（电梯算法）
      - 每次只往一个方向移动
      - 到达一个方向需要服务的尽头再反方向移动
    - 循环扫描算法
      - 每次只往一个方向移动
      - 一个方向到头后再从头开始从同一个方向开始移动



### 2.5 高速缓存

- 为了解决CPU与主存的速度不匹配的问题

- 缓存与主存的关系

  - 存储的逻辑结构类似
  - 缓存的容量较小
  - 缓存的速度更快

- 在主存缓存层次结构中的工作原理

  - CPU需要的数据在缓存里：直接获取
  - CPU需要的数据不在缓存里：需要去主存拿，替换策略
    - 需要性能良好的缓存替换策略
  - 命中率：从缓存取数据的命中率
    - 命中率是衡量缓存的重要性能指标
    - 理论上CPU每次都能从高速缓存取数据的时候，命中率为1
    - 访问主存次数： N𝑚，访问Cache次数： N𝑐
    - 命中率ℎ =𝑁𝑐/(𝑁𝑐＋𝑁𝑚)
  - 访问效率： 𝑒
    - 访问主存时间： 𝑡𝑚 ，访问缓存时间：𝑡𝑐
    - 访问Cache-主存系统平均时间： 𝑡𝑎 = ℎ×𝑡𝑐 + (1 − ℎ)×𝑡𝑚
    - 𝑒 =𝑡𝑐/𝑡𝑎

- 高速缓存替换策略

  - 随机算法
  - 先进先出算法(FIFO)
    - 把高速缓存看做是一个先进先出的队列
    - 优先替换最先进入队列的字块
  - 最不经常使用算法(LFU)
    - 优先淘汰最不经常使用的字块
    - 需要额外的空间记录字块的使用频率
  - 最近最少使用算法(LRU)
    - 优先淘汰一段时间内没有使用的字块
    - 如果正在使用的字块在缓存就将其移到表头，保证链表头部节点是最近使用的
    - 有多种实现方法，一般使用双向链表

  

### 2.6 计算机的指令系统

- 计算机指令

  - 计算机通过指令指挥计算机工作。
  - CPU被时钟驱动，不断的读取PC指针指向的指令，并增加PC指针，从内存中读取指令并执行。(如此周而复始)
  - 不同的CPU架构使用不同指令。目前使用最广泛的是RISC(Reduced instruction set computer,精简指令集)

- 机器指令的形式

  - 机器指令主要由两部分组成：操作码、地址码
  - 操作码指明指令所要完成的操作
  - 操作码的位数反映了机器的操作种类，如果操作码有8位就有2^8 = 256种操作
  - 地址码直接给出操作数或者操作数的地址
  - 分三地址指令、二地址指令和一地址指令与零地址指令
    - 零地址指令
      - 在机器指令中无地址码
      - 空操作、停机操作、中断返回操作等
    - 一地址指令
      - (addr1)OP→ (addr1)：自己对自己的操作
      - (addr1)OP(ACC) → (addr1)：自增操作
    - 二地址指令
      - (addr1)OP(addr2) → (addr1)或(addr2)： 结果放在addr1或addr2)
    - 三地址指令
      - 一个操作码和三个地址码
      - (addr1)OP(addr2) → (addr3)：结果放在addr3， 例如： 1+2=3

- 操作类型

  - 数据传输
    - 寄存器之间、寄存器与存储单元、存储单元之间传送
    - 数据读写、交换地址数据、清零置一等操作

- load/store指令用来从内存中读/写入内存。通常会有多个版本的实现，助记符是:
      - load类: Iw,Ib,Ih
      - store类: sw,sb,sh

  - 算术逻辑
    - 操作数之间的加减乘除运算
      - 加减乘除等：addi, subi, divi, multi
    - 操作数的与或非等逻辑位运算
      - 位运算指令：and/or/xor

- 移位操作

  - 数据左移（乘2）、数据右移（除2）
  - 完成数据在算术逻辑单元的必要操作
  - 控制指令
    - 等待指令、停机指令、空操作指令、中断指令等

- 寻址方式

  - 指令寻址

    - 顺序寻址

    - 跳跃寻址

      | 地址 |   指令    |
      | :--: | :-------: |
      | 101  | MOV R0,R1 |
      | 102  | ADD R1,R2 |
      | 103  |  JMP 102  |

  - 数据寻址

    - 立即寻址
      - 指令直接获得操作数
      - 无需访问存储器
      - 优点：速度快
      - 缺点：地址码位数限制操作数表示范围
    - 直接寻址
      - 直接给出操作数在主存的地址
      - 寻找操作数简单，无需计算数据地址
      - 优点：寻找操作数简单
      - 缺点：地址码位数限制操作数表示范围
    - 间接寻址
      - 指令地址码给出的是操作数地址的地址
      - 需要访问一次或多次主存来获取操作数
      - 优点：操作数寻址范围大
      - 缺点：速度较慢

  

### 2.7 计算机的控制器

- 控制器是协调和控制计算机运行的
- 程序计数器
  - 程序计数器用来存储下一条指令的地址
  - 循环从程序计数器中拿出指令
  - 当指令被拿出时，指向下一条指令
- 时序发生器
  - 电气工程领域，用于发送时序脉冲
  - CPU依据不同的时序脉冲有节奏的进行工作
- 指令译码器
  - 指令译码器是控制器的主要部件之一
  - 计算机指令由操作码和地址码组成
  - 翻译操作码对应的操作以及控制传输地址码对应的数据
- 指令寄存器
  - 指令寄存器也是控制器的主要部件之一
  - 从主存或高速缓存取计算机指令
- 主存地址寄存器
  - 保存当前CPU正要访问的内存单元的地址
- 主存数据寄存器
  - 保存当前CPU正要读或写的主存数据
- 通用寄存器
  - 用于暂时存放或传送数据或指令
  - 可保存ALU的运算中间结果
  - 容量比一般专用寄存器要大



### 2.8 计算机的运算器

- 运算器是用来进行数据运算加工的

- 数据缓冲器
  - 分为输入缓冲和输出缓冲
  - 输入缓冲暂时存放外设送过来的数据
  - 输出缓冲暂时存放送往外设的数据
- ALU
  - ALU：算术逻辑单元，是运算器的主要组成
  - 常见的位运算（左右移、与或非等）
  - 算术运算（加减乘除等）
- 通用寄存器
  - 用于暂时存放或传送数据或指令
  - 可保存ALU的运算中间结果
  - 容量比一般专用寄存器要大
- 状态字寄存器
  - 存放运算状态（条件码、进位、溢出、结果正负等）
  - 存放运算控制信息（调试跟踪标记位、允许中断位等）
- 总线



### 2.9 计算机指令的执行过程

- 指令执行过程

  - 取指令 
    - 从缓存取指令
    - 送到指令寄存器
  - 分析指令
    - 指令译码器译码
    - 发出控制信号
    - 程序计数器+1
  - 执行指令
    - 装载数据到寄存器
    - ALU处理数据
    - 记录运算状态
    - 送出运算结果

  ![](https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801144002.jpg)

- CPU的流水线设计

  - 提高CPU的综合利用率
  - 类似工厂的装配线
  - 工厂的装配线使得多个产品可以同时被加工
  - 在同一个时刻，不同产品均位于不同的加工阶段
  - 串行执行m条指令： 𝑇1 = 3t × 𝑚
  - 流水线执行m条指令： 𝑇2 = 𝑡 × (𝑚 + 2)
  - 流水线执行效率:H=𝑇2/𝑇1= 𝑡 × (𝑚 + 2)/3t × 𝑚=1/3+1/3m, m很大的情况下是串行执行的3倍效率

  | 指令 | 时间片 | 时间片   | 时间片   | 时间片   | 时间片   |
  | ---- | ------ | -------- | -------- | -------- | -------- |
  | 1    | 取指令 | 分析指令 | 执行指令 |          |          |
  | 2    |        | 取指令   | 分析指令 | 执行指令 |          |
  | 3    |        |          | 取指令   | 分析指令 | 执行指令 |






## 3.计算篇

### 3.1 进制运算的基础

- 什么是进制
  - 进位制是一种记数方式，亦称进位计数法或位值计数法
  - 有限种数字符号来表示无限的数值
  - 使用的数字符号的数目称为这种进位制的基数或底数
  - 计算机喜欢二进制，但是二进制表达太长了
  - 使用大进制位可以解决这个问题
  - 八进制、十六进制满足2的n次方的要求
  - 二进制
    - 1024=0b1000000000 
  - 八进制
    - 1024=0o2000
  - 十进制： [0-9] 
  - 十六进制
    - MAC地址：[0-9]和A、 B、 C、 D、 E、 F
    - 1024=0x400
  - 二十进制
    - 玛雅文明的玛雅数字
    - 因努伊特的因努伊特数字
  - 六十进制
    - 时间、坐标、角度等量化数据
- 进制的表示法
  - 正整数N，基数为r，位数为n
  - N=𝑑𝑛−1×r𝑛−1 +𝑑𝑛−2× r𝑛−2 + ⋯ + 𝑑1×𝑟 + 𝑑0
  - N= 1024  = 1 ×10^3 +0×10^3+ 2 × 10^1 + 4× 10^0
  - 𝑁 = 10000000000  = 1 × 2^10
- 二进制转十进制的方法
  - 按权展开法
  - 𝑁 = 01100101 = 1 × 2^6 + 1 × 2^5 + 1 ×2^2 + 1 = 101
  - 小数的按权展开法
  - 𝑁 = 0.11001 = 1×2^−1 + 1×2^−2 + 1× 2^−5 = 0.78125=25/32
- 十进制转二进制的方法
  - （整数）重复相除法
  - 重复除以2 ，得商， 取余数，最后一个余数为最高位
  - （小数）重复相乘法
  - 重复乘以2， 得积 ，取1，第一个余数为最高位



### 3.2 原码&反码&补码

- 使用0表示正数，使用1表示负数，最高位表示符号位，其它都是数字位

- +237=011101101， -237=111101101

- 两个字节16位表示+237 【0】 0 0 0 0 0 0 0 1 1 1 0 1 1 0 1

- 原码表示法

  - 使用0表示正数、 1表示负数
  - 规定符号位位于数值第一位
  - 表达简单明了，是人类最容易理解的表示法
  - 0有两种表示方法： 00、 10
  - 原码进行运算非常复杂，特别是两个操作数符号不同的时候
    - 判断两个操作数绝对值大小
    - 使用绝对值大的数减去绝对值小的数
    - 对于符号值，以绝对值大的为准
  - 希望找到不同符号操作数更加简单的运算方法
  - 希望找到使用正数代替负数的方法
  - 使用加法操作代替减法操作，从而消除减法

- 补码表示法

  - 整数的补码
    - 如果 x∈[0, 2^𝑛) X=x  ，n是数字位的个数
    - 如果 x∈[−2^𝑛, 0) X=2^(𝑛+1) + 𝑥
      - 例如：n=4， x=13，计算x的二进制原码和补码
        - 原码： x=0,1101
        - 补码： x=0,1101
      - 例如：n=4，x=-13，计算x的二进制原码和补码
        - 原码： x=1,1101
        - 补码： 2^(𝑛+1) + 𝑥= 2^(4+1() − 13 = 100000 − 1101 = 10011
  - 小数的补码
    - 如果 x∈[0, 1) X=x  
    - 如果 x∈[−1, 0) X=2+x
    - 规律：小数的反码等于原码除符号位外按位取反，补码等于反码+1
  - 在计算补码的过程中，还是使用了减法
  - 需要寻找使用正数代替负数的方法

- 反码表示法

  - 反码的目的是找出原码和补码之间的规律，消除转换过程中的减法
  - 如果 x∈[0, 2^𝑛) X=x  ，n是数字位的个数
  - 如果 x∈[−2^𝑛, 0) X=（2^(𝑛+1)-1） + 𝑥
  - 规律：负数的反码等于原码除符号位外按位取反，负数的补码等于反码+1
    - -13， 原码：1,1101 ，反码：1,0011 ，补码：1,0010
    - -7， 原码： 1,0111，反码： 1,1001，补码： 1,1000
    - -1， 原码： 1,0001 ，反码：1,1111，补码： 1,1110
  - x=-13，计算x的二进制原码和反码
    - 原码： x=1,1101
    - 反码： (2𝑛+1−1) + 𝑥 = (2^4+1−1) − 13 = 011111 − 1101 = 1,0010
    - 反码： x=1,0010

  

  ![](https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801144040.jpg)



### 3.3 定点数与浮点数

- 定点数的表示方法

  - 小数点固定在某个位置的数称之为定点数
  - 纯小数 ：符号位【小数点】数值位
  - 纯整数：符号位 数值位 【小数点】
  - 其它小数需要乘以比例因子以满足定点数保存格式，10.01 需要左移两位或者右移两位
  - 计算机中的存储形式见下表，小数点不显示

  | 数值    | 符号位 | 数值位 |
  | :------ | :----: | :----: |
  | 0.1011  |   0    |  1011  |
  | -0.1011 |   1    |  1011  |
  | 1011    |   0    |  1011  |
  | -1011   |   1    |  1011  |

- 浮点数的表示方法

  - 计算机处理的很大程度上不是纯小数或纯整数

  - 数据范围很大，定点数难以表达

  - 浮点数的表示格式

    - 类比科学计数法：123450000000 = 1.2345 × 10^11 ， 1.2345：尾数 ，10：基数 ，11：阶码
    - 𝑁 = 𝑆 × 𝑟^𝑗 ，S：尾数， r：基数， j：阶码
    - 阶码符号位|阶码数值位|尾数符号位|尾数数值位
    - 尾数规定使用纯小数
    - 11.0101 = 0.110101 × 2^10
    - 11.0101 = 0.0110101 × 2^11
    - 计算机中的存储形式见下表，小数点不显示

    | 数字             | 阶码符号位 | 阶码数值位 | 尾数符号位 | 尾数数值位（8位） |
    | ---------------- | ---------- | ---------- | ---------- | ----------------- |
    | 0.110101 × 2^10  | 0          | 10         | 0          | 1010100           |
    | 0.0110101 × 2^11 | 0          | 11         | 0          | 01101010          |

    

  - 浮点数的表示范围

    - 假设阶码数值取m位，尾数数值取n位
    - 阶码表示范围： [−(𝟐^𝒎 − 𝟏),  𝟐^𝒎 − 𝟏]
    - 尾数表示范围： [−(𝟏 − 𝟐^−𝒏), −(𝟐^−𝒏)] [𝟐^−𝒏,  𝟏 − 𝟐−^𝒏]
    - 单精度浮点数：使用4字节、 32位来表达浮点数(float)
    - 双精度浮点数：使用8字节、 64位来表达浮点数(double)

    ![](https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801144101.jpg)

  - 浮点数的规格化

    - 尾数规定使用纯小数
    - 尾数最高位必须是1
    - 例如：11.0101 = 0.110101 × 2^10

- 两者的对比

  -  当定点数与浮点数位数相同时， 浮点数表示的范围更大
  -  当浮点数尾数为规格化数时， 浮点数的精度更高（尾数存8位，前面的0多了丢失的精度就更多）
  -  浮点数运算包含阶码和尾数， 浮点数的运算更为复杂
  -  浮点数在数的表示范围、精度、溢出处理、编程等方面均优于定点数
  -  浮点数在数的运算规则、运算速度、硬件成本方面不如定点数



### 3.4 定点数的加减法运算

- 整数加法：A 补 + B 补 = 𝐴 + 𝐵 补 (𝑚𝑜𝑑2^(𝑛+1))
- 小数加法：A 补 + B 补 = 𝐴 + 𝐵 补 (𝑚𝑜𝑑2)
- 数值位与符号位一同运算，并将符号位产生的进位自然丢掉
- 整数减法：A 补 − B 补 = 𝐴 + (−𝐵) 补  (𝑚𝑜𝑑2^(𝑛+1))
- 小数减法：A 补 − B 补 = 𝐴 + (−𝐵) 补 (𝑚𝑜𝑑2)
- -B[补]等于B[补]连同符号位按位取反，末位加一，B 补 = 1,0010101， (−B) 补 = 0,1101011
- 负数的反码等于原码按位取反，补码等于反码+1
- 例如： A=-110010， B=001101，求A+B
  - A[补] = 1,001110
  - B 补 = B[原] = 0,001101
  - A 补 + B 补 = (A + B) 补 =1,011011
  - (A + B)原 = −100101
- 例如：A=11001000， B=-00110100，求A-B
  - A 补 = A[原] = 0,11001000
  - B 补 = 1,11001100
  - (−B) 补 = 0,00110100
  - A 补 − B 补 = A + (−B) 补=0,11111100
  - A − B（原） = 111111100

- 双符号位判断溢出
  - 双符号位判断法
    - 单符号位表示变成双符号位： 0=>00,1=>11
    - 双符号位产生的进位丢弃
    - 结果的双符号位不同则表示溢出



### 3.5 浮点数的加减法运算

- 𝑥 = 𝑆𝑥 × 𝑟^𝑗𝑥，𝑥 = 0.1101 × 2^01

- 𝑦 = 𝑆𝑦 × 𝑟^𝑗y，𝑦 = (−0.1010) × 2^11

- 対阶

  - 対阶的目的是使得两个浮点数阶码一致，使得尾数可以进行运算
  - 浮点数尾数运算简单
  - 浮点数位数实际小数位与阶码有关
  - 阶码按小阶看齐大阶的原则

  | 数字             | 阶码符号位 | 阶码数值位 | 尾数符号位 | 尾数数值位（8位） |
  | ---------------- | ---------- | ---------- | ---------- | ----------------- |
  | 0.1101 × 2^01    | 00         | 0001       | 00         | 1101              |
  | (−0.1010) × 2^11 | 00         | 0011       | 01         | 1010              |

  - 対阶操作：将x的数值右移两位，𝑥 = 0.001101 × 2^11

  | 数字             | 阶码符号位 | 阶码数值位 | 尾数符号位 | 尾数数值位（8位）  |
  | ---------------- | ---------- | ---------- | ---------- | ------------------ |
  | 0.001101 × 2^11  | 00         | **0011**   | 00         | 0011(01)舍弃后两位 |
  | (−0.1010) × 2^11 | 00         | 0011       | 01         | 1010               |

- 尾数求和

  - 使用补码进行运算
  - 减法运算转化为加法运算： A - B = A + (-B)
  - 𝑥[原] = 00.0011，𝑥[补] = 00.0011
  - 𝑦[原] = 11.1010，𝑦[补] = 11.0110
  - S = (𝑥 + 𝑦)[补] = 11.1001

  | 数字    | 阶码符号位 | 阶码数值位 | 尾数符号位 | 尾数数值位（8位） |
  | ------- | ---------- | ---------- | ---------- | ----------------- |
  | 11.1001 | 00         | **0011**   | 11         | 1001              |

- 尾数规格化

  - ◆ 对补码进行规格化需要判断两种情况： S>0和S<0
  - S[补] = 00.1xxxxxx(𝑆 > 0)
  - S[补] = 11.0xxxxxx(𝑆 < 0)
  - 如果不满足此格式，需要进行左移， 同时阶码相应变化，以满足规格化
  - S = (𝑥 + 𝑦)[补] = 11.1001，不满足约定格式
  - S = (𝑥 + 𝑦)[补] = 11. (1)0010(左移舍弃，阶码数值位也要相应变化)

  | 数字    | 阶码符号位 | 阶码数值位 | 尾数符号位 | 尾数数值位（8位） |
  | ------- | ---------- | ---------- | ---------- | ----------------- |
  | 11.0010 | 00         | 0010       | 11         | 0010              |

  - S = 𝑥 + 𝑦 补 = 11.0010，𝑥 + 𝑦 原 = −0.1110
  - 𝑥 + 𝑦 = −0.1110× 2^10
  - 一般情况下都是左移，符号位不一致下需要右移(定点运算的溢出情况)
  - 右移的话则需要进行舍入操作

- 舍入

  - 0舍1入” 法（二进制的四舍五入）
  - S 补 = 10.10110111，符号位不一致，右移舍弃尾数再+1， S 补 = 11.01011011(1)+1=11.01011100
  - 右移阶码要+1

- 溢出判断

  - 定点运算双符号位不一致为溢出
  - 浮点运算尾数双符号位不一致不算溢出，因为尾数双符号位可以进行右规
  - 浮点运算主要通过阶码的双符号位判断是否溢出
  - 如果规格化后，阶码双符号位不一致，则认为是溢出

![](https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801144134.jpg)



### 3.6 浮点数的乘除法运算

- 乘法：阶码相加，尾数求积
- 𝑥 × 𝑦 = (𝑆𝑥 × 𝑆𝑦) × 𝑟^(𝑗𝑥+𝑗y)
- 除法：阶码相减，尾数求商
- 𝑥/𝑦 = (𝑆𝑥/𝑆𝑦) × 𝑟^(𝑗𝑥−𝑗y)

- 阶码运算
- 尾数运算
- 尾数规格化
- 舍入
- 溢出判断
- 例如： 𝑥 = 0.11010011 × 2^1101， 𝑦 = 0.11101110 × 2^0001，假设阶码4位，尾数8位，计算x * y
  - 𝑥 × 𝑦 = (𝑆𝑥 × 𝑆𝑦) ×^𝑟(𝑗𝑥+𝑗y)
  - = (0.11010011 × 0.11101110) × 𝑟^(1101+0001)
  - = 0.11000100(保留八位) × 𝑟^1110



## 4.关于我

一个专注基础知识的十二线小码农，本着 **基础，体系，实践，分享** 的学习理念，在自我提升的同时分享自己的心得体会，不断完善，周而复始。

[个人网站 basedev.cn](http://basedev.cn/)  

[Github](https://github.com/jaydroid1024)

BaseDev系列只整理点到为止的知识纲领，不求甚解；欲知其所以然者还得回归书本且付诸实践。



## 5.参考

- [重学操作系统 | 拉钩教育](https://kaiwu.lagou.com/course/courseInfo.htm?sid=20-h5Url-0&courseId=478&lagoufrom=noapp&sharetype=wx_friend#/content)

- [编程必备基础 | 慕课网](https://coding.imooc.com/class/package/355.html)



