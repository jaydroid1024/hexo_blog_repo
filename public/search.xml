<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>筑基系列-算法大全（更新中...）</title>
      <link href="2021/10/31/code-all/"/>
      <url>2021/10/31/code-all/</url>
      
        <content type="html"><![CDATA[<details>      <summary> <b> Solution2：两次循环+栈，时间：O(N),空间：O(N) </b></summary>         <pre><code>    代码  </code></pre></details><h3 id="01-组中重复的数字"><a href="#01-组中重复的数字" class="headerlink" title="01 组中重复的数字"></a>01 组中重复的数字</h3><table><thead><tr><th>剑指 Offer 03</th><th><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中重复的数字</a></th><th><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/" target="_blank" rel="noopener">LeetCode 题解</a></th></tr></thead></table><h3 id="01-从尾到头打印链表"><a href="#01-从尾到头打印链表" class="headerlink" title="01 从尾到头打印链表"></a>01 从尾到头打印链表</h3><table><thead><tr><th>剑指 Offer 06</th><th><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof" target="_blank" rel="noopener">从尾到头打印链表</a></th><th><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution" target="_blank" rel="noopener">LeetCode 题解</a></th></tr></thead></table><details>      <summary> <b> Solution1：两次循环，时间：O(N)，空间：O(N)</b> </summary>         <pre><code>/*  Solution1：两次循环，时间：O(N),空间：O(N)  1. while 循环遍历链表求出总长度 length  2. 根据length构建整数型数组 array  3. for 循环向 array 中后插法插入数据 */class Solution1 {    fun reversePrint(head: ListNode?): IntArray {        var temp = head        var length = 0        //1. while 循环遍历链表求出总长度 length        while (temp != null) {            length++            temp = temp.next        }        //2. 根据length构建整数型数组 array        val array = IntArray(length)        temp = head//temp指针指向头节点再利用        //3. for 循环向 array 中后插法插入数据        for (i in 0 until length) {            array[length - 1 - i] = temp?.`val` ?: 0            temp = temp?.next        }        return array    }}  </code></pre></details><details>      <summary> <b> Solution2：两次循环+栈，时间：O(N),空间：O(N) </b></summary>         <pre><code>/*    Solution2：两次循环+栈，时间：O(N),空间：O(N)    1. 入栈： 遍历链表，将各节点值 addLast 入栈。（借助 LinkedList 的addLast()方法）。    2. 出栈： 将各节点值 removeLast 出栈，存储于数组并返回。 */class Solution2 {    fun reversePrint(head: ListNode?): IntArray {        //stack.push(temp) / stack.pop() ，Java 中的Stack数据结构是继承自Vector，addElement方法是通过大锁保证线程安全的        //Stack<listnode> stack = new Stack&lt;&gt;();        //通过 LinkedList 来模拟栈操作可以提高效率        var temp = head        val stack = LinkedList<int>()        //1. 入栈： 遍历链表，将各节点值 addLast 入栈。（借助 LinkedList 的addLast()方法）。        while (temp != null) {            stack.addLast(temp.`val`)            temp = temp.next        }        val res = IntArray(stack.size)        //2. 出栈： 将各节点值 removeLast 出栈，存储于数组并返回。        for (i in res.indices) {            res[i] = stack.removeLast()        }        return res    }}  </int></listnode></code></pre></details><details>      <summary> <b> Solution3：递归，时间：O(N)，空间：O(N) </b></summary>         <pre><code>/*    Solution3：递归，时间：O(N),空间：O(N)    1. 递推阶段：每次传入 head.next ，以 head == null（即走过链表尾部节点）为递归终止条件，此时直接返回。    2. 回溯阶段：层层回溯时，将当前节点值加入列表，即tmp.add(head.val)。    3. 转换数据：将列表 tmp 转化为数组 res ，并返回即可。 */class Solution3 {    var tmp = ArrayList<int>()    fun reversePrint(head: ListNode?): IntArray {        recur(head)        //转换数据：将列表 tmp 转化为数组 res ，并返回即可。        val res = IntArray(tmp.size)        for (i in res.indices) res[i] = tmp[i]        return res    }    fun recur(head: ListNode?) {    //1. 递推阶段：每次传入 head.next ，以 head == null（即走过链表尾部节点）为递归终止条件，此时直接返回。    if (head == null) return    recur(head.next)    //2. 回溯阶段：层层回溯时，将当前节点值加入列表，即tmp.add(head.val)。    tmp.add(head.`val`)    }}//递归2class Solution31 {    private lateinit var res: IntArray    private var i = 0 //测量栈深度，初始化数组    private var x = 0 //数组下标    fun reversePrint(head: ListNode?): IntArray {        solve(head)        return res    }    fun solve(head: ListNode?) {    //1. 递推阶段：每次传入 head.next ，以 head == null（即走过链表尾部节点）为递归终止条件，此时获取了递归深度可以初始化数组再返回。    if (head == null) {        res = IntArray(i)        return    }    i++    solve(head.next)    //2. 回溯阶段：层层回溯时，将当前节点值加入列表，即tmp.add(head.val)。    res[x] = head.`val`    x++    }}  </int></code></pre></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin | 委托(Delegation﻿)详解</title>
      <link href="2021/08/31/kotlin-delegate/"/>
      <url>2021/08/31/kotlin-delegate/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/post_banner_jay.png" alt=""></p><h1 id="Kotlin-委托-Delegation-详解"><a href="#Kotlin-委托-Delegation-详解" class="headerlink" title="Kotlin | 委托(Delegation﻿)详解"></a>Kotlin | 委托(Delegation﻿)详解</h1><p>本文要点概述</p><ul><li><p>辨析委托模式与代理模式 </p></li><li><p>接口委托(Delegated interface)</p></li><li><p>属性委托(Delegated properties)</p></li><li><p>映射委托(Map delegation)</p></li><li><p>延迟属性(lazy properties)</p></li><li><p>非空属性(Delegates.notNull)</p></li><li><p>变量值更新后的监听(Delegates.observable)</p></li><li><p>变量值更新前的拦截(Delegates.vetoable)</p></li><li><p>ViewBinding+属性委托</p></li><li><p>ViewModel+属性委托</p></li><li><p>SP +属性委托</p></li></ul><h2 id="1-委托模式-VS-代理模式"><a href="#1-委托模式-VS-代理模式" class="headerlink" title="1.委托模式 VS 代理模式"></a>1.委托模式 VS 代理模式</h2><p>委托模式和代理模式都属于结构型设计模式，结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。</p><h3 id="1-1-代理模式（Proxy-Pattern）"><a href="#1-1-代理模式（Proxy-Pattern）" class="headerlink" title="1.1 代理模式（Proxy Pattern）"></a>1.1 代理模式（Proxy Pattern）</h3><p>在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。在代理类中还可以提供额外的逻辑， 例如当真实对象上的操作是资源密集型任务时可以在代理中添加缓存操作，或者在调用真实对象操作之前做一些权限校验或检查行为等。一般情况下，我们让代理类和原始类实现同样的接口或者让代理类继承原始类来实现代理模式。</p><h3 id="1-2-委托模式（Delegation-pattern）"><a href="#1-2-委托模式（Delegation-pattern）" class="headerlink" title="1.2 委托模式（Delegation pattern）"></a>1.2 委托模式（Delegation pattern）</h3><p>委托可以理解为是代理的一种变体，是一种使组合像继承一样实现代码复用的另一种设计模式。主要目的是组合委托调用和代码复用而不考虑控制访问等逻辑。在委托中处理请求涉及两个对象，委托方将操作交给受托方实现，类似于子类将请求推迟到父类。一般情况下，委托也可以通过接口约束或受托方继承委托方实现委托模式。</p><h3 id="1-3-法律层面区分代理与委托"><a href="#1-3-法律层面区分代理与委托" class="headerlink" title="1.3 法律层面区分代理与委托"></a>1.3 法律层面区分代理与委托</h3><p>为了加深代理和委托的理解，我们看一下<strong>法律层面的代理与委托的不同之处</strong></p><ul><li><p>民事主体活动的名义不同。 代理是指被代理人在代理权限范围内，以被代理人的名义同第三人独立为民事法律行为，由此产生的法律效果直接归属于被代理人的一种法律制度，即代理人必须以被代理人的名义为代理行为。 委托则是委托人委托受托人处理一定事务，受托人接受委托的协议，受托人可以以委托人的名义活动，也可以以自己的名义活动。</p></li><li><p>适用范围不尽相同：代理只是代理人在代理权范围内以被代理人的名义同第三人的民事法律行为；而委托中的受托人办理委托人委托事务的行为可以是民事法律行为，还可以是有经济意义的行为（如整理账簿）和单纯的事实行为（如抄写文件）。</p></li><li><p>效力范围不同：代理涉及三方当事人，即被代理人、代理人、第三人；委托则属于双方当事人之间的关系，即委托人、受托人。</p></li></ul><h3 id="1-4-代码实现委托和代理"><a href="#1-4-代码实现委托和代理" class="headerlink" title="1.4 代码实现委托和代理"></a>1.4 代码实现委托和代理</h3><p>代理模式和委托模式在代码实现上并没有太多差别，他们的差异还是在使用场景上，为了能更好的理解代理模式和委托模式，我们再来看看如何通过代码来实现</p><p>代码参考自：<strong><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener"> java-design-patterns</a></strong></p><p><a href="https://github.com/iluwatar/java-design-patterns/tree/master/delegation" target="_blank" rel="noopener">delegation</a> ：打印机控制器将打印任务委托给不同的打印机</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 委托二人组：打印机控制器、打印机（惠普打印机、佳能打印机、爱普生打印机）</span><span class="token comment" spellcheck="true">// 电脑上有三种打印机设备的驱动，分别将打印任务委托给对应的打印机执行具体的打印操作</span>PrinterController hpPrinterController <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrinterController</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HpPrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PrinterController canonPrinterController <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrinterController</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CanonPrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PrinterController epsonPrinterController <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrinterController</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EpsonPrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hpPrinterController<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>MESSAGE_TO_PRINT<span class="token punctuation">)</span><span class="token punctuation">;</span>canonPrinterController<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>MESSAGE_TO_PRINT<span class="token punctuation">)</span><span class="token punctuation">;</span>epsonPrinterController<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>MESSAGE_TO_PRINT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//打印机控制器</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrinterController</span> <span class="token keyword">implements</span> <span class="token class-name">Printer</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> Printer printer<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">PrinterController</span><span class="token punctuation">(</span>Printer printer<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>printer <span class="token operator">=</span> printer<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/**    * 此方法是从 {@link Printer} 实现的，在提供实现时它会调用通过构造函数传递的委托方的 print 方法。    * 这意味着委托关系一旦确定后，调用者不关心实现类，只关心拥有的打印机控制器就行。   */</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>    printer<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//三个打印机也实现了 Printer 接口 并提供了具体的打印功能，代码可以参考上面的链接</span></code></pre><p><a href="https://github.com/iluwatar/java-design-patterns/tree/master/proxy" target="_blank" rel="noopener">proxy</a> ：巫师要进入塔内修炼法术，象牙塔只能通过代理访问并确保只有前三个巫师可以进入。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 代理三人组：巫师塔代理、象牙塔、巫师</span>WizardTowerProxy proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WizardTowerProxy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IvoryTower</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>proxy<span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Wizard</span><span class="token punctuation">(</span><span class="token string">"Red wizard"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>proxy<span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Wizard</span><span class="token punctuation">(</span><span class="token string">"White wizard"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>proxy<span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Wizard</span><span class="token punctuation">(</span><span class="token string">"Black wizard"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>proxy<span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Wizard</span><span class="token punctuation">(</span><span class="token string">"Green wizard"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>proxy<span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Wizard</span><span class="token punctuation">(</span><span class="token string">"Brown wizard"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//代理方：塔代理</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WizardTowerProxy</span> <span class="token keyword">implements</span> <span class="token class-name">WizardTower</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NUM_WIZARDS_ALLOWED <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> WizardTower tower<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> numWizards<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//被代理方通过构造方法传入</span>  <span class="token keyword">public</span> <span class="token function">WizardTowerProxy</span><span class="token punctuation">(</span>WizardTower tower<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tower <span class="token operator">=</span> tower<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//对象牙塔的访问的代理。第三方通过 enter 方法进入</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">enter</span><span class="token punctuation">(</span>Wizard wizard<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//超过三个就不让进了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numWizards <span class="token operator">&lt;</span> NUM_WIZARDS_ALLOWED<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//代理方授权执行操作</span>      tower<span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span>wizard<span class="token punctuation">)</span><span class="token punctuation">;</span>      numWizards<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"{} is not allowed to enter!"</span> <span class="token operator">+</span> wizard<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//被代理方：塔</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IvoryTower</span> <span class="token keyword">implements</span> <span class="token class-name">WizardTower</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">enter</span><span class="token punctuation">(</span>Wizard wizard<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"{} enters the tower."</span> <span class="token operator">+</span> wizard<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//第三方：巫师</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Wizard</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">Wizard</span><span class="token punctuation">(</span>String wizard<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> wizard<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> name<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="2-接口委托-Delegated-interface"><a href="#2-接口委托-Delegated-interface" class="headerlink" title="2. 接口委托(Delegated interface)"></a>2. 接口委托(Delegated interface)</h2><p>我们看看Kotlin 是怎么内置接口委托的，先看一下实现的委托模式的传统方式</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> Api <span class="token punctuation">{</span>    <span class="token keyword">fun</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">fun</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">fun</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//委托方</span><span class="token keyword">class</span> ApiImpl <span class="token operator">:</span> Api <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ApiImpl-a"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ApiImpl-b"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ApiImpl-c"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//受托方</span><span class="token keyword">class</span> <span class="token function">ApiWrapper</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> api<span class="token operator">:</span> Api<span class="token punctuation">)</span> <span class="token operator">:</span> Api <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ApiWrapper-a"</span><span class="token punctuation">)</span>        api<span class="token punctuation">.</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ApiWrapper-b"</span><span class="token punctuation">)</span>        api<span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ApiWrapper-c"</span><span class="token punctuation">)</span>        api<span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>再看看Kotlin 通过 <code>by</code> 关键字实现的简便方式</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//变量 api代替 ApiWrapperWithDelegate 实现了 Api 接口，ApiWrapperWithDelegate 就可以灵活的复写需要的函数</span><span class="token keyword">class</span> <span class="token function">ApiWrapperWithDelegate</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> api<span class="token operator">:</span> Api<span class="token punctuation">)</span> <span class="token operator">:</span> Api <span class="token keyword">by</span> api <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ApiWrapperWithDelegate-a"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//反编译 Java 后的代码和 ApiWrapper 是一样的</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> ApiWrapperWithDelegate implements Api <span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> Api api<span class="token punctuation">;</span>   <span class="token keyword">public</span> void <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      String var1 <span class="token operator">=</span> <span class="token string">"ApiWrapperWithDelegate-a"</span><span class="token punctuation">;</span>      boolean var2 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token function">ApiWrapperWithDelegate</span><span class="token punctuation">(</span><span class="token annotation builtin">@NotNull</span> Api api<span class="token punctuation">)</span> <span class="token punctuation">{</span>      Intrinsics<span class="token punctuation">.</span><span class="token function">checkNotNullParameter</span><span class="token punctuation">(</span>api<span class="token punctuation">,</span> <span class="token string">"api"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>api <span class="token operator">=</span> api<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> void <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>api<span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> void <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>api<span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到 Kotlin 内置的接口委托是编译器帮我们生成了相关代码</p><p>再看一个实践的例子：利用接口代理实现一个集成了 map 和 list 的超级集合</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 对象 list 和 map 代理 SupperArrayWithDelegate 实现 MutableList，MutableMap</span><span class="token keyword">class</span> SupperArrayWithDelegate<span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> list<span class="token operator">:</span> MutableList<span class="token operator">&lt;</span>E<span class="token operator">?</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token function">mutableListOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> map<span class="token operator">:</span> MutableMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> E<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">mutableMapOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> MutableList<span class="token operator">&lt;</span>E<span class="token operator">?</span><span class="token operator">></span> <span class="token keyword">by</span> list<span class="token punctuation">,</span> MutableMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> E<span class="token operator">></span> <span class="token keyword">by</span> map <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 两个接口中都有，编译器不知道执行哪个，所以这些方法必须得重写</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        map<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token punctuation">{</span>        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> map<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">val</span> size<span class="token operator">:</span> Int <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> list<span class="token punctuation">.</span>size <span class="token operator">+</span> map<span class="token punctuation">.</span>size    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token keyword">set</span><span class="token punctuation">(</span>index<span class="token operator">:</span> Int<span class="token punctuation">,</span> element<span class="token operator">:</span> E<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> E<span class="token operator">?</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;=</span> list<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">repeat</span><span class="token punctuation">(</span>index <span class="token operator">-</span> list<span class="token punctuation">.</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> element<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"list:<span class="token interpolation variable">$list</span>,map:<span class="token interpolation variable">$map</span>"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="3-属性委托-Delegated-properties"><a href="#3-属性委托-Delegated-properties" class="headerlink" title="3. 属性委托(Delegated properties)"></a>3. 属性委托(Delegated properties)</h2><h3 id="3-1-属性-property"><a href="#3-1-属性-property" class="headerlink" title="3.1 属性(property)"></a>3.1 属性(property)</h3><p>我们先通过对比 Java field 和 kotlin property  来探究一下 kt 中 property 的内部实现方式</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//PersonKotlin 尽量写的像Java好对比 Kotlin 属性背后做的事情</span><span class="token keyword">class</span> <span class="token class-name">PersonKotlin</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>age<span class="token operator">:</span> Int<span class="token punctuation">,</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token punctuation">}</span>    <span class="token keyword">private</span> var age<span class="token operator">:</span> Int<span class="token operator">?</span> <span class="token operator">=</span> null        <span class="token comment" spellcheck="true">//Redundant getter 属性的 get/set 方法由编译器自动生成</span>        <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> field <span class="token comment" spellcheck="true">//这里的 field = backing field</span>        <span class="token punctuation">}</span>        <span class="token function">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            field <span class="token operator">=</span> value        <span class="token punctuation">}</span>    <span class="token keyword">private</span> var name<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> null        <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> field        <span class="token punctuation">}</span>        <span class="token function">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            field <span class="token operator">=</span> value        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//反编译 Java 后的代码</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">PersonKotlin</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//field</span>   <span class="token keyword">private</span> String name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//field</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> Integer <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span>Integer value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> value<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> value<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token function">PersonKotlin</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token annotation punctuation">@NotNull</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>      Intrinsics<span class="token punctuation">.</span><span class="token function">checkNotNullParameter</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="property-kotlin-field-java-getField-setField"><a href="#property-kotlin-field-java-getField-setField" class="headerlink" title="property(kotlin)=field(java)+getField()+setField()"></a>property(kotlin)=field(java)+getField()+setField()</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// age 属性背后包含了三个角色，backing field、get、set</span><span class="token keyword">private</span> var age<span class="token operator">:</span> Int<span class="token operator">?</span> <span class="token operator">=</span> null<span class="token comment" spellcheck="true">//等价于下面的代码</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">private</span> Integer age<span class="token punctuation">;</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">public</span> <span class="token keyword">final</span> Integer <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Integer var1<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> var1<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="属性引用-Property-Reference"><a href="#属性引用-Property-Reference" class="headerlink" title="属性引用(Property Reference)"></a>属性引用(Property Reference)</h4><p>通过属性引用我们可以更清楚的了解 property 背后的 get 和 set 以及代理信息等</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> ageRef<span class="token operator">:</span> KMutableProperty1<span class="token operator">&lt;</span>PersonKotlin<span class="token punctuation">,</span> Int<span class="token operator">?</span><span class="token operator">></span> <span class="token operator">=</span> PersonKotlin<span class="token operator">::</span>age<span class="token comment" spellcheck="true">//PersonKotlin::age 类名获取的属性引用不包含 receiver，操作时需要传递一个</span><span class="token keyword">val</span> personKotlin <span class="token operator">=</span> <span class="token function">PersonKotlin</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"Jay"</span><span class="token punctuation">)</span>ageRef<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>personKotlin<span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span>ageRef<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>personKotlin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//22</span><span class="token comment" spellcheck="true">//public actual fun set(receiver: T, value: V)</span><span class="token comment" spellcheck="true">//public actual fun get(receiver: T): V</span><span class="token comment" spellcheck="true">//receiver - 用于获取属性值的接收器。 例如，如果这是该类的成员属性，则它应该是类实例，如果这是顶级扩展属性，则它应该是扩展接收器</span><span class="token comment" spellcheck="true">//测试自定义属性委托后获取属性的委托信息</span><span class="token keyword">val</span> nameRef<span class="token operator">:</span> KProperty0<span class="token operator">&lt;</span>String<span class="token operator">?</span><span class="token operator">></span> <span class="token operator">=</span> personKotlin<span class="token operator">::</span>name<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"personKotlin: "</span> <span class="token operator">+</span> personKotlin<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"nameRef: "</span> <span class="token operator">+</span> nameRef<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"personKotlin.name: "</span> <span class="token operator">+</span> personKotlin<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//取： is KMutableProperty -> javaField?.isAccessible ?: true &amp;&amp; javaGetter?.isAccessible ?: true &amp;&amp;javaSetter?.isAccessible ?: true</span><span class="token comment" spellcheck="true">//存： is KMutableProperty -> { javaField?.isAccessible = value javaGetter?.isAccessible = value javaSetter?.isAccessible = value }</span><span class="token comment" spellcheck="true">//设置是否访问，只有设置为 true 才可以拿到 属性引用中的委托信息（如果被委托了）这个属性需要单独引入 kotlin-reflect 库</span>nameRef<span class="token punctuation">.</span>isAccessible <span class="token operator">=</span> <span class="token boolean">true</span><span class="token comment" spellcheck="true">//如果这是一个委托属性，则返回委托的值，如果此属性未委托，则返回null</span><span class="token keyword">val</span> nameDelegate <span class="token operator">=</span> nameRef<span class="token punctuation">.</span><span class="token function">getDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"nameDelegate： <span class="token interpolation variable">$nameDelegate</span>"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//返回委托信息</span><span class="token function">println</span><span class="token punctuation">(</span>nameRef<span class="token punctuation">.</span>getter<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//相当于调用 get 方法</span><span class="token comment" spellcheck="true">//personKotlin: 1751075886</span><span class="token comment" spellcheck="true">//nameRef: -954731934</span><span class="token comment" spellcheck="true">//thisRef:1751075886</span><span class="token comment" spellcheck="true">//property:-954731934</span><span class="token comment" spellcheck="true">//personKotlin.name: 88377</span><span class="token comment" spellcheck="true">//可以看到属性引用类和它的 receiver 在委托类和这里的 hashCode 相同</span><span class="token comment" spellcheck="true">//com.jay.lib_kotlin.delegate.MyDelegate@5a63f509</span><span class="token comment" spellcheck="true">//YYY</span><span class="token comment" spellcheck="true">//测试lazy 属性代理方式</span><span class="token keyword">val</span> sexRef<span class="token operator">:</span> KProperty0<span class="token operator">&lt;</span>String<span class="token operator">?</span><span class="token operator">></span> <span class="token operator">=</span> personKotlin<span class="token operator">::</span>sexpersonKotlin<span class="token punctuation">.</span>sexsexRef<span class="token punctuation">.</span>isAccessible <span class="token operator">=</span> <span class="token boolean">true</span><span class="token function">println</span><span class="token punctuation">(</span>sexRef<span class="token punctuation">.</span><span class="token function">getDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取的代理信息就是lazy代码块中的值：sex is male</span><span class="token comment" spellcheck="true">//测试 属性引用的类型</span><span class="token keyword">val</span> kMutableProperty0<span class="token operator">:</span> KMutableProperty0<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token operator">=</span> <span class="token operator">::</span>sex <span class="token comment" spellcheck="true">//sex 是顶级属性</span><span class="token keyword">val</span> s <span class="token operator">=</span> kMutableProperty0 <span class="token keyword">as</span> CallableReference<span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>owner<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//file class com.jay.lib_kotlin.property.PersonKotlinKt</span><span class="token comment" spellcheck="true">//属性引用的类型是 CallableReference</span></code></pre><p><strong>receiver</strong>：属性值的接收器。 例如，如果这是该类的成员属性，则它应该是类实例，如果这是顶级扩展属性，则它应该是扩展接收器</p><p><strong>CallableReference</strong>：是 Kotlin 编译器为可调用引用类生成的所有类的超类</p><h3 id="3-2-属性委托实现原理"><a href="#3-2-属性委托实现原理" class="headerlink" title="3.2 属性委托实现原理"></a>3.2 属性委托实现原理</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">open</span> <span class="token keyword">class</span> FooBy <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//只要在by关键字后面带有一个委托对象，这个对象不一定要实现特定的接口，只要包含了getValue/setValue方法、那它就能作为一个代理属性来使用。</span>    <span class="token keyword">val</span> y <span class="token keyword">by</span> <span class="token function">MyDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> w<span class="token operator">:</span> String <span class="token keyword">by</span> <span class="token function">MyDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">class</span> MyDelegate <span class="token punctuation">{</span>    <span class="token keyword">var</span> value<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string">"YYY"</span>    <span class="token comment" spellcheck="true">//todo 委托类里面必须提供 getValue 方法，或者扩展这个方法也可</span>    operator <span class="token keyword">fun</span> <span class="token function">getValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>        <span class="token keyword">return</span> value    <span class="token punctuation">}</span>    operator <span class="token keyword">fun</span> <span class="token function">setValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> s<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> s    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>反编译Java后的代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FooBy</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// $FF: synthetic field</span>   <span class="token keyword">static</span> <span class="token keyword">final</span> KProperty<span class="token punctuation">[</span><span class="token punctuation">]</span> $$delegatedProperties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KProperty</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">(</span>KProperty<span class="token punctuation">)</span>Reflection<span class="token punctuation">.</span><span class="token function">property1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PropertyReference1Impl</span><span class="token punctuation">(</span>FooBy<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"y"</span><span class="token punctuation">,</span> <span class="token string">"getY()Ljava/lang/String;"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>KProperty<span class="token punctuation">)</span>Reflection<span class="token punctuation">.</span><span class="token function">mutableProperty1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MutablePropertyReference1Impl</span><span class="token punctuation">(</span>FooBy<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> <span class="token string">"getW()Ljava/lang/String;"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token annotation punctuation">@NotNull</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> MyDelegate y$delegate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token annotation punctuation">@NotNull</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> MyDelegate w$delegate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token annotation punctuation">@NotNull</span>   <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y$delegate<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> $$delegatedProperties<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token annotation punctuation">@NotNull</span>   <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">getW</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>w$delegate<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> $$delegatedProperties<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setW</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> String var1<span class="token punctuation">)</span> <span class="token punctuation">{</span>      Intrinsics<span class="token punctuation">.</span><span class="token function">checkNotNullParameter</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> <span class="token string">"&lt;set-?>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>w$delegate<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> $$delegatedProperties<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当调用下面的代码时，就会调用到 FooBy.y 的 get 方法</p><pre><code>val foo = FooBy()println(foo.y)</code></pre><p>看一下反编译后的 getY 方法，</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@NotNull</span><span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y$delegate<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> $$delegatedProperties<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>看一下 <code>y$delegate</code> 是什么 ,其实就是我们的代理类并在 FooBy 类构建的时候已经初始化</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@NotNull</span><span class="token keyword">private</span> <span class="token keyword">final</span> MyDelegate y$delegate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>再看看MyDelegate中的的 getValue 方法, 就是我们在代理类中必须提供的方法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Java code</span><span class="token annotation punctuation">@NotNull</span><span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> Object thisRef<span class="token punctuation">,</span> <span class="token annotation punctuation">@NotNull</span> KProperty property<span class="token punctuation">)</span> <span class="token punctuation">{</span>   Intrinsics<span class="token punctuation">.</span><span class="token function">checkNotNullParameter</span><span class="token punctuation">(</span>thisRef<span class="token punctuation">,</span> <span class="token string">"thisRef"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   Intrinsics<span class="token punctuation">.</span><span class="token function">checkNotNullParameter</span><span class="token punctuation">(</span>property<span class="token punctuation">,</span> <span class="token string">"property"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>到这里我们就可以看清了整个委托流程了</p><ul><li>当类中有属性被委托时，Kotlin 会在当前类中添加委托类的实例并在实例化当前类时实例化委托类( y$delegate)，同时$$delegatedProperties 数组也是在类初始化时创建完成，里面方式所有属性的反射类信息</li><li>当要获取委托属性时，会调用到它的 get 方法，而 get 方法返回的是代理类的 getValue 方法</li><li>getValue 方法是我们自己实现的，最终代理属性就会通过 getValue  方法赋上值了</li><li>setValue 时还会把 属性 的backing field 传过去</li></ul><h3 id="3-3-PropertyReferenceImpl"><a href="#3-3-PropertyReferenceImpl" class="headerlink" title="3.3 PropertyReferenceImpl"></a>3.3 PropertyReferenceImpl</h3><p>委托流程搞清楚了，我们再来看看 getValue 方法中 <code>thisRef: Any</code>， <code>property: KProperty&lt;*&gt;</code> 这两个参数是怎么来的，干什么用的</p><p>thisRef 这个参数是业务类本身可以看到就是在调用 getValue 方法时传递的 this</p><p>property 是委托属性的描述类 <code>KProperty</code> ,它是从这个数组里取的 <code>$$delegatedProperties[0]</code>，这个数组也是构建业务类时由Kotlin自动生成的，存放的是描述类属性的 KProperty 类型</p><p><code>Reflection.property1</code>  是一个工厂函数，将传入的参数返回</p><p>PropertyReference1Impl 的父类也间接实现了 KProperty 接口，所以这里可以强转</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//$$delegatedProperties</span><span class="token keyword">static</span> <span class="token keyword">final</span> KProperty<span class="token punctuation">[</span><span class="token punctuation">]</span> $$delegatedProperties <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">KProperty</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">(</span>KProperty<span class="token punctuation">)</span>Reflection<span class="token punctuation">.</span><span class="token function">property1</span><span class="token punctuation">(</span>  <span class="token keyword">new</span> <span class="token class-name">PropertyReference1Impl</span><span class="token punctuation">(</span>FooBy<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"y"</span><span class="token punctuation">,</span> <span class="token string">"getY()Ljava/lang/String;"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>KProperty<span class="token punctuation">)</span>Reflection<span class="token punctuation">.</span><span class="token function">mutableProperty1</span><span class="token punctuation">(</span>  <span class="token keyword">new</span> <span class="token class-name">MutablePropertyReference1Impl</span><span class="token punctuation">(</span>FooBy<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> <span class="token string">"getW()Ljava/lang/String;"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>再看一下属性引用实现类 PropertyReference1Impl  的构造参数 </p><p>PropertyReference1Impl 类的构造器最终会调用到它的父类  CallableReference</p><p><strong>CallableReference</strong>：是 Kotlin 编译器为可调用引用类生成的所有类的超类。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@SinceKotlin</span><span class="token punctuation">(</span>version <span class="token operator">=</span> <span class="token string">"1.4"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">PropertyReference1Impl</span><span class="token punctuation">(</span>Class owner<span class="token punctuation">,</span> String name<span class="token punctuation">,</span> String signature<span class="token punctuation">,</span> int flags<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>NO_RECEIVER<span class="token punctuation">,</span> owner<span class="token punctuation">,</span> name<span class="token punctuation">,</span> signature<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//NO_RECEIVER 如果属性没有 receiver 构造时会缺省添加一个 NO_RECEIVER</span><span class="token annotation builtin">@SinceKotlin</span><span class="token punctuation">(</span>version <span class="token operator">=</span> <span class="token string">"1.1"</span><span class="token punctuation">)</span><span class="token keyword">public</span> static <span class="token keyword">final</span> Object NO_RECEIVER <span class="token operator">=</span> NoReceiver<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span><span class="token annotation builtin">@SinceKotlin</span><span class="token punctuation">(</span>version <span class="token operator">=</span> <span class="token string">"1.2"</span><span class="token punctuation">)</span><span class="token keyword">private</span> static <span class="token keyword">class</span> NoReceiver implements Serializable <span class="token punctuation">{</span>    <span class="token keyword">private</span> static <span class="token keyword">final</span> NoReceiver INSTANCE <span class="token operator">=</span> new <span class="token function">NoReceiver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Object <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> throws ObjectStreamException <span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//CallableReference</span><span class="token annotation builtin">@SinceKotlin</span><span class="token punctuation">(</span>version <span class="token operator">=</span> <span class="token string">"1.4"</span><span class="token punctuation">)</span><span class="token keyword">protected</span> <span class="token function">CallableReference</span><span class="token punctuation">(</span>Object receiver<span class="token punctuation">,</span> Class owner<span class="token punctuation">,</span> String name<span class="token punctuation">,</span> String signature<span class="token punctuation">,</span> boolean isTopLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>receiver <span class="token operator">=</span> receiver<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//可调用对象的属性值的接收器。 例如：类实例</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>owner <span class="token operator">=</span> owner<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//可调用对象所在的类或包</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//可调用对象的 Kotlin 名称，即在源代码中声明的名</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>signature <span class="token operator">=</span> signature<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//可调用对象的 JVM 签名。如果这是一个属性引用，则返回其 getter 的 JVM 签名，例如“getFoo(LjavalangString;)I”。</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>isTopLevel <span class="token operator">=</span> isTopLevel<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//是否高等类型(文件中还是类中)，0 false; 1 true</span><span class="token punctuation">}</span></code></pre><p>利用Java的实现方式简单总结以下Kotlin 属性委托的背后原理</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>  <span class="token keyword">static</span> <span class="token keyword">final</span> Field<span class="token punctuation">[</span><span class="token punctuation">]</span> delegatedProperties <span class="token operator">=</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> NameDelegate nameDelegate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NameDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nameDelegate<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> delegatedProperties<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">NameDelegate</span> <span class="token punctuation">{</span>  String <span class="token function">getValue</span><span class="token punctuation">(</span>Person thisRef<span class="token punctuation">,</span> Field property<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"Jay"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3-4-简化属性委托的内置接口们"><a href="#3-4-简化属性委托的内置接口们" class="headerlink" title="3.4 简化属性委托的内置接口们"></a>3.4 简化属性委托的内置接口们</h3><p>Kotlin 内置的属性委托功能是<strong>属性委托类</strong>，不能像普通的委托模式一样通过接口或集成的方式来约束交互的方法和类型，做不了两方约束，但是可以通过泛型+接口约束一下委托类，也能达到一部分约束的效果。</p><p>Kotlin 标准库中提供了三个接口来简化委托类的实现</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//val 属性</span><span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token keyword">interface</span> ReadOnlyProperty<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token punctuation">,</span> <span class="token keyword">out</span> V<span class="token operator">></span><span class="token comment" spellcheck="true">//var 属性</span><span class="token keyword">public</span> <span class="token keyword">interface</span> ReadWriteProperty<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token operator">:</span> ReadOnlyProperty<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token comment" spellcheck="true">//创建委托类的工厂接口</span><span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token keyword">interface</span> PropertyDelegateProvider<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token punctuation">,</span> <span class="token keyword">out</span> D<span class="token operator">></span><span class="token comment" spellcheck="true">//T：拥有委托属性的对象类型。 </span><span class="token comment" spellcheck="true">//V：属性值的类型。</span><span class="token comment" spellcheck="true">//D：委托类的类型</span></code></pre><p>看一下三个接口的接口和方法签名</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token keyword">interface</span> ReadOnlyProperty<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token punctuation">,</span> <span class="token keyword">out</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> operator <span class="token keyword">fun</span> <span class="token function">getValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> T<span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> V<span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> ReadWriteProperty<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token operator">:</span> ReadOnlyProperty<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">override</span> operator <span class="token keyword">fun</span> <span class="token function">getValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> T<span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> V    <span class="token keyword">public</span> operator <span class="token keyword">fun</span> <span class="token function">setValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> T<span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> value<span class="token operator">:</span> V<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token annotation builtin">@SinceKotlin</span><span class="token punctuation">(</span><span class="token string">"1.4"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token keyword">interface</span> PropertyDelegateProvider<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token punctuation">,</span> <span class="token keyword">out</span> D<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> operator <span class="token keyword">fun</span> <span class="token function">provideDelegate</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> T<span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> D<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//前两个直接用就行，看一个 PropertyDelegateProvider 的使用场景</span><span class="token keyword">private</span> <span class="token keyword">val</span> provider <span class="token operator">=</span> PropertyDelegateProvider<span class="token operator">&lt;</span>FooBy<span class="token punctuation">,</span> MyDelegate<span class="token operator">></span> <span class="token punctuation">{</span> thisRef<span class="token punctuation">,</span> property <span class="token operator">-></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>thisRef<span class="token punctuation">.</span>y <span class="token operator">==</span> <span class="token string">"YYY"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">MyDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">MyDelegate2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//MyDelegate2:MyDelegate</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>看一下他们几个综合使用的情况，同时也可以看到kt语音的强大，同样的功能,代码可以从十几行到三行再到一行。yyds!!!</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> provider1 <span class="token operator">=</span> <span class="token keyword">object</span> <span class="token operator">:</span> PropertyDelegateProvider<span class="token operator">&lt;</span>FooReadWrite<span class="token punctuation">,</span> ReadWriteProperty<span class="token operator">&lt;</span>FooReadWrite<span class="token punctuation">,</span> Int<span class="token operator">></span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">provideDelegate</span><span class="token punctuation">(</span>            thisRef<span class="token operator">:</span> FooReadWrite<span class="token punctuation">,</span>            property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span>        <span class="token punctuation">)</span><span class="token operator">:</span> ReadWriteProperty<span class="token operator">&lt;</span>FooReadWrite<span class="token punctuation">,</span> Int<span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">object</span> <span class="token operator">:</span> ReadWriteProperty<span class="token operator">&lt;</span>FooReadWrite<span class="token punctuation">,</span> Int<span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">var</span> result<span class="token operator">=</span><span class="token number">1024</span>                <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">getValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> FooReadWrite<span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token punctuation">{</span>                    <span class="token keyword">return</span> result                <span class="token punctuation">}</span>                <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">setValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> FooReadWrite<span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> value<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result<span class="token operator">=</span>value                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//lambda 简化版本</span><span class="token keyword">val</span> provider2<span class="token operator">:</span> PropertyDelegateProvider<span class="token operator">&lt;</span>FooReadWrite<span class="token punctuation">,</span> ReadOnlyProperty<span class="token operator">&lt;</span>FooReadWrite<span class="token punctuation">,</span> Int<span class="token operator">></span><span class="token operator">></span> <span class="token operator">=</span>    PropertyDelegateProvider<span class="token operator">&lt;</span>FooReadWrite<span class="token punctuation">,</span> ReadOnlyProperty<span class="token operator">&lt;</span>FooReadWrite<span class="token punctuation">,</span> Int<span class="token operator">></span><span class="token operator">></span> <span class="token punctuation">{</span> pThisRef<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> pProperty<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span> <span class="token operator">-></span>ReadOnlyProperty<span class="token operator">&lt;</span>Any<span class="token operator">?</span><span class="token punctuation">,</span> Int<span class="token operator">></span> <span class="token punctuation">{</span> thisRef<span class="token punctuation">,</span> property <span class="token operator">-></span> <span class="token number">1025</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//智能类型推导再简化版本</span><span class="token keyword">private</span> <span class="token keyword">val</span> provider3 <span class="token operator">=</span>PropertyDelegateProvider <span class="token punctuation">{</span> _<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> _ <span class="token operator">-></span> ReadOnlyProperty<span class="token operator">&lt;</span>Any<span class="token operator">?</span><span class="token punctuation">,</span> Int<span class="token operator">></span> <span class="token punctuation">{</span> _<span class="token punctuation">,</span> _ <span class="token operator">-></span> <span class="token number">1026</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">val</span> delegate1<span class="token operator">:</span> Int <span class="token keyword">by</span> provider1<span class="token keyword">val</span> delegate2<span class="token operator">:</span> Int <span class="token keyword">by</span> provider2<span class="token keyword">val</span> delegate3<span class="token operator">:</span> Int <span class="token keyword">by</span> provider3</code></pre><h2 id="4-属性委托在-Kotlin-Api-中的运用"><a href="#4-属性委托在-Kotlin-Api-中的运用" class="headerlink" title="4. 属性委托在 Kotlin Api 中的运用"></a>4. 属性委托在 Kotlin Api 中的运用</h2><p>Kotlin 标准库中提供了几种委托</p><ul><li>映射委托(Map delegation)</li><li>延迟属性（lazy properties）: 其值只在首次访问时计算；</li><li>可观察属性（observable properties）: 监听器会收到有关此属性变更的通知；</li><li>非空属性(Delegates.notNull)</li></ul><h3 id="4-1-映射委托-Map-delegation"><a href="#4-1-映射委托-Map-delegation" class="headerlink" title="4.1 映射委托(Map delegation)"></a>4.1 映射委托(Map delegation)</h3><p>看一个map 作为属性委托方的示例</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> User <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//委托 val</span>    <span class="token keyword">val</span> map<span class="token operator">:</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Any<span class="token operator">?</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token function">mapOf</span><span class="token punctuation">(</span><span class="token string">"name2"</span> <span class="token keyword">to</span> <span class="token string">"Jay"</span><span class="token punctuation">,</span> <span class="token string">"age"</span> <span class="token keyword">to</span> <span class="token number">18</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//可变 map 可以委托 val和var</span>    <span class="token keyword">val</span> map2<span class="token operator">:</span> MutableMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Any<span class="token operator">?</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token function">mutableMapOf</span><span class="token punctuation">(</span><span class="token string">"name2"</span> <span class="token keyword">to</span> <span class="token string">"Jay"</span><span class="token punctuation">,</span> <span class="token string">"age"</span> <span class="token keyword">to</span> <span class="token number">18</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> name<span class="token operator">:</span> String <span class="token keyword">by</span> map    <span class="token keyword">var</span> age<span class="token operator">:</span> Int <span class="token keyword">by</span> map2    <span class="token comment" spellcheck="true">//更新 age 的值，MutableMap 也会同步更新</span>    <span class="token keyword">fun</span> <span class="token function">setValues</span><span class="token punctuation">(</span>age<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>map 中的 key 必须包含属性名，否则会报下面这个错</p><pre class=" language-kotlin"><code class="language-kotlin">Exception <span class="token keyword">in</span> thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>NoSuchElementException<span class="token operator">:</span> Key name2 <span class="token keyword">is</span> missing <span class="token keyword">in</span> the map<span class="token punctuation">.</span></code></pre><p>所以在使用这个特性时除非我们完全确定支持映射的结构，否则应该避免基于映射的属性委托，要不然委托的类可能会失败并抛出异常</p><p>还有一种情况当value 为 null 时，只有第四种情况会发生：NullPointerException ，这个问题想了解的可以官方的 <a href="https://youtrack.jetbrains.com/issue/KT-27672" target="_blank" rel="noopener">bug report</a></p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> map<span class="token operator">:</span> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Any<span class="token operator">?</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token function">hashMapOf</span><span class="token punctuation">(</span><span class="token string">"name"</span> <span class="token keyword">to</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"age"</span> <span class="token keyword">to</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token keyword">val</span> name<span class="token operator">:</span> String <span class="token keyword">by</span> map<span class="token keyword">val</span> name<span class="token operator">:</span> String？ <span class="token keyword">by</span> map<span class="token keyword">var</span> age<span class="token operator">:</span> Int<span class="token operator">?</span> <span class="token keyword">by</span> map<span class="token keyword">var</span> age<span class="token operator">:</span> Int <span class="token keyword">by</span> map</code></pre><p>再来窥探一下 Map delegation 的委托原理</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// $FF: synthetic field</span><span class="token keyword">static</span> <span class="token keyword">final</span> KProperty<span class="token punctuation">[</span><span class="token punctuation">]</span> $$delegatedProperties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KProperty</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">(</span>KProperty<span class="token punctuation">)</span>Reflection<span class="token punctuation">.</span><span class="token function">property1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PropertyReference1Impl</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"getName()Ljava/lang/String;"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>KProperty<span class="token punctuation">)</span>Reflection<span class="token punctuation">.</span><span class="token function">mutableProperty1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MutablePropertyReference1Impl</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token string">"getAge()Ljava/lang/Integer;"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">private</span> <span class="token keyword">final</span> Map age$delegate<span class="token punctuation">;</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">public</span> <span class="token keyword">final</span> Integer <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   Map var1 <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>age$delegate<span class="token punctuation">;</span>   KProperty var3 <span class="token operator">=</span> $$delegatedProperties<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">boolean</span> var4 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span>MapsKt<span class="token punctuation">.</span><span class="token function">getOrImplicitDefaultNullable</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var3<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Integer var1<span class="token punctuation">)</span> <span class="token punctuation">{</span>   Map var2 <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>age$delegate<span class="token punctuation">;</span>   KProperty var4 <span class="token operator">=</span> $$delegatedProperties<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">boolean</span> var5 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   var2<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>var4<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到，Kotlin 编译器 也生成了KProperty[] 类型的 $$delegatedProperties 和 Map 类型 age$delegate，并在构造时实例化age$delegate </p><p>Map相关的委托必要方法在<strong><a href="https://github.com/JetBrains/kotlin/blob/34e57a45f2/libraries/stdlib/src/kotlin/collections/MapAccessors.kt" target="_blank" rel="noopener">MapAccessors</a></strong> 这个类里面</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//Map</span><span class="token label symbol">@kotlin</span><span class="token punctuation">.</span>internal<span class="token punctuation">.</span>InlineOnly<span class="token keyword">public</span> <span class="token keyword">inline</span> operator <span class="token keyword">fun</span> <span class="token operator">&lt;</span>V<span class="token punctuation">,</span> V1 <span class="token operator">:</span> V<span class="token operator">></span> Map<span class="token operator">&lt;</span><span class="token keyword">in</span> String<span class="token punctuation">,</span> <span class="token annotation builtin">@Exact</span> V<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> V1 <span class="token operator">=</span><span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"UNCHECKED_CAST"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">getOrImplicitDefault</span><span class="token punctuation">(</span>property<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token keyword">as</span> V1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//MutableMap</span><span class="token label symbol">@kotlin</span><span class="token punctuation">.</span>jvm<span class="token punctuation">.</span><span class="token function">JvmName</span><span class="token punctuation">(</span><span class="token string">"getVar"</span><span class="token punctuation">)</span><span class="token label symbol">@kotlin</span><span class="token punctuation">.</span>internal<span class="token punctuation">.</span>InlineOnly<span class="token keyword">public</span> <span class="token keyword">inline</span> operator <span class="token keyword">fun</span> <span class="token operator">&lt;</span>V<span class="token punctuation">,</span> V1 <span class="token operator">:</span> V<span class="token operator">></span> MutableMap<span class="token operator">&lt;</span><span class="token keyword">in</span> String<span class="token punctuation">,</span> <span class="token keyword">out</span> <span class="token annotation builtin">@Exact</span> V<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> V1 <span class="token operator">=</span> <span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"UNCHECKED_CAST"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">getOrImplicitDefault</span><span class="token punctuation">(</span>property<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token keyword">as</span> V1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//MutableMap</span><span class="token label symbol">@kotlin</span><span class="token punctuation">.</span>internal<span class="token punctuation">.</span>InlineOnly<span class="token keyword">public</span> <span class="token keyword">inline</span> operator <span class="token keyword">fun</span> <span class="token operator">&lt;</span>V<span class="token operator">></span> MutableMap<span class="token operator">&lt;</span><span class="token keyword">in</span> String<span class="token punctuation">,</span> <span class="token keyword">in</span> V<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> value<span class="token operator">:</span> V<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>property<span class="token punctuation">.</span>name<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在访问 age 的 get 时会调用委托 Map 的    <code>(Integer)MapsKt.getOrImplicitDefaultNullable(var1, var3.getName());</code></p><p>在访问 age 的 set 时直接调用委托 Map 的put方法</p><p>下面是 <strong>getOrImplicitDefaultNullable</strong> 函数</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//JvmName 这个注解是指定从此元素生成的 Java 类或方法的名称。</span><span class="token comment" spellcheck="true">//扩展方法编译后会将方法的 reciver 作为第一个参数传入</span><span class="token label symbol">@kotlin</span><span class="token punctuation">.</span>jvm<span class="token punctuation">.</span><span class="token function">JvmName</span><span class="token punctuation">(</span><span class="token string">"getOrImplicitDefaultNullable"</span><span class="token punctuation">)</span><span class="token annotation builtin">@PublishedApi</span><span class="token keyword">internal</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">getOrImplicitDefault</span><span class="token punctuation">(</span>key<span class="token operator">:</span> K<span class="token punctuation">)</span><span class="token operator">:</span> V <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">is</span> MapWithDefault<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getOrImplicitDefault</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">getOrElseNullable</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token function">NoSuchElementException</span><span class="token punctuation">(</span><span class="token string">"Key <span class="token interpolation variable">$key</span> is missing in the map."</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>关于 map 的 put 和 get 操作是如何与委托的 getValue 和 setValue 如何联系在一起的 以及map 的 <code>getValue(thisRef: Any?, property: KProperty&lt;*&gt;)</code>方法为什么用 inline 修饰了，这里涉及到Kotlin 1.4 对委托属性的一个优化，稍后再解析 lazy 原理时会详细解释。</p><p>Map delegation 的一个实践，将推送消息封装并通知APP</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onNotificationReceivedInApp</span><span class="token punctuation">(</span>    context<span class="token operator">:</span> Context<span class="token punctuation">,</span>    title<span class="token operator">:</span> String<span class="token punctuation">,</span>    summary<span class="token operator">:</span> String<span class="token punctuation">,</span>    extraMap<span class="token operator">:</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">val</span> <span class="token keyword">data</span> <span class="token operator">=</span> extraMap<span class="token punctuation">.</span><span class="token function">withDefault</span> <span class="token punctuation">{</span> <span class="token string">""</span> <span class="token punctuation">}</span>    <span class="token keyword">val</span> params <span class="token operator">=</span> <span class="token function">NotificationParams</span><span class="token punctuation">(</span><span class="token keyword">data</span><span class="token punctuation">)</span>    EventBus<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token function">NotificationParams</span><span class="token punctuation">(</span><span class="token keyword">val</span> map<span class="token operator">:</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">val</span> title<span class="token operator">:</span> String <span class="token keyword">by</span> map    <span class="token keyword">val</span> content<span class="token operator">:</span> String <span class="token keyword">by</span> map<span class="token punctuation">}</span></code></pre><h3 id="4-2-延迟属性-lazy-properties"><a href="#4-2-延迟属性-lazy-properties" class="headerlink" title="4.2 延迟属性(lazy properties)"></a>4.2 延迟属性(lazy properties)</h3><p>看一下lazy的简单使用</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> x<span class="token operator">:</span> String <span class="token keyword">by</span> <span class="token function">lazy</span><span class="token punctuation">(</span>LazyThreadSafetyMode<span class="token punctuation">.</span>SYNCHRONIZED<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"xxx——lazy"</span><span class="token punctuation">)</span>    <span class="token string">"xxx——<span class="token interpolation"><span class="token delimiter variable">${</span>index<span class="token operator">++</span><span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">}</span><span class="token keyword">val</span> y<span class="token operator">:</span> String <span class="token keyword">by</span> <span class="token function">lazy</span><span class="token punctuation">(</span>LazyThreadSafetyMode<span class="token punctuation">.</span>PUBLICATION<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"yyy——lazy"</span><span class="token punctuation">)</span>    <span class="token string">"yyy——<span class="token interpolation"><span class="token delimiter variable">${</span>index<span class="token operator">++</span><span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">}</span><span class="token keyword">val</span> z<span class="token operator">:</span> String <span class="token keyword">by</span> <span class="token function">lazy</span><span class="token punctuation">(</span>LazyThreadSafetyMode<span class="token punctuation">.</span>NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"zzz——lazy"</span><span class="token punctuation">)</span>    <span class="token string">"zzz——<span class="token interpolation"><span class="token delimiter variable">${</span>index<span class="token operator">++</span><span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> fooLazy <span class="token operator">=</span> <span class="token function">FooLazy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">val</span> thread <span class="token operator">=</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"="</span> <span class="token operator">+</span> fooLazy<span class="token punctuation">.</span>x<span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===="</span> <span class="token operator">+</span> fooLazy<span class="token punctuation">.</span>y<span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"========="</span> <span class="token operator">+</span> fooLazy<span class="token punctuation">.</span>z<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//xxx——lazy 和 yyy——lazy 都只执行一次，x=0, y=1</span><span class="token comment" spellcheck="true">//zzz——lazy 和 z 的值不能确定会执行几次</span></code></pre><p>LazyThreadSafetyMode 有三种模式作用是指定 [Lazy] 实例如何在多个线程之间同步初始化。</p><ul><li>SYNCHRONIZED: 锁用于确保只有一个线程可以初始化[Lazy]实例。</li><li>PUBLICATION: 并发访问未初始化的[Lazy]实例值时，可以多次调用Initializer函数，但是只有第一个返回的值将用作[Lazy]实例的值。</li><li>NONE: 不使用锁来同步对 [Lazy] 实例值的访问；如果从多个线程访问该实例，可能会发生线程安全问题。除非保证 [Lazy] 实例永远不会从多个线程初始化，否则不应使用此模式。</li></ul><h4 id="lazy-原理解析"><a href="#lazy-原理解析" class="headerlink" title="lazy 原理解析"></a>lazy 原理解析</h4><p>受托对象是Lazy</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@NotNull</span><span class="token keyword">private</span> <span class="token keyword">final</span> Lazy x$delegate<span class="token punctuation">;</span></code></pre><p>受托对象在委托者构造方法中实例化</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token function">FooLazy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>x$delegate <span class="token operator">=</span> LazyKt<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span>LazyThreadSafetyMode<span class="token punctuation">.</span>SYNCHRONIZED<span class="token punctuation">,</span> <span class="token punctuation">(</span>Function0<span class="token punctuation">)</span><span class="token punctuation">(</span>new <span class="token function">Function0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// $FF: synthetic method</span>      <span class="token comment" spellcheck="true">// $FF: bridge method</span>      <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token annotation builtin">@NotNull</span>      <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         String var1 <span class="token operator">=</span> <span class="token string">"xxx——lazy"</span><span class="token punctuation">;</span>         boolean var2 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span>         StringBuilder var10000 <span class="token operator">=</span> <span class="token punctuation">(</span>new <span class="token function">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"xxx——"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         FooLazy var10001 <span class="token operator">=</span> FooLazy<span class="token punctuation">.</span>this<span class="token punctuation">;</span>         int var3<span class="token punctuation">;</span>         var10001<span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>var3 <span class="token operator">=</span> var10001<span class="token punctuation">.</span>index<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> var10000<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>var3<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到 <code>x$delegate</code>  是通过 LazyKt.lazy() 方法实例化的，两个参数分别是线程安全模式类型和一个接口回调</p><p>当调用x 的 get 方法时 反回了受托者的 getValue 方法 并没有调用 lazy 的扩展方法：LazyKt.getValue(thisRef: Any?, property: KProperty&lt;*&gt;) </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   Lazy var1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x$delegate<span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>var1<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>再看一下 lazy 是如何定义委托方法 getValue 的</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token label symbol">@kotlin</span><span class="token punctuation">.</span>internal<span class="token punctuation">.</span>InlineOnly<span class="token keyword">public</span> <span class="token keyword">inline</span> operator <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Lazy<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token operator">=</span> value</code></pre><p>这里有没有注意到 lazy 利用属性委托的方式是不同的</p><ul><li>没有自动生成属性数组  <code>KProperty[] $$delegatedProperties</code> </li><li>getX 时最终返回时调用的也不是 <code>getValue(thisRef: Any?, property: KProperty&lt;*&gt;)</code></li><li>lazy 的  <code>getValue(thisRef: Any?, property: KProperty&lt;*&gt;)</code> 方法是用 <strong>inline</strong> 修饰的 并且添加了<code>@kotlin.internal.InlineOnly</code> 注解，map 委托 也是这样的操作</li></ul><p>其实这里是Kotlin 1.4 做的优化，当某些委托属性不会使用 KProperty。对于他们来说，在 <code>$$delegatedProperties</code> 中生成一个KProperty对象是多余的。Kotlin 1.4 版本将优化此类情况。如果委托的属性运算符是内联的，并且没有使用 KProperty 参数，则不会生成相应的反射对象。如果委托属性中有没有采用 inline 修饰的 ， 最终生成的<code>$$delegatedProperties</code>  数组中也之会单独生成它自己的反射对象，详细说明可以看官方的这篇博客</p><p><a href="https://blog.jetbrains.com/kotlin/2019/12/what-to-expect-in-kotlin-1-4-and-beyond/" target="_blank" rel="noopener">What to Expect in Kotlin 1.4 and Beyond | Optimized delegated properties</a></p><blockquote><p>内联实际上是如何工作的？</p><p>粗略地说，内联采用被内联的函数的字节码，并将其插入到调用处，因此内联函数声明不必在调用处可见。</p><p><code>@kotlin.internal.InlineOnly</code> 注解的作用？</p><p><code>InlineOnly</code> 意味着与此 Kotlin 函数对应的 Java 方法被标记为私有，因此 Java 代码无法访问它（这是调用内联函数而不实际内联它的唯一方法）。这个注释还没有得到很好的验证，官方目前只在内部使用，很有可能稍后将其公之于众。</p></blockquote><p>所以 lazy 和 map 的属性委托在 Kotlin 4.1 都是做了优化的，lazy 属性在调用 getter 时实际上是调用的的是 Lazy<t> 中 value 的 getter，map 属性在调用 getter/setter 时 实际上最终调用的也是 map 的 get/put 方法。</t></p><p>看一下 lazy 函数签名</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> actual <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">lazy</span><span class="token punctuation">(</span>mode<span class="token operator">:</span> LazyThreadSafetyMode<span class="token punctuation">,</span> initializer<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token operator">:</span> Lazy<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">=</span>    <span class="token keyword">when</span> <span class="token punctuation">(</span>mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LazyThreadSafetyMode<span class="token punctuation">.</span>SYNCHRONIZED <span class="token operator">-></span> <span class="token function">SynchronizedLazyImpl</span><span class="token punctuation">(</span>initializer<span class="token punctuation">)</span>        LazyThreadSafetyMode<span class="token punctuation">.</span>PUBLICATION <span class="token operator">-></span> <span class="token function">SafePublicationLazyImpl</span><span class="token punctuation">(</span>initializer<span class="token punctuation">)</span>        LazyThreadSafetyMode<span class="token punctuation">.</span>NONE <span class="token operator">-></span> <span class="token function">UnsafeLazyImpl</span><span class="token punctuation">(</span>initializer<span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><h4 id="SynchronizedLazyImpl"><a href="#SynchronizedLazyImpl" class="headerlink" title="SynchronizedLazyImpl"></a>SynchronizedLazyImpl</h4><p>SynchronizedLazyImpl 采用 DCL 方式确保线程安全</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">class</span> SynchronizedLazyImpl<span class="token operator">&lt;</span><span class="token keyword">out</span> T<span class="token operator">></span><span class="token punctuation">(</span>initializer<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">,</span> lock<span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">:</span> Lazy<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> initializer<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">=</span> initializer    <span class="token annotation builtin">@Volatile</span> <span class="token comment" spellcheck="true">// 用内存可见性来检查是否在其他线程初始化过，同时也会禁止指令重排序防止_value拿到不完整的实例</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> _value<span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token operator">=</span> UNINITIALIZED_VALUE    <span class="token comment" spellcheck="true">//实例使用自身进行同步</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> lock <span class="token operator">=</span> lock <span class="token operator">?:</span> <span class="token keyword">this</span>    <span class="token comment" spellcheck="true">//Lazy 接口的 value 属性用于获取当前 Lazy 实例的延迟初始化值。一旦初始化后，它不得在此 Lazy 实例的剩余生命周期内更改。</span>    <span class="token keyword">val</span> value<span class="token operator">:</span> T        <span class="token comment" spellcheck="true">// 重写 get 来保证懒加载，只在使用的时候才执行函数</span>        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//局部变量可以将性能提高25%以上</span>            <span class="token keyword">val</span> _v1 <span class="token operator">=</span> _value            <span class="token comment" spellcheck="true">//检查单例实例是否已初始化。如果它被初始化就返回实例。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>_v1 <span class="token operator">!==</span> UNINITIALIZED_VALUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"UNCHECKED_CAST"</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> _v1 <span class="token keyword">as</span> T            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//到这里还没有初始化，但我们不能确定，因为可能有多个其他线程可能同时初始化了它。</span>            <span class="token comment" spellcheck="true">//所以为了以防万一，这里需要添加一把互斥锁来保证只有一个线程去实例化实例对象。</span>            <span class="token keyword">return</span> <span class="token function">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//再次将实例分配给局部变量以检查它是否被其他线程初始化，而当前线程被阻止进入锁定区域。</span>                <span class="token keyword">val</span> _v2 <span class="token operator">=</span> _value                <span class="token comment" spellcheck="true">//如果它已经被其它线程初始化了，当前线程也能感知他的存在了，直接返回实例</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>_v2 <span class="token operator">!==</span> UNINITIALIZED_VALUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"UNCHECKED_CAST"</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span>_v2 <span class="token keyword">as</span> T<span class="token punctuation">)</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//到这里该实例仍未初始化，因此我们可以安全地（没有其他线程可以进入该区域）创建一个实例了。</span>                    <span class="token keyword">val</span> typedValue <span class="token operator">=</span> initializer<span class="token operator">!!</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//执行 Function 对象的 invoke 并将函数的返回值缓存起来</span>                    _value <span class="token operator">=</span> typedValue <span class="token comment" spellcheck="true">//_value赋值通知其它线程别进来了，拿走用吧</span>                    initializer <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment" spellcheck="true">//initializer在当前类实例已经没用了</span>                    typedValue <span class="token comment" spellcheck="true">// 返回最终的结果给 value</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>看不惯这种DCL也可以恢复成传统方式看一下</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> value<span class="token operator">:</span> T    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//局部变量将性能提高了 25% Joshua Bloch “Effective Java, Second Edition”，第 3 页。 283-284</span>        <span class="token keyword">var</span> _v1 <span class="token operator">=</span> _value        <span class="token keyword">if</span> <span class="token punctuation">(</span>_v1 <span class="token operator">==</span> UNINITIALIZED_VALUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 再次将实例分配给局部变量以检查它是否被其他线程初始化，而当前线程被阻止进入锁定区域。</span>                <span class="token comment" spellcheck="true">// 如果它被初始化，当前线程也能感知他的存在了。</span>                _v1 <span class="token operator">=</span> _value                <span class="token keyword">if</span> <span class="token punctuation">(</span>_v1 <span class="token operator">==</span> UNINITIALIZED_VALUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 该实例仍未初始化，因此我们可以安全地（没有其他线程可以进入该区域）创建一个实例并将其赋值给我们的单例引用。</span>                    _v1 <span class="token operator">=</span> initializer<span class="token operator">!!</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    initializer <span class="token operator">=</span> <span class="token keyword">null</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"UNCHECKED_CAST"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> _v1 <span class="token keyword">as</span> T    <span class="token punctuation">}</span></code></pre><h4 id="SafePublicationLazyImpl"><a href="#SafePublicationLazyImpl" class="headerlink" title="SafePublicationLazyImpl"></a>SafePublicationLazyImpl</h4><p><strong>AtomicReferenceFieldUpdater</strong> ：原子更新器是基于反射的工具类，用来对某个类中，被volatile修饰的字段进行原子更新。</p><p>通过调用AtomicReferenceFieldUpdater的静态方法<code>newUpdater</code>就能创建它的实例，该方法要接收三个参数：包含该字段所在的类、将被更新的对象的类型、将被更新的字段的名称</p><p><code>compareAndSet</code> 如果期望值和字段当前值相等，说明目前是最新的值可以进行更新返回 true 同时原子地将字段设置为给定的更新值。</p><p><code>getAndSet</code>原子地将此更新程序管理的给定对象的字段设置为给定值并返回旧值。</p><p>原子更新器的使用存在比较苛刻的条件如下</p><ul><li>操作的字段不能是static类型。</li><li>操作的字段不能是final类型的，因为final根本没法修改。</li><li>字段必须是volatile修饰的，也就是数据本身是读一致的。</li><li>属性必须对当前的Updater所在的区域是可见的，如果不是当前类内部进行原子更新器操作不能使用private，protected子类操作父类时修饰符必须是protect权限及以上，如果在同一个package下则必须是default权限及以上，也就是说无论何时都应该保证操作类与被操作类间的可见性。</li></ul><blockquote><p>CAS，Compare and Swap即比较并交换，设计并发算法时常用到的一种技术，java.util.concurrent包全完建立在CAS之上，没有CAS也就没有此包，可见CAS的重要性。当前的处理器基本都支持CAS，只不过不同的厂家的实现不一样罢了。<strong>CAS有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false</strong>。</p><p>Unsafe，JDK中的一个类，它提供了硬件级别的<strong>原子操作</strong>。</p></blockquote><p>compareAndSet 方法调用流程</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe U <span class="token operator">=</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span>T obj<span class="token punctuation">,</span> V expect<span class="token punctuation">,</span> V update<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">accessCheck</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">valueCheck</span><span class="token punctuation">(</span>update<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> U<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span>Object var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> Object var4<span class="token punctuation">,</span> Object var5<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>看一个例子了解 <code>AtomicReferenceFieldUpdater</code> 的使用方式</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicReferenceFieldUpdaterTest</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// T:持有可更新字段的对象的类型</span>    <span class="token comment" spellcheck="true">// V:字段的类型</span>    AtomicReferenceFieldUpdater<span class="token operator">&lt;</span>Dog<span class="token punctuation">,</span> String<span class="token operator">></span> updater <span class="token operator">=</span>        <span class="token comment" spellcheck="true">// 包含该字段所在的类、将被更新的对象的类、将被更新的字段的名称</span>        AtomicReferenceFieldUpdater<span class="token punctuation">.</span><span class="token function">newUpdater</span><span class="token punctuation">(</span>Dog<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Dog dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果期望值和字段当前值相等，说明目前是最新的值可以进行更新，则原子地将字段设置为给定的更新值。</span>    <span class="token comment" spellcheck="true">// 参数：</span>    <span class="token comment" spellcheck="true">// obj: 字段所在对象</span>    <span class="token comment" spellcheck="true">// expect - 期望值</span>    <span class="token comment" spellcheck="true">// update - 新值</span>    <span class="token comment" spellcheck="true">// 返回：如果成功则为true</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// dog1 默认值</span>    <span class="token keyword">boolean</span> result <span class="token operator">=</span> updater<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>dog<span class="token punctuation">,</span> <span class="token string">"dog1"</span><span class="token punctuation">,</span> <span class="token string">"dog2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true 修改成功</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// dog2 修改后的的值</span>    <span class="token keyword">boolean</span> result2 <span class="token operator">=</span> updater<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>dog<span class="token punctuation">,</span> <span class="token string">"dog1"</span><span class="token punctuation">,</span> <span class="token string">"dog3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false 修改失败</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// dog2 还是原来的值</span>    <span class="token comment" spellcheck="true">// 原子地将此更新程序管理的给定对象的字段设置为给定值并返回旧值。</span>    <span class="token comment" spellcheck="true">// 参数：</span>    <span class="token comment" spellcheck="true">// obj – 更新字段的对象</span>    <span class="token comment" spellcheck="true">// newValue – 新值</span>    <span class="token comment" spellcheck="true">// 返回：之前的的值</span>    String result3 <span class="token operator">=</span> updater<span class="token punctuation">.</span><span class="token function">getAndSet</span><span class="token punctuation">(</span>dog<span class="token punctuation">,</span> <span class="token string">"dog4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// dog2  原来的值</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// dog4 修改后的值</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span>  <span class="token keyword">volatile</span> String name <span class="token operator">=</span> <span class="token string">"dog1"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>SafePublicationLazyImpl 使用 AtomicReferenceFieldUpdater 来保证 _value 属性的原子操作。支持同时多个线程调用，并且可以在全部或部分线程上同时进行初始化。如果某个值已由另一个线程初始化，则将返回该值而不执行初始化。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">class</span> SafePublicationLazyImpl<span class="token operator">&lt;</span><span class="token keyword">out</span> T<span class="token operator">></span><span class="token punctuation">(</span>initializer<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span> <span class="token operator">:</span> Lazy<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span>    <span class="token annotation builtin">@Volatile</span> <span class="token keyword">private</span> <span class="token keyword">var</span> initializer<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">=</span> initializer    <span class="token annotation builtin">@Volatile</span> <span class="token keyword">private</span> <span class="token keyword">var</span> _value<span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token operator">=</span> UNINITIALIZED_VALUE    <span class="token keyword">private</span> <span class="token keyword">val</span> <span class="token keyword">final</span><span class="token operator">:</span> Any <span class="token operator">=</span> UNINITIALIZED_VALUE    <span class="token keyword">override</span> <span class="token keyword">val</span> value<span class="token operator">:</span> T        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">val</span> value <span class="token operator">=</span> _value            <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!==</span> UNINITIALIZED_VALUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"UNCHECKED_CAST"</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> value <span class="token keyword">as</span> T            <span class="token punctuation">}</span>            <span class="token keyword">val</span> initializerValue <span class="token operator">=</span> initializer            <span class="token comment" spellcheck="true">//如果在这里看到初始值已经为 null，则表示该值已被另一个线程设置过了，直接返回 _value ，否则就初始化</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>initializerValue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">val</span> newValue <span class="token operator">=</span> <span class="token function">initializerValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//执行 Function 对象的 invoke 并将函数返回值原子化赋值给 _value</span>                <span class="token comment" spellcheck="true">//如果_value的值是UNINITIALIZED_VALUE说明还没有线程初始化它，此时可以将newValue设置给_value</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>valueUpdater<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> UNINITIALIZED_VALUE<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    initializer <span class="token operator">=</span> <span class="token keyword">null</span>                    <span class="token keyword">return</span> newValue <span class="token comment" spellcheck="true">//只有唯一的线程会从这里返回，其它都走下面的返回了</span>                <span class="token punctuation">}</span>              <span class="token comment" spellcheck="true">//如果_value的值不是UNINITIALIZED_VALUE，说明其它线程已经初始化完了，当前线程直接返回_value就行了</span>            <span class="token punctuation">}</span>            <span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"UNCHECKED_CAST"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> _value <span class="token keyword">as</span> T        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//如果一个序列化类中含有Object writeReplace()方法，那么实际序列化的对象将是作为writeReplace方法返回值的对象，</span>    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">writeReplace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Any <span class="token operator">=</span> <span class="token function">InitializedLazyImpl</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//初始化一个原子更新器：保证原子操作的字段是 _value</span>        <span class="token keyword">private</span> <span class="token keyword">val</span> valueUpdater <span class="token operator">=</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicReferenceFieldUpdater<span class="token punctuation">.</span><span class="token function">newUpdater</span><span class="token punctuation">(</span>            SafePublicationLazyImpl<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">,</span>            Any<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">,</span>            <span class="token string">"_value"</span>        <span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="UnsafeLazyImpl"><a href="#UnsafeLazyImpl" class="headerlink" title="UnsafeLazyImpl"></a>UnsafeLazyImpl</h4><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">internal</span> <span class="token keyword">class</span> UnsafeLazyImpl<span class="token operator">&lt;</span><span class="token keyword">out</span> T<span class="token operator">></span><span class="token punctuation">(</span>initializer<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span> <span class="token operator">:</span> Lazy<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> initializer<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">=</span> initializer    <span class="token keyword">private</span> <span class="token keyword">var</span> _value<span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token operator">=</span> UNINITIALIZED_VALUE    <span class="token keyword">override</span> <span class="token keyword">val</span> value<span class="token operator">:</span> T        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//普通的懒加载，只初始化一次，但是在多线程环境下不能保证只执行一次</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>_value <span class="token operator">===</span> UNINITIALIZED_VALUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                _value <span class="token operator">=</span> initializer<span class="token operator">!!</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//多线程并发情况下可能出现空指针异常</span>                initializer <span class="token operator">=</span> <span class="token keyword">null</span>            <span class="token punctuation">}</span>            <span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"UNCHECKED_CAST"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> _value <span class="token keyword">as</span> T        <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//如果一个序列化类中含有Object writeReplace()方法，那么实际序列化的对象将是作为writeReplace方法返回值的对象，</span>    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">writeReplace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Any <span class="token operator">=</span> <span class="token function">InitializedLazyImpl</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="4-3-NotNullVar"><a href="#4-3-NotNullVar" class="headerlink" title="4.3 NotNullVar"></a>4.3 NotNullVar</h3><p>notNull 可以返回一个经过非空校验的属性值但是该属性值并没有初始化需要人为稍后setValue<br>在分配初始值之前尝试读取属性会导致异常，这也是返回非空属性的原理所在</p><blockquote><p>非空属性应用场景分析<br>通常，声明为非空类型的属性必须在构造函数中初始化。然而，这通常并不方便。 例如，可以通过依赖注入或在单元测试的 setup 方法中初始化属性。在这种情况下，您不能在构造函数中提供非 null 初始值设定项，但您仍然希望在引用类体内的属性时避免空检查。</p><p>notNull VS lateinit<br>lateinit 不支持原始类型、只能用在可变属性var<br>notNull 会为每个属性创建委托类 NotNullVar</p></blockquote><p>notNull  的使用与原理</p><pre class=" language-kotlin"><code class="language-kotlin">    <span class="token keyword">var</span> name2<span class="token operator">:</span> String <span class="token keyword">by</span> Delegates<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> age2<span class="token operator">:</span> Int <span class="token keyword">by</span> Delegates<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// notNull 会为每个属性创建委托类 NotNullVar</span><span class="token comment" spellcheck="true">//    lateinit var age3: Int //lateinit 不支持原始类型</span>    <span class="token keyword">lateinit</span> <span class="token keyword">var</span> name3<span class="token operator">:</span> String <span class="token comment" spellcheck="true">//lateinit 只能用在 var</span><span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T <span class="token operator">:</span> Any<span class="token operator">></span> <span class="token function">notNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> ReadWriteProperty<span class="token operator">&lt;</span>Any<span class="token operator">?</span><span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">NotNullVar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">class</span> NotNullVar<span class="token operator">&lt;</span>T <span class="token operator">:</span> Any<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> ReadWriteProperty<span class="token operator">&lt;</span>Any<span class="token operator">?</span><span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> value<span class="token operator">:</span> T<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">getValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token punctuation">{</span>        <span class="token keyword">return</span> value <span class="token operator">?:</span> <span class="token keyword">throw</span> <span class="token function">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Property <span class="token interpolation"><span class="token delimiter variable">${</span>property<span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span> should be initialized before get."</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">setValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> value<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4-4-ObservableProperty"><a href="#4-4-ObservableProperty" class="headerlink" title="4.4 ObservableProperty"></a>4.4 ObservableProperty</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> ObservableProperty<span class="token operator">&lt;</span>V<span class="token operator">></span><span class="token punctuation">(</span>initialValue<span class="token operator">:</span> V<span class="token punctuation">)</span> <span class="token operator">:</span> ReadWriteProperty<span class="token operator">&lt;</span>Any<span class="token operator">?</span><span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> value <span class="token operator">=</span> initialValue    <span class="token keyword">protected</span> <span class="token keyword">open</span> <span class="token keyword">fun</span> <span class="token function">beforeChange</span><span class="token punctuation">(</span>property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> oldValue<span class="token operator">:</span> V<span class="token punctuation">,</span> newValue<span class="token operator">:</span> V<span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">true</span>    <span class="token keyword">protected</span> <span class="token keyword">open</span> <span class="token keyword">fun</span> <span class="token function">afterChange</span><span class="token punctuation">(</span>property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> oldValue<span class="token operator">:</span> V<span class="token punctuation">,</span> newValue<span class="token operator">:</span> V<span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">getValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> V <span class="token punctuation">{</span>        <span class="token keyword">return</span> value    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">setValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> value<span class="token operator">:</span> V<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">val</span> oldValue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value    <span class="token comment" spellcheck="true">//beforeChange: 在尝试更改属性值之前调用的回调。 调用此回调时，该属性的值尚未更改。 如果回调返回true ，则属性的值被设置为新值，如果回调返回false ，则丢弃新值，属性保持其旧值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">beforeChange</span><span class="token punctuation">(</span>property<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value    <span class="token comment" spellcheck="true">//afterChange: 进行属性更改后调用的回调。 调用此回调时，该属性的值已更改。</span>        <span class="token function">afterChange</span><span class="token punctuation">(</span>property<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> value<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="observable-变量值更新后的监听"><a href="#observable-变量值更新后的监听" class="headerlink" title="observable 变量值更新后的监听"></a>observable 变量值更新后的监听</h4><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">observable</span><span class="token punctuation">(</span>initialValue<span class="token operator">:</span> T<span class="token punctuation">,</span> <span class="token keyword">crossinline</span> onChange<span class="token operator">:</span> <span class="token punctuation">(</span>property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> oldValue<span class="token operator">:</span> T<span class="token punctuation">,</span> newValue<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span><span class="token operator">:</span> ReadWriteProperty<span class="token operator">&lt;</span>Any<span class="token operator">?</span><span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token operator">=</span>    <span class="token keyword">object</span> <span class="token operator">:</span> ObservableProperty<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>initialValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">afterChange</span><span class="token punctuation">(</span>property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> oldValue<span class="token operator">:</span> T<span class="token punctuation">,</span> newValue<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">onChange</span><span class="token punctuation">(</span>property<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><h4 id="vetoable变量值更新前的拦截"><a href="#vetoable变量值更新前的拦截" class="headerlink" title="vetoable变量值更新前的拦截"></a>vetoable变量值更新前的拦截</h4><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">vetoable</span><span class="token punctuation">(</span>initialValue<span class="token operator">:</span> T<span class="token punctuation">,</span> <span class="token keyword">crossinline</span> onChange<span class="token operator">:</span> <span class="token punctuation">(</span>property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> oldValue<span class="token operator">:</span> T<span class="token punctuation">,</span> newValue<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token operator">-></span> Boolean<span class="token punctuation">)</span><span class="token operator">:</span> ReadWriteProperty<span class="token operator">&lt;</span>Any<span class="token operator">?</span><span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token operator">=</span>    <span class="token keyword">object</span> <span class="token operator">:</span> ObservableProperty<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>initialValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">beforeChange</span><span class="token punctuation">(</span>property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> oldValue<span class="token operator">:</span> T<span class="token punctuation">,</span> newValue<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token operator">=</span> <span class="token function">onChange</span><span class="token punctuation">(</span>property<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><p>测试代码</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">var</span> items<span class="token operator">:</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token keyword">by</span> Delegates<span class="token punctuation">.</span><span class="token function">observable</span><span class="token punctuation">(</span><span class="token function">mutableListOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> property<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> newValue <span class="token operator">-></span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">${</span>property<span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span> : <span class="token interpolation variable">$oldValue</span> -> <span class="token interpolation variable">$newValue</span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> nameAfter<span class="token operator">:</span> String <span class="token keyword">by</span> Delegates<span class="token punctuation">.</span><span class="token function">observable</span><span class="token punctuation">(</span><span class="token string">"no"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> prop<span class="token punctuation">,</span> old<span class="token punctuation">,</span> new <span class="token operator">-></span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation variable">$old</span> -> <span class="token interpolation variable">$new</span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> nameBefore<span class="token operator">:</span> String <span class="token keyword">by</span> Delegates<span class="token punctuation">.</span><span class="token function">vetoable</span><span class="token punctuation">(</span><span class="token string">"no"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> prop<span class="token punctuation">,</span> old<span class="token punctuation">,</span> new <span class="token operator">-></span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation variable">$old</span> -> <span class="token interpolation variable">$new</span>"</span><span class="token punctuation">)</span>    <span class="token boolean">true</span> <span class="token comment" spellcheck="true">//返回true 表示 setValue 成功，否则不能覆盖原值</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">onChange</span><span class="token punctuation">(</span>property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> oldValue<span class="token operator">:</span> T<span class="token punctuation">,</span> newValue<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">${</span>property<span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span> : <span class="token interpolation variable">$oldValue</span> -> <span class="token interpolation variable">$newValue</span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> age<span class="token operator">:</span> Int <span class="token keyword">by</span> Delegates<span class="token punctuation">.</span><span class="token function">observable</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token operator">::</span>onChange<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//运行结果</span>no <span class="token operator">-></span> firstfirst <span class="token operator">-></span> secondno <span class="token operator">-></span> <span class="token number">11111</span><span class="token number">11111</span> <span class="token operator">-></span> <span class="token number">2222</span>age <span class="token operator">:</span> <span class="token number">18</span> <span class="token operator">-></span> <span class="token number">33</span>age <span class="token operator">:</span> <span class="token number">33</span> <span class="token operator">-></span> <span class="token number">55</span>items <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span>new <span class="token keyword">val</span><span class="token punctuation">]</span>items <span class="token operator">:</span> <span class="token punctuation">[</span>new <span class="token keyword">val</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span>new <span class="token keyword">val</span><span class="token punctuation">,</span> new <span class="token number">111</span><span class="token punctuation">]</span></code></pre><h2 id="5-属性委托在-Android-上的应用"><a href="#5-属性委托在-Android-上的应用" class="headerlink" title="5. 属性委托在 Android 上的应用"></a>5. 属性委托在 Android 上的应用</h2><h3 id="5-1-ViewBinding"><a href="#5-1-ViewBinding" class="headerlink" title="5.1 ViewBinding"></a>5.1 ViewBinding</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//1. 借助 lazy 属性委托  + 反射 VB 的 inflate 方法</span><span class="token keyword">private</span> <span class="token keyword">val</span> binding<span class="token operator">:</span> ActivityMainBinding <span class="token keyword">by</span> <span class="token function">vb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//2. 借助 lazy 属性委托  + 传递 inflate 方法引用</span><span class="token keyword">private</span> <span class="token keyword">val</span> binding<span class="token operator">:</span> ActivityMainBinding <span class="token keyword">by</span> <span class="token function">vb</span><span class="token punctuation">(</span>ActivityMainBinding<span class="token operator">::</span>inflate<span class="token punctuation">)</span></code></pre><p><strong><a href="https://github.com/jaydroid1024/VBHelper" target="_blank" rel="noopener">VBHelper</a></strong></p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@MainThread</span><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span><span class="token keyword">reified</span> T <span class="token operator">:</span> ViewBinding<span class="token operator">></span> ComponentActivity<span class="token punctuation">.</span><span class="token function">vb</span><span class="token punctuation">(</span><span class="token keyword">noinline</span> inflateMethodRef<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>LayoutInflater<span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token operator">:</span> Lazy<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">=</span>    <span class="token function">ActivityVBLazy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> T<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">,</span> inflateMethodRef<span class="token punctuation">)</span><span class="token keyword">class</span> ActivityVBLazy<span class="token operator">&lt;</span>T <span class="token operator">:</span> ViewBinding<span class="token operator">></span><span class="token punctuation">(</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> activity<span class="token operator">:</span> ComponentActivity<span class="token punctuation">,</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> kClass<span class="token operator">:</span> KClass<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> inflateMethodRef<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>LayoutInflater<span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">:</span> Lazy<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> cachedBinding<span class="token operator">:</span> T<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">override</span> <span class="token keyword">val</span> value<span class="token operator">:</span> T        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> viewBinding <span class="token operator">=</span> cachedBinding            <span class="token keyword">if</span> <span class="token punctuation">(</span>viewBinding <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                viewBinding <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>inflateMethodRef <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//借助 lazy 属性委托 + 传递 inflate 方法引用</span>                    inflateMethodRef<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>activity<span class="token punctuation">.</span>layoutInflater<span class="token punctuation">)</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//借助 lazy 属性委托  + 反射绑定类的 inflate 方法</span>                    <span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"UNCHECKED_CAST"</span><span class="token punctuation">)</span>                    kClass<span class="token punctuation">.</span>java<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>METHOD_INFLATE<span class="token punctuation">,</span> LayoutInflater<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> activity<span class="token punctuation">.</span>layoutInflater<span class="token punctuation">)</span> <span class="token keyword">as</span> T                <span class="token punctuation">}</span>                activity<span class="token punctuation">.</span><span class="token function">setContentView</span><span class="token punctuation">(</span>viewBinding<span class="token punctuation">.</span>root<span class="token punctuation">)</span>                cachedBinding <span class="token operator">=</span> viewBinding            <span class="token punctuation">}</span>            <span class="token keyword">return</span> viewBinding        <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">isInitialized</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> cachedBinding <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">}</span></code></pre><h3 id="5-2-ViewModel"><a href="#5-2-ViewModel" class="headerlink" title="5.2 ViewModel"></a>5.2 ViewModel</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//借助 lazy 属性委托  + ViewModelProvider</span><span class="token keyword">val</span> model<span class="token operator">:</span> MyViewModel <span class="token keyword">by</span> <span class="token function">viewModels</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><strong><a href="https://android.googlesource.com/platform/frameworks/support/+/0699f8f5b5aa7d79ba48d57a3710989ae2f50ee3/activity/ktx/src/main/java/androidx/activity/ActivityViewModelLazy.kt" target="_blank" rel="noopener">ActivityViewModelLazy</a></strong></p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@MainThread</span><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span><span class="token keyword">reified</span> VM <span class="token operator">:</span> ViewModel<span class="token operator">></span> ComponentActivity<span class="token punctuation">.</span><span class="token function">viewModels</span><span class="token punctuation">(</span>    factory<span class="token operator">:</span> ViewModelProvider<span class="token punctuation">.</span>Factory<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token operator">:</span> Lazy<span class="token operator">&lt;</span>VM<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">ActivityViewModelLazy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> VM<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">,</span> factory<span class="token punctuation">)</span><span class="token comment" spellcheck="true">/** * An implementation of [Lazy] used by [ComponentActivity.viewModels] tied to the given [activity], * [viewModelClass], [factory] */</span><span class="token keyword">class</span> ActivityViewModelLazy<span class="token operator">&lt;</span>VM <span class="token operator">:</span> ViewModel<span class="token operator">></span><span class="token punctuation">(</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> activity<span class="token operator">:</span> ComponentActivity<span class="token punctuation">,</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> viewModelClass<span class="token operator">:</span> KClass<span class="token operator">&lt;</span>VM<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> factory<span class="token operator">:</span> ViewModelProvider<span class="token punctuation">.</span>Factory<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">:</span> Lazy<span class="token operator">&lt;</span>VM<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> cached<span class="token operator">:</span> VM<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">override</span> <span class="token keyword">val</span> value<span class="token operator">:</span> VM        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> viewModel <span class="token operator">=</span> cached            <span class="token keyword">if</span> <span class="token punctuation">(</span>viewModel <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">val</span> application <span class="token operator">=</span> activity<span class="token punctuation">.</span>application                    <span class="token operator">?:</span> <span class="token keyword">throw</span> <span class="token function">IllegalArgumentException</span><span class="token punctuation">(</span>                        <span class="token string">"ViewModel can be accessed "</span> <span class="token operator">+</span>                                <span class="token string">"only when Activity is attached"</span>                    <span class="token punctuation">)</span>                <span class="token keyword">val</span> resolvedFactory <span class="token operator">=</span> factory <span class="token operator">?:</span> AndroidViewModelFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>application<span class="token punctuation">)</span>                viewModel <span class="token operator">=</span> <span class="token function">ViewModelProvider</span><span class="token punctuation">(</span>activity<span class="token punctuation">,</span> resolvedFactory<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>viewModelClass<span class="token punctuation">.</span>java<span class="token punctuation">)</span>                cached <span class="token operator">=</span> viewModel            <span class="token punctuation">}</span>            <span class="token keyword">return</span> viewModel        <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">isInitialized</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> cached <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">}</span></code></pre><p><strong><a href="https://android.googlesource.com/platform/frameworks/support/+/0699f8f5b5aa7d79ba48d57a3710989ae2f50ee3/fragment/ktx/src/main/java/androidx/fragment/app/FragmentViewModelLazy.kt" target="_blank" rel="noopener">FragmentViewModelLazy</a></strong></p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@MainThread</span><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span><span class="token keyword">reified</span> VM <span class="token operator">:</span> ViewModel<span class="token operator">></span> Fragment<span class="token punctuation">.</span><span class="token function">viewModels</span><span class="token punctuation">(</span>factory<span class="token operator">:</span> Factory<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token operator">:</span> Lazy<span class="token operator">&lt;</span>VM<span class="token operator">></span> <span class="token operator">=</span>    <span class="token function">FragmentViewModelLazy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> VM<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">,</span> factory<span class="token punctuation">)</span><span class="token comment" spellcheck="true">/** * An implementation of [Lazy] used by [Fragment.viewModels] tied to the given [fragment], * [viewModelClass], [factory] */</span><span class="token keyword">class</span> FragmentViewModelLazy<span class="token operator">&lt;</span>VM <span class="token operator">:</span> ViewModel<span class="token operator">></span><span class="token punctuation">(</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> fragment<span class="token operator">:</span> Fragment<span class="token punctuation">,</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> viewModelClass<span class="token operator">:</span> KClass<span class="token operator">&lt;</span>VM<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> factory<span class="token operator">:</span> Factory<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">:</span> Lazy<span class="token operator">&lt;</span>VM<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> cached<span class="token operator">:</span> VM<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">override</span> <span class="token keyword">val</span> value<span class="token operator">:</span> VM        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> viewModel <span class="token operator">=</span> cached            <span class="token keyword">if</span> <span class="token punctuation">(</span>viewModel <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">val</span> application <span class="token operator">=</span> fragment<span class="token punctuation">.</span>activity<span class="token operator">?</span><span class="token punctuation">.</span>application                    <span class="token operator">?:</span> <span class="token keyword">throw</span> <span class="token function">IllegalArgumentException</span><span class="token punctuation">(</span>                        <span class="token string">"ViewModel can be accessed "</span> <span class="token operator">+</span>                                <span class="token string">"only when Fragment is attached"</span>                    <span class="token punctuation">)</span>                <span class="token keyword">val</span> resolvedFactory <span class="token operator">=</span> factory <span class="token operator">?:</span> AndroidViewModelFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>application<span class="token punctuation">)</span>                viewModel <span class="token operator">=</span> <span class="token function">ViewModelProvider</span><span class="token punctuation">(</span>fragment<span class="token punctuation">,</span> resolvedFactory<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>viewModelClass<span class="token punctuation">.</span>java<span class="token punctuation">)</span>                cached <span class="token operator">=</span> viewModel            <span class="token punctuation">}</span>            <span class="token keyword">return</span> viewModel        <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">isInitialized</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> cached <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">}</span></code></pre><h3 id="5-3-SP-delegates"><a href="#5-3-SP-delegates" class="headerlink" title="5.3 SP delegates"></a>5.3 SP delegates</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> SharedPreferences<span class="token punctuation">.</span><span class="token function">int</span><span class="token punctuation">(</span>def<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> key<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">=</span>    <span class="token function">delegate</span><span class="token punctuation">(</span>def<span class="token punctuation">,</span> key<span class="token punctuation">,</span> SharedPreferences<span class="token operator">::</span>getInt<span class="token punctuation">,</span> SharedPreferences<span class="token punctuation">.</span>Editor<span class="token operator">::</span>putInt<span class="token punctuation">)</span><span class="token keyword">fun</span> SharedPreferences<span class="token punctuation">.</span><span class="token function">long</span><span class="token punctuation">(</span>def<span class="token operator">:</span> Long <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> key<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">=</span>    <span class="token function">delegate</span><span class="token punctuation">(</span>def<span class="token punctuation">,</span> key<span class="token punctuation">,</span> SharedPreferences<span class="token operator">::</span>getLong<span class="token punctuation">,</span> SharedPreferences<span class="token punctuation">.</span>Editor<span class="token operator">::</span>putLong<span class="token punctuation">)</span><span class="token keyword">fun</span> SharedPreferences<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span>def<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> key<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">=</span>    <span class="token function">delegate</span><span class="token punctuation">(</span>def<span class="token punctuation">,</span> key<span class="token punctuation">,</span> SharedPreferences<span class="token operator">::</span>getString<span class="token punctuation">,</span> SharedPreferences<span class="token punctuation">.</span>Editor<span class="token operator">::</span>putString<span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> SharedPreferences<span class="token punctuation">.</span><span class="token function">delegate</span><span class="token punctuation">(</span>    defaultValue<span class="token operator">:</span> T<span class="token punctuation">,</span>    key<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">,</span>    <span class="token keyword">crossinline</span> getter<span class="token operator">:</span> SharedPreferences<span class="token punctuation">.</span><span class="token punctuation">(</span>String<span class="token punctuation">,</span> T<span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">,</span>    <span class="token keyword">crossinline</span> setter<span class="token operator">:</span> SharedPreferences<span class="token punctuation">.</span>Editor<span class="token punctuation">.</span><span class="token punctuation">(</span>String<span class="token punctuation">,</span> T<span class="token punctuation">)</span> <span class="token operator">-></span> SharedPreferences<span class="token punctuation">.</span>Editor<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">object</span> <span class="token operator">:</span> ReadWriteProperty<span class="token operator">&lt;</span>Any<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">getValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span>        <span class="token function">getter</span><span class="token punctuation">(</span>key <span class="token operator">?:</span> property<span class="token punctuation">.</span>name<span class="token punctuation">,</span> defaultValue<span class="token punctuation">)</span>    <span class="token annotation builtin">@SuppressLint</span><span class="token punctuation">(</span><span class="token string">"CommitPrefEdits"</span><span class="token punctuation">)</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">setValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> value<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token operator">=</span>        <span class="token function">edit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setter</span><span class="token punctuation">(</span>key <span class="token operator">?:</span> property<span class="token punctuation">.</span>name<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>测试代码</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> <span class="token function">TokenHolder</span><span class="token punctuation">(</span>prefs<span class="token operator">:</span> SharedPreferences<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> token<span class="token operator">:</span> String <span class="token keyword">by</span> prefs<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">private</span> <span class="token keyword">set</span>    <span class="token keyword">var</span> count <span class="token keyword">by</span> prefs<span class="token punctuation">.</span><span class="token function">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">private</span> <span class="token keyword">set</span>    <span class="token keyword">fun</span> <span class="token function">saveToken</span><span class="token punctuation">(</span>newToken<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>        token <span class="token operator">=</span> newToken        count<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"TokenHolder(token='<span class="token interpolation variable">$token</span>', count=<span class="token interpolation variable">$count</span>)"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token function">UserHolder</span><span class="token punctuation">(</span>prefs<span class="token operator">:</span> SharedPreferences<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> name<span class="token operator">:</span> String <span class="token keyword">by</span> prefs<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">private</span> <span class="token keyword">set</span>    <span class="token keyword">var</span> pwd<span class="token operator">:</span> String <span class="token keyword">by</span> prefs<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">private</span> <span class="token keyword">set</span>    <span class="token keyword">fun</span> <span class="token function">saveUserAccount</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">,</span> pwd<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name        <span class="token keyword">this</span><span class="token punctuation">.</span>pwd <span class="token operator">=</span> pwd    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"UserHolder(name='<span class="token interpolation variable">$name</span>', pwd='<span class="token interpolation variable">$pwd</span>')"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">val</span> prefs <span class="token operator">=</span> <span class="token function">getSharedPreferences</span><span class="token punctuation">(</span><span class="token string">"sp_app_jay"</span><span class="token punctuation">,</span> Context<span class="token punctuation">.</span>MODE_PRIVATE<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//缓存Token的场景</span><span class="token keyword">val</span> tokenHolder <span class="token operator">=</span> <span class="token function">TokenHolder</span><span class="token punctuation">(</span>prefs<span class="token punctuation">)</span>Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"Jay"</span><span class="token punctuation">,</span> <span class="token string">"tokenHolder:<span class="token interpolation variable">$tokenHolder</span>"</span><span class="token punctuation">)</span>tokenHolder<span class="token punctuation">.</span><span class="token function">saveToken</span><span class="token punctuation">(</span><span class="token string">"token_one"</span><span class="token punctuation">)</span>tokenHolder<span class="token punctuation">.</span><span class="token function">saveToken</span><span class="token punctuation">(</span><span class="token string">"token_second"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//缓存登录信息的场景</span><span class="token keyword">val</span> userHolder <span class="token operator">=</span> <span class="token function">UserHolder</span><span class="token punctuation">(</span>prefs<span class="token punctuation">)</span>Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"Jay"</span><span class="token punctuation">,</span> <span class="token string">"userHolder:<span class="token interpolation variable">$userHolder</span>"</span><span class="token punctuation">)</span>userHolder<span class="token punctuation">.</span><span class="token function">saveUserAccount</span><span class="token punctuation">(</span><span class="token string">"jay"</span><span class="token punctuation">,</span> <span class="token string">"123456"</span><span class="token punctuation">)</span></code></pre><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>本篇文章围绕 Kotlin 的内置委托(Delegation﻿) 特性并结合代码实践分别阐述了 Kotlin 委托的原理(包括属性委托和接口委托)，尤其是属性委托从属性到委托详细阐述了其实现原理，</p><p>然后是实践部分，首先是Kotlin 标准库中利用属性委托为我们封装了很多简洁的API，比如：map、lazy、notNull、Observable 等；然后是Kotlin 属性委托在 Android 上的一些实践，包括 VB、VM、SP 等利用属性委托基本上都能完成一行代码实现set/get。Kotlin 委托显然在消除样板代码方面能发挥出强大的作用。但是这每个属性的背后却对应这一个委托类，所以在大量使用时也需要兼顾性能。</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h2><p><a href="https://www.kotlincn.net/docs/reference/delegation.html" target="_blank" rel="noopener">官方文档 | 委托</a></p><p><a href="https://www.kotlincn.net/docs/reference/delegated-properties.html" target="_blank" rel="noopener">官方文档 | 属性委托</a></p><p><a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">慕课网 | 新版 Kotlin 从入门到精通</a></p><p><a href="https://juejin.cn/post/6844904038589267982" target="_blank" rel="noopener">一文彻底搞懂Kotlin中的委托</a></p><p><a href="https://en.wikipedia.org/wiki/Delegation_pattern" target="_blank" rel="noopener">Wikipedia | Delegation pattern</a></p><p><a href="https://en.wikipedia.org/wiki/Proxy_pattern" target="_blank" rel="noopener">Wikipedia | Proxy pattern</a></p><p><a href="https://proandroiddev.com/kotlin-delegates-in-android-1ab0a715762d" target="_blank" rel="noopener">Medium | Kotlin Delegates in Android</a></p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ViewBinding </tag>
            
            <tag> Kotlin 委托 </tag>
            
            <tag> 属性委托 </tag>
            
            <tag> ViewModel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDispatcher-Android组件生命周期分发框架</title>
      <link href="2021/07/31/jdispatcher/"/>
      <url>2021/07/31/jdispatcher/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/post_banner_jay.png" alt=""></p><h1 id="JDispatcher"><a href="#JDispatcher" class="headerlink" title="JDispatcher"></a>JDispatcher</h1><p>Android 组件生命周期分发框架，适用于组件化，模块化，启动优化等场景</p><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210729184216.png" alt=""></p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ul><li>实现 Application 各个生命周期方法在所有需要的组件中分发</li><li>分发顺序支持多种规则<ul><li>优先级：优先级值越大越先被调用</li><li>依赖项：组件依赖的分发类先初始化</li><li>支持自动校正在优先级和依赖项两种规则交叉使用情况下的分发顺序</li></ul></li><li>分发维度支持多种规则<ul><li>在指定进程(所有进程，主进程，非主进程)中分发</li><li>在指定线程(主线程，空闲线程，工作线程)中分发，实现异步加载</li><li>支持通过非阻塞式异步通知机制实现异步加载与同步加载交叉使用的情况（todo）</li><li>手动延迟调用分发，实现延迟加载</li><li>通过 ContentProvider 实现在 Application 之前超前预加载（todo）</li><li>只在debug模式下分发，实现 DevTools、DoKit 等开发工具的初始化</li></ul></li><li>维度值采用对整型 or/and 的位操作完成多维度值的收集与识别，灵活且高效</li><li>支持初始化时批量传参，可用于多项目多环境的三方 sdk 的初始化，使环境配置更统一</li><li>通过注解打点，APT 增量收集分发类，降低耦合，可用于模块化，组件化场景</li><li>通过拦截 AGP 构建流程实现在编译期间对分发类的扫描和排序，提高运行时性能</li><li>AGP Transform 增量支持编译（todo）</li><li>通过 ASM 字节码插桩实现分发表和 Application  生命周期回调方法的自动注入，集成更高效</li><li>支持统计所有分发类的初始化时间，可用于启动优化的统计与排查</li></ul><h2 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h2><ul><li><p>jdispatcher-annotation</p><ul><li>模块类型：apply plugin: ‘java’</li><li>模块描述：声明编译时所需的注解类以及公共类等</li></ul></li><li><p>jdispatcher-compiler</p><ul><li>模块类型：apply plugin: ‘java’</li><li>模块描述：编译期(.java–.class阶段) 收集和处理整个工程中的Dispatch注解信息并通过 javapoet 生成辅助类文件 JDispatcher$$Group_hash.java </li></ul></li><li><p>jdispatcher-plugin</p><ul><li><p>模块类型：apply plugin: ‘groovy’</p></li><li><p>模块描述：编译期(.class–.dex阶段) 自定义Transform拦截AGP的构建过程，找到所有Dispatch并排序</p></li><li><p>模块主要工作：</p><ul><li>第一个：IDispatch 的分发流程<ul><li>扫描到所有 APT 生成的 JDispatcher$$Group_hash.java 文件</li><li>反射获取收集到的 Map&lt;String, DispatchItem&gt; atlas)</li><li>通过 atlas 集合收集到的 DispatchItem 实现对 IDispatch 对象的反射实例化</li><li>按照 DispatchItem 的排序规则完成排序操作</li><li>将排好序的 IDispatch 集合通过字节码插桩到 JDispatcher 中，运行时执行对所有 IDispatch 的分发操作</li></ul></li><li>第二个：Application 生命周期方法的自动注册流程<ul><li>通过调用方在gradle中配置的 Application 全类名，在自定义Transform中扫描到该类</li><li>JDispatcher 调用字节码注入到 onTerminate()</li><li>JDispatcher 调用字节码注入到 onConfigurationChanged(newConfig: Configuration)</li><li>JDispatcher 调用字节码注入到 onLowMemory()</li><li>JDispatcher 调用字节码注入到 onTrimMemory(level: Int)</li></ul></li></ul></li></ul></li><li><p>jdispatcher-api</p><ul><li>模块类型：apply plugin: ‘com.android.library’</li><li>模块描述：运行时用于整个框架的初始化，运行时分发等操作</li></ul></li></ul><h2 id="集成说明"><a href="#集成说明" class="headerlink" title="集成说明"></a>集成说明</h2><p><a href="https://jitpack.io/#jaydroid1024/JDispatcher" target="_blank" rel="noopener"><img src="https://jitpack.io/v/jaydroid1024/JDispatcher.svg" alt=""></a></p><pre class=" language-groovy"><code class="language-groovy"><span class="token comment" spellcheck="true">//Step 1. Add the JitPack repository to your build file</span><span class="token comment" spellcheck="true">//buildscript &amp; allprojects</span>allprojects <span class="token punctuation">{</span>    repositories <span class="token punctuation">{</span>        <span class="token punctuation">...</span>        maven <span class="token punctuation">{</span> url <span class="token string">'https://jitpack.io'</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//dependencies</span>classpath <span class="token string">'com.github.jaydroid1024.JDispatcher:jdispatcher-plugin:$last_version'</span><span class="token comment" spellcheck="true">//Step 2. Add the dependency</span>implementation <span class="token string">'com.github.jaydroid1024.JDispatcher:jdispatcher-api:$last_version'</span>kapt <span class="token string">'com.github.jaydroid1024.JDispatcher:jdispatcher-compiler:$last_version'</span><span class="token comment" spellcheck="true">//Step 3. apply the plugin and config dispatcher</span>apply plugin<span class="token punctuation">:</span> <span class="token string">'jdispatcher'</span>dispatcher <span class="token punctuation">{</span>    appCanonicalName <span class="token operator">=</span> <span class="token string">"com.jay.android.App"</span>    buildIncremental <span class="token operator">=</span> <span class="token boolean">false</span>    buildDebug <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">}</span></code></pre><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> App <span class="token operator">:</span> <span class="token function">Application</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//为分发类指定自定义参数，用于三方key的统一收口配置</span>        <span class="token keyword">val</span> dispatchExtraParam <span class="token operator">=</span> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>        dispatchExtraParam<span class="token punctuation">[</span><span class="token string">"com.jay.android.jdispatcher.DispatcherAppDemo"</span><span class="token punctuation">]</span> <span class="token operator">=</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>BuildConfig<span class="token punctuation">.</span>DEBUG<span class="token punctuation">)</span> <span class="token function">hashMapOf</span><span class="token punctuation">(</span>                <span class="token function">Pair</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">,</span> <span class="token string">"value1_debug"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token function">Pair</span><span class="token punctuation">(</span><span class="token string">"key2"</span><span class="token punctuation">,</span> <span class="token string">"value2_debug"</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span>            <span class="token keyword">else</span> <span class="token function">hashMapOf</span><span class="token punctuation">(</span>                <span class="token function">Pair</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">,</span> <span class="token string">"value1_release"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token function">Pair</span><span class="token punctuation">(</span><span class="token string">"key2"</span><span class="token punctuation">,</span> <span class="token string">"value2_release"</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//自动分发</span>        JDispatcher<span class="token punctuation">.</span>instance            <span class="token punctuation">.</span><span class="token function">withDebugAble</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//调试模式：打印更多日志，实时刷新等</span>            <span class="token punctuation">.</span><span class="token function">withDispatchExtraParam</span><span class="token punctuation">(</span>dispatchExtraParam<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//分发参数</span>            <span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// region如果在 app build.gradle 中配置了</span><span class="token comment" spellcheck="true">// dispatcher {appCanonicalName = "com.jay.android.App"}</span><span class="token comment" spellcheck="true">// 就不需要添加以下代码,dispatcher 插件会自动注入</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        JDispatcher<span class="token punctuation">.</span>instance<span class="token punctuation">.</span><span class="token function">onTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onConfigurationChanged</span><span class="token punctuation">(</span>newConfig<span class="token operator">:</span> Configuration<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onConfigurationChanged</span><span class="token punctuation">(</span>newConfig<span class="token punctuation">)</span>        JDispatcher<span class="token punctuation">.</span>instance<span class="token punctuation">.</span><span class="token function">onConfigurationChanged</span><span class="token punctuation">(</span>newConfig<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onLowMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onLowMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        JDispatcher<span class="token punctuation">.</span>instance<span class="token punctuation">.</span><span class="token function">onLowMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onTrimMemory</span><span class="token punctuation">(</span>level<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onTrimMemory</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span>        JDispatcher<span class="token punctuation">.</span>instance<span class="token punctuation">.</span><span class="token function">onTrimMemory</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//endregion</span><span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//手动调用分发</span>JDispatcher<span class="token punctuation">.</span>instance    <span class="token punctuation">.</span><span class="token function">manualDispatch</span><span class="token punctuation">(</span><span class="token string">"com.jay.android.jdispatcher.DispatcherAppDemo"</span><span class="token punctuation">)</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//声明分发类</span><span class="token annotation builtin">@Dispatch</span><span class="token punctuation">(</span>priority <span class="token operator">=</span> Priority<span class="token punctuation">.</span>LOW_DEFAULT<span class="token punctuation">,</span> description <span class="token operator">=</span> <span class="token string">"DispatcherAppDemo"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> DispatcherAppDemo extends DispatchTemplate <span class="token punctuation">{</span>    <span class="token annotation builtin">@Override</span>    <span class="token keyword">public</span> void <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token annotation builtin">@NotNull</span> Application app<span class="token punctuation">,</span> <span class="token annotation builtin">@NotNull</span> DispatchItem dispatchItem<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"Jay"</span><span class="token punctuation">,</span> <span class="token string">"DispatcherAppDemo#onCreate"</span> <span class="token operator">+</span> dispatchItem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation builtin">@Override</span>    <span class="token keyword">public</span> void <span class="token function">onConfigurationChanged</span><span class="token punctuation">(</span><span class="token annotation builtin">@NotNull</span> Configuration newConfig<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"Jay"</span><span class="token punctuation">,</span> <span class="token string">"DispatcherAppDemo#onConfigurationChanged"</span> <span class="token operator">+</span> newConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation builtin">@Override</span>    <span class="token keyword">public</span> void <span class="token function">onLowMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"Jay"</span><span class="token punctuation">,</span> <span class="token string">"DispatcherAppDemo#onLowMemory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation builtin">@Override</span>    <span class="token keyword">public</span> void <span class="token function">onTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"Jay"</span><span class="token punctuation">,</span> <span class="token string">"DispatcherAppDemo#onTerminate"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation builtin">@Override</span>    <span class="token keyword">public</span> void <span class="token function">onTrimMemory</span><span class="token punctuation">(</span>int level<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"Jay"</span><span class="token punctuation">,</span> <span class="token string">"DispatcherAppDemo#onTrimMemory"</span> <span class="token operator">+</span> level<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-groovy"><code class="language-groovy">#Jdispatcher 混淆配置<span class="token operator">-</span>keep <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">com<span class="token punctuation">.</span>jay<span class="token punctuation">.</span>android<span class="token punctuation">.</span>dispatcher<span class="token punctuation">.</span></span><span class="token operator">**</span><span class="token punctuation">{</span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">-</span>keep <span class="token keyword">class</span> <span class="token operator">*</span> <span class="token keyword">implements</span> <span class="token class-name">com<span class="token punctuation">.</span>jay<span class="token punctuation">.</span>android<span class="token punctuation">.</span>dispatcher<span class="token punctuation">.</span>common<span class="token punctuation">.</span>IDispatch</span><span class="token punctuation">{</span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><ul><li><p>支持通过非阻塞式异步通知机制实现异步加载与同步加载交叉使用的情况</p></li><li><p>通过 ContentProvider 实现在 Application 之前超前预加载</p></li><li><p>AGP Transform 增量支持编译</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://github.com/alibaba/ARouter/blob/master/README_CN.md" target="_blank" rel="noopener">ARouter</a> 是一个用于帮助 Android App 进行组件化改造的框架 —— 支持模块间的路由、通信、解耦</p></li><li><p><a href="https://github.com/bingoogolapple/AppInit" target="_blank" rel="noopener">AppInit</a> 是一款 Android 应用初始化框架，基于组件化的设计思路，功能灵活，使用简单。</p></li><li><p><a href="https://github.com/meituan/WMRouter" target="_blank" rel="noopener"><em>WMRouter</em></a> 是一款Android路由框架，基于组件化的设计思路，有功能灵活、使用简单的特点</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化 </tag>
            
            <tag> 注解 </tag>
            
            <tag> Gradle Plugin </tag>
            
            <tag> ASM </tag>
            
            <tag> APT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筑基系列-计算机网络基础知识小抄版</title>
      <link href="2021/07/31/computer-net/"/>
      <url>2021/07/31/computer-net/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/post_banner_jay.png" alt=""></p><h1 id="筑基系列-计算机网络基础知识小抄版"><a href="#筑基系列-计算机网络基础知识小抄版" class="headerlink" title="筑基系列-计算机网络基础知识小抄版"></a>筑基系列-计算机网络基础知识小抄版</h1><blockquote><p>计算机基础知识筑基三部曲：</p><ul><li><strong><a href="https://juejin.cn/post/6991367806772052004" target="_blank" rel="noopener">第一部：筑基系列-计算机基础知识小抄版</a></strong><ul><li>包括发展史、CPU、总线、存储器、指令系统、控制器、运算器、位运算等</li></ul></li><li><strong><a href="https://juejin.cn/post/6991385109509193764" target="_blank" rel="noopener">第二部：筑基系列-操作系统基础知识小抄版</a></strong><ul><li>包括进程与线程同步管理、作业管理、存储管理、虚拟内存、Linux、文件管理等</li></ul></li><li><strong><a href="https://juejin.cn/post/6991397445251334151" target="_blank" rel="noopener">第三部：筑基系列-计算机网络基础知识小抄版</a></strong><ul><li>包括OSI七层模型各层详解、IP协议、TCP\IP协议、Http协议、DNS协议等</li></ul></li></ul></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p><a href="#1.计算机网络概述">1.计算机网络概述</a></p><ul><li><a href="#11-什么是计算机网络">1.1 什么是计算机网络</a></li><li><a href="#12-计算机网络的分类">1.2 计算机网络的分类</a></li><li><a href="#13-计算机网络的发展历史">1.3 计算机网络的发展历史</a></li><li><a href="#14-计算机网络的层次结构">1.4 计算机网络的层次结构</a></li><li><a href="#15-现代互联网的网络拓扑">1.5 现代互联网的网络拓扑</a></li><li><a href="#16-计算机网络的性能指标">1.6 计算机网络的性能指标</a></li></ul></li><li><p><a href="#2.物理层">2.物理层</a></p><ul><li><a href="#21-物理层的作用">2.1 物理层的作用</a></li><li><a href="#22-信道的基本概念">2.2 信道的基本概念</a></li></ul></li><li><p><a href="#3.数据链路层">3.数据链路层</a></p><ul><li><a href="#31-数据链路层主要功能">3.1 数据链路层主要功能</a></li><li><a href="#32-最大传输单元mtu">3.2 最大传输单元MTU</a></li><li><a href="#33-以太网协议详解">3.3 以太网协议详解</a></li></ul></li><li><p><a href="#4.网络层">4.网络层</a></p><ul><li><a href="#41-网络层的主要功能">4.1 网络层的主要功能</a></li><li><a href="#42-ip协议详解">4.2 IP协议详解</a></li><li><a href="#43-ip协议的转发流程">4.3 IP协议的转发流程</a></li><li><a href="#44-arp协议与rarp协议">4.4 ARP协议与RARP协议</a></li><li><a href="#45-ip地址的分类">4.5 IP地址的分类</a></li><li><a href="#46-ip地址的划分子网">4.6 IP地址的划分子网</a></li><li><a href="#47-无分类地址cidr">4.7 无分类地址CIDR</a></li><li><a href="#48-网络地址转换nat技术">4.8 网络地址转换NAT技术</a></li><li><a href="#49-icmp协议详解">4.9 ICMP协议详解</a></li><li><a href="#410-网络层的路由概述">4.10 网络层的路由概述</a></li><li><a href="#411-自治系统as">4.11 自治系统(AS)</a></li><li><a href="#412-内部网关路由协议之rip协议">4.12 内部网关路由协议之RIP协议</a></li><li><a href="#413-外部网关路由协议之bgp协议">4.13 外部网关路由协议之BGP协议</a></li></ul></li><li><p><a href="#5.传输层">5.传输层</a></p><ul><li><a href="#51-传输层的主要功能">5.1 传输层的主要功能</a></li><li><a href="#52-udp协议详解">5.2 UDP协议详解</a></li><li><a href="#53-tcp报文详解">5.3 TCP报文详解</a></li><li><a href="#54-tcp可靠传输的基本原理">5.4 TCP可靠传输的基本原理</a></li><li><a href="#55-tcp协议的可靠传输">5.5 TCP协议的可靠传输</a></li><li><a href="#56-tcp协议的流量控制">5.6 TCP协议的流量控制</a></li><li><a href="#57-tcp协议的拥塞控制">5.7 TCP协议的拥塞控制</a></li><li><a href="#58-tcp连接的建立">5.8 TCP连接的建立</a></li><li><a href="#59-tcp连接的释放">5.9 TCP连接的释放</a></li><li><a href="#510-套接字与套接字编程">5.10 套接字与套接字编程</a></li></ul></li><li><p><a href="#6.应用层">6.应用层</a></p><ul><li><p><a href="#61-应用层概述">6.1 应用层概述</a></p></li><li><p><a href="#62-应用层主要功能">6.2 应用层主要功能</a></p></li><li><p><a href="#63-dns服务详解">6.3 DNS服务详解</a></p></li><li><p><a href="#64-dhcp协议详解">6.4 DHCP协议详解</a></p></li><li><p><a href="#65-http协议详解">6.5 HTTP协议详解</a></p></li><li><p><a href="#66-http工作的结构">6.6 HTTP工作的结构</a></p></li><li><p><a href="#67-https协议详解">6.7 HTTPS协议详解</a></p></li><li><p><a href="#68-输入域名按下回车键的过程有哪些">6.8 输入域名按下回车键的过程有哪些</a></p></li></ul></li><li><p><a href="#7.HTTP协议详解">7.HTTP协议详解</a></p><ul><li><a href="#71-浏览器背后的故事">7.1 浏览器背后的故事</a></li><li><a href="#72-http协议的前世今生">7.2 HTTP协议的前世今生</a></li><li><a href="#73-透过tcpip看http">7.3 透过TCP/IP看HTTP</a></li></ul></li><li><p><a href="#8.计算机网络实践">8.计算机网络实践</a></p><ul><li><a href="#81-网络嗅探工具">8.1 网络嗅探工具</a></li></ul></li><li><p><a href="#9关于我">9.关于我</a></p></li><li><p><a href="#10参考">10.参考</a></p></li></ul><h2 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1.计算机网络概述"></a>1.计算机网络概述</h2><h3 id="1-1-什么是计算机网络"><a href="#1-1-什么是计算机网络" class="headerlink" title="1.1 什么是计算机网络"></a>1.1 什么是计算机网络</h3><ul><li>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统</li><li>计算机网络的不是软件概念，还包含硬件设备</li><li>计算机网络不仅仅是信息通信，还可以支持广泛的应用</li></ul><h3 id="1-2-计算机网络的分类"><a href="#1-2-计算机网络的分类" class="headerlink" title="1.2 计算机网络的分类"></a>1.2 计算机网络的分类</h3><table><thead><tr><th>分类</th><th>英文</th><th>范围</th><th>区域</th></tr></thead><tbody><tr><td>广域网</td><td>WAN(Wide Area Network)</td><td>几十到几千公里</td><td>跨省、跨国</td></tr><tr><td>城域网</td><td>MAN(Metro. Area Network)</td><td>5KM-50KM</td><td>城市间</td></tr><tr><td>局域网</td><td>LAN(Local Area Network)</td><td>1KM以内</td><td>地区内</td></tr></tbody></table><h3 id="计算机网络的发展历史"><a href="#计算机网络的发展历史" class="headerlink" title="计算机网络的发展历史"></a>计算机网络的发展历史</h3><ul><li><p>世界互联网发展历史</p><ul><li>单个网络 ARPANET<ul><li>计算机–&gt;交换机&lt;–计算机</li></ul></li><li>三级结构互联网<ul><li>主干网–&gt;地区网–&gt;校园网</li></ul></li><li>多层次ISP互联网<ul><li>ISP(Internet Service Provider): 网络服务提供商</li><li>中国电信、中国移动、中国联通等</li><li>主干ISP(海底电缆)–&gt;地区ISP(山东移动)–&gt;校园、家庭、公司</li><li>查看全球网络地图：<a href="https://www.infrapedia.com/app" target="_blank" rel="noopener">https://www.infrapedia.com/app</a></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801171046.jpg" alt=""></p></li><li><p>中国互联网的发展历史</p><ul><li>1980 年开始互联网实验</li><li>1989 年第一个公共网络建立运行</li><li>1994 接入国际互联网</li><li>中国的互联网企业<ul><li>中国电信互联网CHINANET</li><li>中国联通互联网UNINET</li><li>中国移动互联网CMNET</li><li>中国教育与科研计算机网CERNET</li><li>中国科学技术网CSTNET</li><li>1996年，张朝阳创建搜狐</li><li>1997年，丁磊创建网易</li><li>1998年，王志东创建新浪</li><li>1998年，马化腾、张志东创建腾讯</li><li>1999年，马云创建阿里巴巴</li><li>2000年，李彦宏创建百度</li></ul></li></ul></li></ul><h3 id="1-4-计算机网络的层次结构"><a href="#1-4-计算机网络的层次结构" class="headerlink" title="1.4 计算机网络的层次结构"></a>1.4 计算机网络的层次结构</h3><ul><li>层次结构设计的基本原则<ul><li>分层实现不同的功能<ul><li>保证数据通路顺畅</li><li>识别目的计算机</li><li>目的计算机状态</li><li>数据是否错误</li><li>层次划分：网络应用数据(视频、文件、游戏)–&gt;数据可靠通信(数据错误、重复)–&gt;物理网络接入(光电等物理特性)</li></ul></li><li>各层之间是相互独立的</li><li>每一层要有足够的灵活性</li><li>各层之间完全解耦</li></ul></li><li>OSI七层模型<ul><li>应用层：为计算机用户提供接口和服务</li><li>表示层：数据处理（编码解码、加密解密等）</li><li>会话层：管理（建立、维护、重连）通信会话</li><li>传输层：管理端到端的通信连接</li><li>网络层：数据路由（决定数据在网络的路径）</li><li>数据链路层：管理相邻节点之间的数据通信</li><li>物理层：数据通信的光电物理特性</li><li>OSI在市场化过程中困难重重， TCP/IP在全球范围成功运行</li><li>OSI欲成为全球计算机都遵循的标准</li><li>OSI最终并没有成为广为使用的标准模型</li><li>为什么没有被接受<ul><li>OSI标准制定周期过长，按OSI标准生产的设备无法及时进入市场</li><li>OSI的专家缺乏实际经验</li><li>OSI模型设计的并不合理，一些功能在多层中重复出现</li></ul></li></ul></li><li>TCP/IP四层模型<ul><li>应用层：HTTP/FTP/… ，对应OSI的应用层、表示层、会话层</li><li>传输层：TCP/UDP，对应OSI的传输层</li><li>网络层：IP/ICMP，对应OSI的网络层</li><li>网络接口层：Ethernet/ARP/RARP，对应OSI的数据链路层、物理层</li></ul></li></ul><h3 id="1-5-现代互联网的网络拓扑"><a href="#1-5-现代互联网的网络拓扑" class="headerlink" title="1.5 现代互联网的网络拓扑"></a>1.5 现代互联网的网络拓扑</h3><ul><li>边缘部分<ul><li>家庭：终端机器(手机)–&gt;路由器–&gt;网关–&gt;地区ISP</li><li>企业：终端机器(电脑)–&gt;路由器–&gt;内部网关–&gt;统一网关–&gt;地区ISP</li></ul></li><li>核心部分<ul><li>地区ISP–&gt;主干ISP–&gt;国际路由器</li></ul></li><li>网络连接错综复杂</li><li>接入设备数以亿计</li><li>网络覆盖边际全球</li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801171055.jpg" alt=""></p><ul><li>客户-服务器(C/S)模式<ul><li>C请求服务–&gt;S获得服务</li></ul></li><li>对等连接(P2P)模式</li></ul><h3 id="1-6-计算机网络的性能指标"><a href="#1-6-计算机网络的性能指标" class="headerlink" title="1.6 计算机网络的性能指标"></a>1.6 计算机网络的性能指标</h3><ul><li>速率<ul><li>速率单位： bps=bit/s</li><li>为什么电信拉的100M光纤，测试峰值速度只有12M每秒？<ul><li>bps到字节的转换</li><li>网络常用单位为(Mbps)</li><li>100M/s = 100Mbps = 100Mbit/s</li><li>100Mbit/s=(100/8)MB/s=12.5MB/s</li></ul></li></ul></li><li>时延<ul><li>总时延 = 发送时延 + 排队时延 + 传播时延 + 处理时延</li><li>发送时延<ul><li>发送时延 = 数据长度(𝑏𝑖𝑡)/发送速率(𝑏𝑖𝑡/𝑠)</li><li>发送速率受限于计算机网卡</li></ul></li><li>传输时延<ul><li>传播时延 = 传输路径距离/传播速率(𝑏𝑖𝑡/𝑠)</li><li>传播速率受限于传输介质，铜线、光线</li></ul></li><li>排队时延<ul><li>数据包在网络设备中等待被处理的时间</li></ul></li><li>处理时延<ul><li>数据包到达设备或者目的机器被处理所需要的时间</li></ul></li></ul></li><li>往返时间RTT<ul><li>RTT表示的是数据报文在端到端通信中的来回一次的时间</li><li>RTT(Route-Trip Time)是评估网络质量的一项重要指标</li><li>通常使用ping命令查看RTT</li></ul></li></ul><h2 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2.物理层"></a>2.物理层</h2><h3 id="2-1-物理层的作用"><a href="#2-1-物理层的作用" class="headerlink" title="2.1 物理层的作用"></a>2.1 物理层的作用</h3><ul><li>相关设备<ul><li>双绞线</li><li>同轴电缆</li><li>光纤</li><li>红外线</li><li>无线</li><li>激光</li></ul></li><li>传输比特流</li><li>连接不同的物理设备</li><li>物理特性<ul><li>机械特性</li><li>电气特性</li><li>功能特性</li><li>过程特性</li></ul></li></ul><h3 id="2-2-信道的基本概念"><a href="#2-2-信道的基本概念" class="headerlink" title="2.2 信道的基本概念"></a>2.2 信道的基本概念</h3><ul><li><p>一条通信电路包含一个接收信道和一个发送信道</p></li><li><p>信道是往一个方向传送信息的媒体</p></li><li><p>单工信道</p><ul><li>有线电视、无线电收音机等等</li><li>只能一个方向通信，没有反方向反馈的信道</li></ul></li><li><p>半双工信道</p><ul><li>不能双方同时发送，也不能同时接收</li><li>双方都可以发送和接收信息</li></ul></li><li><p>全双工信道</p><ul><li>双方都可以同时发送和接收信息</li></ul></li><li><p>分用-复用技术</p><ul><li>信道利用率并不高？</li><li>分用器</li><li>复用器</li><li>频分复用</li><li>时分复用</li><li>波分复用</li><li>码分复用</li></ul></li></ul><h2 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3.数据链路层"></a>3.数据链路层</h2><h3 id="3-1-数据链路层主要功能"><a href="#3-1-数据链路层主要功能" class="headerlink" title="3.1 数据链路层主要功能"></a>3.1 数据链路层主要功能</h3><ul><li><p>封装成帧</p><ul><li>发送端在网络层的一段数据前后添加特定标记形成“帧”</li><li>“帧”是数据链路层数据的基本单位</li><li>接收端根据前后特定标记识别出“帧”</li><li>物理层才不管你“帧”不“帧”，物理层之作用bit流的传输</li><li>IP数据报–&gt;“帧”的数据[帧首部， “帧”的数据 ，帧尾部]</li><li>帧首部和尾部是特定的控制字符（特定比特流）SOH: 00000001，EOT: 00000100</li></ul></li><li><p>透明传输</p><ul><li>“一种实际存在的事物却又看起来不存在一样”</li><li>“透明”在计算机领域是非常重要的一个术语</li><li>“即是控制字符在帧数据中，但是要当做不存在的去处理”</li><li>数据中也出现了控制字符，对数据中的控制字符进行特殊处理，转义</li><li>“\n”、“\t”等控制字符，编程语言中“\”一般为转义字符，“\” 、“\\”</li></ul></li><li><p>差错监测</p><ul><li>数据链路层负责起“差错监测”的工作</li><li>物理层只管传输比特流，无法控制是否出错</li><li>循环冗余校验码CRC<ul><li>检测数据传输或者保存后可能出现的错误</li><li>一种根据传输或保存的数据而产生固定位数校验码的方法</li><li>生成的数字计算出来并且附加到数据后面</li><li>模“2”除法<ul><li>与算术除法类似，但除法不借位，实际是“异或”操作</li><li>模“2”除法是二进制下的除法</li><li>0 xor 0 = 0，0 xor 1 = 1，1 xor 0 = 1，1 xor 1 = 0</li></ul></li><li>检测流程<ul><li>选定一个用于校验的多项式G(x)，并在数据尾部添加r个0</li><li>将添加r个0后的数据，使用模“2”除法除以多项式的位串</li><li>得到的余数填充在原数据r个0的位置得到可校验的位串</li><li>例子1：使用CRC计算101001的可校验位串<ul><li>计算过程有点难！！！</li></ul></li></ul></li><li>数据链路层只进行数据的检测，不进行纠正，一旦出错会丢弃</li><li>CRC的错误检测能力与位串的阶数r有关</li></ul></li><li>奇偶校验码<ul><li>检测机制：在比特流最后一位加上一位（1或者0），（所有比特流中的1相加）偶数加0，奇数加1 </li><li>缺陷：出错两位，奇偶校验码校测不到错误</li></ul></li></ul></li></ul><h3 id="3-2-最大传输单元MTU"><a href="#3-2-最大传输单元MTU" class="headerlink" title="3.2 最大传输单元MTU"></a>3.2 最大传输单元MTU</h3><ul><li>MTU<ul><li>数据链路层的数据帧也不是无限大的</li><li>最大传输单元MTU(Maximum Transmission Unit)</li><li>数据帧过大或过小都会影响传输的效率</li><li>总时延 = 发送时延 + 排队时延 + 传播时延 + 处理时延</li><li>以太网MTU一般为1500字节</li></ul></li><li>路径MTU<ul><li>路径MTU由链路中MTU的最小值决定</li><li>木桶效应</li></ul></li></ul><h3 id="3-3-以太网协议详解"><a href="#3-3-以太网协议详解" class="headerlink" title="3.3 以太网协议详解"></a>3.3 以太网协议详解</h3><ul><li><p>MAC地址</p><ul><li>MAC地址（Media Access Control Address）直译为媒体存取控制位址，也称为局域网地址（LAN Address）</li><li>每一个设备都拥有唯一的MAC地址</li><li>MAC地址（物理地址、硬件地址）</li><li>MAC地址共48位，使用十六进制表示</li><li>ipconfig/all 查看本机所有MAC地址 ，30-B4-9E-ED-85-CA</li></ul></li><li><p>以太网协议</p><ul><li>以太网是一种应用于数据链路层的协议</li><li>以太网(Ethernet)是一种使用广泛的局域网技术</li><li>使用以太网可以完成相邻设备的数据帧传输</li><li>以太网数据格式<ul><li>类型：0800： IP数据报，0806： ARP请求/应答，8035： RARP请求/应答</li></ul></li></ul><table><thead><tr><th>目的地址（MAC地址) 单位字节</th><th>源地址</th><th>类型</th><th>帧数据</th><th>CRC校验码</th></tr></thead><tbody><tr><td>6</td><td>6</td><td>2</td><td>46-1500</td><td>4</td></tr></tbody></table><ul><li>MAC地址表，路由器持有</li></ul><table><thead><tr><th>MAC地址</th><th>硬件接口</th></tr></thead><tbody><tr><td>31-B4-9E-ED-85-CA</td><td>接口1</td></tr><tr><td>32-B4-9E-ED-85-CB</td><td>接口2</td></tr><tr><td>33-B4-9E-ED-85-CC</td><td>接口4</td></tr></tbody></table><ul><li>A终端通过路由器发送数据到C终端的过程<ul><li>A通过网卡发出数据帧</li><li>数据帧到达路由器，路由器取出前6字节（目的MAC地址）</li><li>路由器匹配MAC地址表，找到对应的网络接口</li><li>路由器往该网络接口发送数据帧</li><li>如果MAC地址表没有匹配成功</li><li>路由器将广播A的数据包到除A以外的端口</li><li>路由器检查MAC地址表，发现没有C的信息</li><li>路由器将收到来自B、 C的回应，并将地址记录</li></ul></li><li>以太网协议只提供相邻物理节点传输，跨设备是无法传输的，需要借助网络层</li></ul></li></ul><h2 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4.网络层"></a>4.网络层</h2><h3 id="4-1-网络层的主要功能"><a href="#4-1-网络层的主要功能" class="headerlink" title="4.1 网络层的主要功能"></a>4.1 网络层的主要功能</h3><ul><li>网络层：数据路由（决定数据在网络的路径）</li><li>数据链路层只能解决相邻物理节点传输</li></ul><h3 id="4-2-IP协议详解"><a href="#4-2-IP协议详解" class="headerlink" title="4.2 IP协议详解"></a>4.2 IP协议详解</h3><ul><li><p>虚拟互联网络</p><ul><li>物理设备通过使用IP协议，屏蔽了物理网络之间的差异</li><li>实际的计算机网络是错综复杂的</li><li>当网络中的主机使用IP协议连接时，则无需关注网络细节</li><li>IP协议使得网络层可以屏蔽底层细节而专注网络层的数据转发</li><li>IP协议使得复杂的实际网络变为一个虚拟互连的网络</li><li>IP协议解决了在虚拟网络中数据报传输路径的问题</li></ul></li><li><p>IP协议</p><ul><li>IP地址<ul><li>MAC地址： 30-B4-9E-ED-85-CA：00110000-11000020-11101101-01000101-11001010<ul><li>48位，16进制表示</li><li>唯一，不可变</li></ul></li><li>P地址： 192.168.11.11：11000000.10101000.00001011.00001011<ul><li>32位，常分成4个8位，一般采用点分十进制表示，共可以表示 2^32 = 4294961296</li><li>IP地址常使用<strong>点分十进制</strong>来表示(0<del>255.0</del>255.0<del>255.0</del>255)，例如：255.255.255.255</li><li>受网络环境影响会发生改变</li></ul></li></ul></li><li>IP报文格式</li></ul><table><thead><tr><th>协议层</th><th>数据格式</th></tr></thead><tbody><tr><td>物理层</td><td>001010101001110110101010101010…10101010101010101010101010101</td></tr><tr><td>数据链路层</td><td>【帧首部 】【“帧”的数据】 【帧尾部】</td></tr><tr><td>网络层</td><td>【IP首部】【 IP数据报的数据】</td></tr></tbody></table><ul><li>IP报文头部各个参数的作用</li></ul><table><thead><tr><th>4位版本</th><th>4位首部长度</th><th>8位服务类型(TOS)</th><th>16位总长度(字节)</th></tr></thead><tbody><tr><td>16位标识</td><td>3位标志</td><td>13位片偏移</td><td></td></tr><tr><td>8位生存时间(TTL)</td><td>8位协议</td><td>16位首部校验和</td><td></td></tr><tr><td>32位源IP地址</td><td></td><td></td><td></td></tr><tr><td>32位目的IP地址</td><td></td><td></td><td></td></tr><tr><td>选项options（若有）</td><td></td><td></td><td></td></tr><tr><td>IP数据</td><td></td><td></td><td></td></tr></tbody></table><ul><li>每一行32位，第六行可选，所以IP报文头部至少占4×5=20个字节</li><li>第一行<ul><li>版本：占4位，指的是IP协议的版本，通信双方的版本必须一致，当前主流版本是4，即IPv4，也有IPv6</li><li>首部位长度：占4位，最大数值为15，表示的是IP首部长度，单位是“32位字”（4个字节），也即是IP首部最大长度为60字节</li><li>8位服务类型(TOS)：TOS包括共8位，包括3 bit的优先权字段（取值可以从000-111所有值），4 bit的TOS子字段和1 bit未用位但必须置0。</li><li>总长度：占16位，最大数值为65535，表示的是IP数据报总长度（IP首部+IP数据），数据链路层MTU,如果IP数据报的数据多余“帧”的数据，需要分片处理</li></ul></li><li>第二行<ul><li>16位标识：IP协议内部使用</li><li>3位标志：标记是否可以分片</li><li>13位片偏移：第几个分片</li></ul></li><li>第三行<ul><li>TTL：占8位，表明IP数据报文在网络中的寿命，每经过一个设备， TTL减1，当TTL=0时，网络设备必须丢弃该报文，避免数据在网络无限传输</li><li>协议：占8位，表明IP数据所携带的具体数据是什么协议的（如： TCP、 UDP等）<ul><li>协议名 ICMP、 IGMP、 IP 、TCP、 UDP、 OSPF …，字段值 1 、2 、4 、6、 17、 89 …</li></ul></li><li>首部校验和：占16位，校验IP首部是否有出错</li></ul></li><li>源IP地址：发送方</li><li>目的IP地址：接收方</li></ul></li></ul><h3 id="4-3-IP协议的转发流程"><a href="#4-3-IP协议的转发流程" class="headerlink" title="4.3 IP协议的转发流程"></a>4.3 IP协议的转发流程</h3><ul><li><p>逐跳(hop-by-hop)</p></li><li><p>路由表</p><ul><li>计算机或者路由器都拥有路由表</li><li>MAC地址表和路由表</li></ul><table><thead><tr><th>MAC地址</th><th>硬件接口</th><th></th><th>目的IP地址</th><th>下一跳IP地址</th></tr></thead><tbody><tr><td>A</td><td>E1</td><td></td><td>IP1</td><td>IP4</td></tr><tr><td>B</td><td>E2</td><td></td><td>IP2</td><td>IP5</td></tr><tr><td>C</td><td>E3</td><td></td><td>IP3</td><td>IP6</td></tr></tbody></table></li><li><p>转发流程：网络层</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnl5pjkrqtj30nm07gjsc.jpg" alt=""></p><ul><li>A将数据报发送给E</li><li>A发出目的地为C的IP数据报， 查询路由表发现下一跳为E</li><li>E查询路由表发现下一跳为F，将数据报发送给F</li><li>F查询路由表发现目的地C直接连接，将数据报发送给C</li></ul></li><li><p>IP数据报每一跳的IP地址始终不变</p></li><li><p>数据帧每一跳的MAC地址都在变化</p></li></ul><h3 id="4-4-ARP协议与RARP协议"><a href="#4-4-ARP协议与RARP协议" class="headerlink" title="4.4 ARP协议与RARP协议"></a>4.4 ARP协议与RARP协议</h3><ul><li>ARP协议<ul><li>ARP(Address Resolution Protocol)地址解析协议，通过IP地址查找MAC地址</li><li>ARP缓存表：[IP地址, MAC地址] 如：192.168.83.254 —00-50-56-e0-33-40</li><li>ARP缓存表缓存了IP地址到硬件地址之间的映射关系</li><li>ARP缓存表是ARP协议和RARP协议运行的关键</li><li>ARP缓存表中的记录并不是永久有效的，有一定的期限</li><li><strong>arp -a</strong> :查看ARP缓存表</li><li>数据报格式，共28个字节，封装在数据链路层里，用于网络层，【类型0806 ，ARP请求/应答 ，PAD】<ul><li>硬件类型，2位</li><li>协议类型 ，2位</li><li>标记 ，24</li><li>发送端 以太网地址 ，6位</li><li>发送端 IP地址 ，4位</li><li>目的端 以太网地址 ，6位</li><li>目的端 IP地址，4位</li></ul></li></ul></li><li>RARP协议<ul><li>RARP(Reverse Address Resolution Protocol)逆地址解析协议</li><li>数据链路层MAC48位地址–》网络层IP32位地址</li></ul></li><li>ARP和RARP的操作对程序员是透明的</li><li>(R)ARP协议是TCP/IP协议栈里面基础的协议</li><li>理解(R)ARP协议有助于理解网络分层的细节</li><li>转发流程：网络层+数据链路层+物理层<ul><li>第一步：A-&gt;E<ul><li>A发出目的地为C的IP数据报， 查询路由表发现下一跳为E</li><li>A将IP数据报交给数据链路层，并告知目的MAC地址是E</li><li>数据链路层填充源MAC地址A和目的MAC地址E</li><li>数据链路层通过物理层将数据发送给E</li></ul></li><li>第二步：E–&gt;F<ul><li>E的数据链路层接收到数据帧， 把帧数据交给网络层</li><li>E查询路由表， 发现下一跳为F</li><li>E把数据报交给数据链路层， 并告知目的MAC地址为F</li><li>E的数据链路层封装数据帧并发送</li></ul></li><li>第三步：F–&gt;C<ul><li>F的数据链路层接收到数据帧， 把帧数据交给网络层</li><li>F查询路由表， 发现下一跳为C</li><li>F把数据报交给数据链路层，并告知目的MAC地址为C</li><li>F的数据链路层封装数据帧并发送</li></ul></li></ul></li></ul><h3 id="4-5-IP地址的分类"><a href="#4-5-IP地址的分类" class="headerlink" title="4.5 IP地址的分类"></a>4.5 IP地址的分类</h3><ul><li><p>IP地址长度为32位，常分成4个8位，常使用点分十进制来表示(0<del>255.0</del>255.0<del>255.0</del>255)，2^32 = 4294961296</p></li><li><p>直接对42亿多个IP地址规划和分配IP地址非常麻烦</p></li><li><p>IP地址=【网络号段+主机号段】=【网络号段+ (子网号段+子网主机号段)】=</p></li><li><p>分类的IP地址</p><ul><li>网络号 <ul><li>网络号的位数直接决定了可以分配的网络数（计算方法=2^网络号位数-特殊网络号数）</li></ul></li><li>主机号<ul><li>主机号的位数则决定了网络中最大的主机数（计算方法=2^主机号位数-特殊主机号数）</li></ul></li></ul><table><thead><tr><th>IP类型</th><th>组成</th><th>最小网络号</th><th>最大网络号</th><th>子网数量(理想)</th><th>最小主机号</th><th>最大主机号</th><th>主机数量</th></tr></thead><tbody><tr><td>A</td><td>8位网络号(0开头）+24位主机号</td><td>0(00000000)</td><td>127(01111111)</td><td>2^7=128</td><td>0.0.0</td><td>255.255.255</td><td>2^24=16,777,216</td></tr><tr><td>B</td><td>16位网络号（10开头）+16位主机号</td><td>128(100000000).0</td><td>191(10111111).255</td><td>2^14(6+8)=16,384</td><td>0.0</td><td>255.255</td><td>2^16=65536</td></tr><tr><td>C</td><td>24位网络号（110开头）+8位主机号</td><td>192(110000000).0.0</td><td>223(11011111).255.255</td><td>2^21(5+8+8)=2,097,252</td><td>0</td><td>255</td><td>2^8=256</td></tr><tr><td>D</td><td>组播地址（1110开头）</td><td>224(111000000).0.0.0</td><td>239(11101111).255.255.255</td><td>2^4=16</td><td></td><td></td><td></td></tr><tr><td>E</td><td>保留以后再用（1111开头）</td><td>240(111110000).0.0.0</td><td>225(11111111).255.255.255</td><td>2^4=16</td><td></td><td></td><td></td></tr></tbody></table><ul><li>特殊的网络号<ul><li>A类地址网络段后7位全1(01111111:127)表示回环地址</li><li>A类地址网络段全0(00000000)表示特殊网络</li><li>B类地址网络段(10000000.00000000:128.0)是不可使用的</li><li>C类地址网络段(192.0.0)是不可使用的</li><li>上表中的A类IP的子网可用数量为：2^7-2，B类:2^14-1，C类：2^21-1</li></ul></li><li>特殊的主机号<ul><li>主机号为全1表示广播地址，向当前网络段所有主机发消息，例如：1.0.0.0</li><li>主机号全0表示当前网络段，不可分配为特定主机，例如：1.255.255.255</li><li>上表中A\B\C的可用主机号数量为：2^24-2、2^16-2、2^8-2</li></ul></li><li>127.0.0.1，通常被称为本地回环地址(Loopback Address)，不属于任何一个有类别地址类。localhost是个域名</li><li>如何判断一个IP属于哪一类IP地址<ul><li>取出首八位：</li><li>A类：(0,127) / 0xxxxxxx，</li><li>B类：[128,19]) / 10xxxxxx，</li><li>C类：[192,223] / 110xxxxx</li></ul></li></ul></li></ul><h3 id="4-6-IP地址的划分子网"><a href="#4-6-IP地址的划分子网" class="headerlink" title="4.6 IP地址的划分子网"></a>4.6 IP地址的划分子网</h3><ul><li>某公司拥有100名员工，每人配备一个计算机，请问该公司应该申请哪种网络段？<ul><li>C类可分配的主机数量为2^8-2=254个</li></ul></li><li>某公司拥有256名员工，每人配备一个计算机，请问该公司应该申请哪种网络段？<ul><li>B类可分配的主机数量为2^16-2=65534个</li><li>造成了很大的地址空间浪费</li></ul></li><li>子网号<ul><li>IP地址=【网络号段+主机号段】=【网络号段+ (子网号段+子网主机号段)】=</li><li>例如一个C类IP 193.10.10.0 = 24位网络号（110开头）+8位主机号 </li><li>主机号段为.0=.00000000</li><li>将主机号段最高位分成 <strong>.0</strong>0000000 和  <strong>.1</strong>0000000 两个子网</li><li><strong>.0</strong>0000000 子网可以表示的主机范围为：(0) <strong>.0</strong>0000000 – (127) <strong>.0</strong>1111111 </li><li><strong>.1</strong>0000000 子网可以表示的主机范围为：(128) <strong>.1</strong>0000000 – (255) <strong>.1</strong>1111111 </li><li>某公司拥有100名员工，每人配备一个计算机，就可以申请C类IP的子网从而可以充分利用IP的数量</li></ul></li><li>子网掩码<ul><li>子网号这么多，有没有办法快速判断某个IP的网络子网掩码号？</li><li>子网掩码由连续的1和连续的0组成</li><li>子网掩码和IP地址一样，都是32位</li><li>某一个子网的子网掩码具备网络号位数个连续的1</li><li>A类IP的子网掩码：255.0.0.0 </li><li>B类IP的子网掩码：255.255.0.0 </li><li>C类IP的子网掩码：255.255.255.0</li><li>划分子网的子网掩码：子网掩码-子网号-主机号<ul><li>例如：193.10.10.0 = 24位网络号（110开头）+1位子网号+7位主机号 <ul><li>子网掩码为：255.255.255.128（24+1个1和7个0组成）</li><li>求 193.10.10.6 这个IP对应的子网号</li><li>第一步IP对应的二进制：            193.10.10.6 – 11000001.00001010.00001010.00000110</li><li>第二步子网掩码对应的二进制：255.255.255.128 – 11111111.11111111.11111111.10000000</li><li>第三步：一二步与运算得到子网号 11000001.00001010.00001010.00000000  – 193.10.10.0</li></ul></li></ul></li></ul></li></ul><h3 id="4-7-无分类地址CIDR"><a href="#4-7-无分类地址CIDR" class="headerlink" title="4.7 无分类地址CIDR"></a>4.7 无分类地址CIDR</h3><ul><li><p>IP地址=【网络号段+主机号段】=【网络号段+ (子网号段+子网主机号段)】</p></li><li><p>子网划分相对复杂所以出现了CIDR</p></li><li><p>无类域内路由选择（Classless Inter-Domain Routing）</p></li><li><p>CIDR中没有A、 B、 C类网络号、和子网划分的概念</p></li><li><p>CIDR将网络前缀相同的IP地址称为一个“CIDR地址块”</p></li><li><p>IP地址=【网络前缀+主机号】</p></li><li><p>网络前缀是任意位数的</p></li><li><p>CIDR采用斜线记法来表示一个IP地址</p><ul><li>193.10.10.129/25==11000001.00001010.00001010.10000001</li><li>25表示网络前缀有25位，主机位有7位</li><li>相比原来子网划分更加灵活</li><li>超网-》子网</li></ul><table><thead><tr><th>CIDR前缀长度</th><th>掩码点分十进制</th><th>地址数</th></tr></thead><tbody><tr><td>/13</td><td>255.248.0.0</td><td>2^19=512K</td></tr><tr><td>/14</td><td>255.252.0.0</td><td>2^18=256K</td></tr><tr><td>/15</td><td>255.254.0.0</td><td>2^17=128K</td></tr><tr><td>/16</td><td>255.255.0.0</td><td>2^16=64K</td></tr><tr><td>/17</td><td>255.255.128.0</td><td>2^15=32K</td></tr><tr><td>/18</td><td>255.255.192.0</td><td>2^14=16K</td></tr><tr><td>/19</td><td>255.255.224.0</td><td>2^13=8K</td></tr></tbody></table></li></ul><h3 id="4-8-网络地址转换NAT技术"><a href="#4-8-网络地址转换NAT技术" class="headerlink" title="4.8 网络地址转换NAT技术"></a>4.8 网络地址转换NAT技术</h3><ul><li><p>IPv4最多只有40+亿个IP地址</p></li><li><p>早期IP地址的不合理规划导致IP号浪费</p></li><li><p>网络拓扑：边缘部分：家庭，多个设备如何复用同一个IP地址的</p></li><li><p>内网地址</p><ul><li>内部机构使用</li><li>避免与外网地址重复</li><li>三类内网地址<ul><li>10.0.0.0~10.255.255.255（支持千万数量级设备）</li><li>172.16.0.0~172.31.255.255（支持百万数量级设备）</li><li>192.168.0.0~192.168.255.255（支持万数量级设备）</li></ul></li></ul></li><li><p>外网地址</p><ul><li>全球范围使用</li><li>全球公网唯一</li></ul></li><li><p>网络地址转换NAT技术</p><ul><li>内网多个设备使用同一个外网IP请求外网的服务，外部怎么知道具体是哪个设备在请求的？</li><li>网络地址转换NAT(Network Address Translation)</li><li>NAT技术用于多个主机通过一个公有IP访问互联网的私有网络中</li><li>NAT减缓了IP地址的消耗，但是增加了网络通信的复杂度</li><li>端口(Port)号</li><li>端口映射表：NA(P)T表</li></ul><table><thead><tr><th>数据传输方向</th><th>旧的地址和端口号</th><th>新的地址与端口号</th></tr></thead><tbody><tr><td>出</td><td>92.168.2.11:6666</td><td>173.21.59.10:16666</td></tr><tr><td>出</td><td>192.168.2.10:7777</td><td>173.21.59.10:17777</td></tr><tr><td>入</td><td>173.21.59.10:16666</td><td>192.168.2.11:6666</td></tr><tr><td>入</td><td>173.21.59.10:17777</td><td>192.168.2.10:7777</td></tr></tbody></table></li></ul><h3 id="4-9-ICMP协议详解"><a href="#4-9-ICMP协议详解" class="headerlink" title="4.9 ICMP协议详解"></a>4.9 ICMP协议详解</h3><ul><li><p>网际控制报文协议（Internet Control Message Protocol）</p></li><li><p>ICMP协议可以报告错误信息或者异常情况，辅助IP协议</p></li><li><p>网络层  【IP首部】-【 IP数据报的数据】</p></li><li><p>【IP首部】协议：占8位，表明IP数据所携带的具体数据是什么协议的（如： TCP、 UDP、ICMP等）</p></li><li><p>ICMP数据封装在【 IP数据报的数据】里面</p></li><li><p>【ICMP报文首部】-【 ICMP报文数据】</p></li><li><p>8位类型+ 8位代码 +16位校验和+ICMP报文数据</p></li><li><p>分类</p><ul><li>差错报告报文 </li><li>询问报文</li></ul><table><thead><tr><th>ICMP报文种类</th><th>类型的值</th><th>报文类型</th><th>具体代码</th></tr></thead><tbody><tr><td>差错报告报文</td><td>3 (终点不可达）</td><td>网络不可达 / 主机不可达</td><td>0/1</td></tr><tr><td></td><td>5 (重定向）</td><td>对网络重定向 / 对主机重定向</td><td>0/1</td></tr><tr><td></td><td>11</td><td>传输超时</td><td>-</td></tr><tr><td></td><td>12</td><td>坏的IP头 / 缺少其他必要参数</td><td>0/1</td></tr><tr><td>询问报文</td><td>0或8</td><td>回送(Echo)请求或应答</td><td>-</td></tr><tr><td></td><td>13或14</td><td>时间戳(Timestamp)请求或应答</td><td>-</td></tr></tbody></table></li><li><p>ICMP报文的应用</p><ul><li>Ping应用<ul><li>询问报文-0或8 - 回送(Echo)请求或应答</li><li>Ping回环地址127.0.0.1,如果失败计算机的协议栈可能出问题，需要重装操作系统</li><li>Ping网关地址，如果失败，网关路由器可能出问题</li><li>Ping远端地址，如果失败，家到ISP服务商之间可能出问题了，需要找服务商解决</li></ul></li><li>Traceroute应用<ul><li>Traceroute可以探测IP数据报在网络中走过的路径</li><li>【IP首部】TTL：占8位，表明IP数据报文在网络中的寿命，每经过一个设备， TTL减1，当TTL=0时，网络设备必须丢弃该报文–ICMP终点不可达差错报文</li><li>命令：Windows：tracert github.com ，Mac：traceroute to github.com <ul><li><strong>221.179.159.20来自北京市北京 移动</strong></li><li><strong>111.24.3.17来自 移动</strong></li><li><strong>223.119.2.21来自香港 移动</strong></li><li><strong>52.93.11.39来自新加坡 亚马逊云</strong></li></ul></li></ul></li></ul></li></ul><h3 id="4-10-网络层的路由概述"><a href="#4-10-网络层的路由概述" class="headerlink" title="4.10 网络层的路由概述"></a>4.10 网络层的路由概述</h3><ul><li><p>路由表问题</p><ul><li>路由表是怎么来的</li><li>下一跳地址是唯一的吗？</li><li>下一跳地址是怎么来的？</li><li>下一跳地址是最佳的吗？</li><li>路由器怎么多，他们是怎么协同工作的？</li><li>需要一个好的算法去解决这些事情</li></ul></li><li><p>路由算法</p><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801171345.jpg" alt=""></p><ul><li>每一条边表示一条网络路径</li><li>每一顶点表示一个网络、路由器或计算机</li><li>路由算法实际上是图论的算法</li><li>网络环境复杂，路由算法要比图论的算法要复杂</li><li>路由算法具备哪些特性<ul><li>算法是正确的、 完整的</li><li>算法在计算上应该尽可能的简单</li><li>算法可以适应网络中的变化</li><li>算法是稳定的和公平的</li></ul></li></ul></li></ul><h3 id="4-11-自治系统-AS"><a href="#4-11-自治系统-AS" class="headerlink" title="4.11 自治系统(AS)"></a>4.11 自治系统(AS)</h3><ul><li>对互联网进行划分<ul><li>互联网的规模是非常大的</li><li>互联网环境是非常复杂的</li><li>自治系统(Autonomous System)</li><li>自治系统内部路由的协议称为：内部网关协议(RIP、 OSPF)</li><li>自治系统外部路由的协议称为：外部网关协议(BGP)</li><li>两个内部网关协议需要通过外部网关协议进行通讯</li></ul></li><li>一个自治系统(AS)是处于一个管理机构下的网络设备群</li><li>AS内部网络自行管理， AS对外提供一个或者多个出（入）口</li></ul><h3 id="4-12-内部网关路由协议之RIP协议"><a href="#4-12-内部网关路由协议之RIP协议" class="headerlink" title="4.12 内部网关路由协议之RIP协议"></a>4.12 内部网关路由协议之RIP协议</h3><ul><li><p>距离矢量(DV)算法</p><ul><li>DV=Distance vector</li><li>每一个节点使用两个向量𝐷𝑖和S𝑖</li><li>𝐷𝑖描述的是当前节点到别的节点的距离</li><li>S𝑖描述的是当前节点到别的节点的下一节点</li><li>每一个节点与相邻的节点交换向量𝐷𝑖和S𝑖的信息</li><li>每一个节点根据交换的信息更新自己的节点信息</li><li>算法实现过程<ul><li>todo</li></ul></li></ul></li><li><p>RIP协议的过程</p><ul><li>RIP(Routing Information Protocol)协议</li><li>RIP协议是使用DV算法的一种路由协议</li><li>RIP协议把网络的跳数(hop)作为DV算法的距离</li><li>RIP协议每隔30s交换一次路由信息</li><li>RIP协议认为跳数&gt;15的路由则为不可达路由</li><li>具体流程<ul><li>路由器初始化路由信息(两个向量𝐷𝑖和S𝑖)</li><li>对相邻路由器X发过来的信息，对信息的内容进行修改（下一跳地址设置为X，所有距离加1）<ul><li>检索本地路由，将信息中新的路由插入到路由表里面</li><li>检索本地路由，对于下一跳为X的，更新为修改后的信息</li><li>检索本地路由，对比相同目的的距离，如果新信息的距离更小，则更新本地路由表</li></ul></li><li>如果3分钟没有收到相邻的路由信息，则把相邻路由设置为不可达(16跳)</li></ul></li></ul></li><li><p>RIP协议的优缺点</p><ul><li>故障信息传递慢</li><li>RIP协议：实现简单，开销很小</li><li>RIP协议：限制了网络的规模</li><li>RIP协议：“坏消息传的慢”，更新收敛时间过长</li></ul></li><li><p>Dijkstra（迪杰斯特拉）算法</p><ul><li>Dijkstra算法是著名的图算法</li><li>Dijkstra算法解决有权图从一个节点到其他节点的最短路径问题</li><li>“以起始点为中心，向外层层扩展”</li><li>最短路径问题<ul><li>初始化两个集合(S, U)（S为只有初始顶点点A的集合， U为其他顶点集合）</li><li>如果U不为空， 对U集合顶点进行距离的排序，并取出距离A最近的一个顶点D<ul><li>将顶点D的纳入S集合</li><li>更新通过顶点D到达U集合所有点的距离（如果距离更小则更新，否则不更新）</li><li>重复2步骤</li></ul></li><li>知道U集合为空，算法完成</li></ul></li></ul></li><li><p>内部网关路由协议之OSPF协议</p><ul><li>链路状态(LS)协议<ul><li>向所有的路由器发送消息</li><li>消息描述该路由器与相邻路由器的链路状态<ul><li>距离、时延、带宽</li></ul></li><li>只有链路状态发生变化时，才发送更新信息</li></ul></li><li>OSPF协议的过程<ul><li>OSPF(Open Shortest Path First：开放最短路径优先)</li><li>OSPF协议的核心是Dijkstra算法</li><li>向所有的路由器发送消息<ul><li>获得网络中的所有信息–&gt; “网络的完整拓扑”</li><li>也称为“链路状态数据库”</li><li>“链路状态数据库”是全网一致的</li><li>Dijkstra（迪杰斯特拉）算法</li></ul></li><li>消息描述该路由器与相邻路由器的链路状态<ul><li>OSPF协议更加客观、更加先进</li></ul></li><li>只有链路状态发生变化时，才发送更新信息<ul><li>减少了数据的交换，更快收敛</li></ul></li><li>路由器接入网络</li><li>路由器向邻居发出问候信息</li><li>与邻居交流链路状态数据库</li><li>广播和更新未知路由</li></ul></li><li>五种消息类型<ul><li>问候消息（Hello）</li><li>链路状态数据库描述信息</li><li>链路状态请求信息</li><li>链路状态更新信息</li><li>链路状态确认信息</li></ul></li></ul><table><thead><tr><th>RIP协议</th><th>OSPF协议</th></tr></thead><tbody><tr><td>从邻居看网络</td><td>整个网络的拓扑</td></tr><tr><td>在路由器之间累加距离</td><td>Dijkstra算法计算最短路径</td></tr><tr><td>频繁、周期更新，收敛很慢</td><td>状态变化更新，收敛很快</td></tr><tr><td>路由间拷贝路由信息</td><td>路由间传递链路状态，自行计算路径</td></tr></tbody></table></li></ul><h3 id="4-13-外部网关路由协议之BGP协议"><a href="#4-13-外部网关路由协议之BGP协议" class="headerlink" title="4.13 外部网关路由协议之BGP协议"></a>4.13 外部网关路由协议之BGP协议</h3><ul><li>BGP(Border Gateway Protocol: 边际网关协议)</li><li>BGP协议是运行在自制系统(AS)之间的一种协议</li><li>互联网的规模很大</li><li>AS内部使用不同的路由协议</li><li>AS之间需要考虑除网络特性以外的一些因素（政治、安全…）</li><li>BGP协议能够找到一条到达目的比较好的路由</li><li>BGP发言人(speaker)<ul><li>BGP并不关心内部网络拓扑</li><li>AS之间通过BGP发言人交流信息</li><li>BGP Speaker可以人为配置策略</li></ul></li></ul><h2 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5.传输层"></a>5.传输层</h2><h3 id="5-1-传输层的主要功能"><a href="#5-1-传输层的主要功能" class="headerlink" title="5.1 传输层的主要功能"></a>5.1 传输层的主要功能</h3><ul><li><p>本质：跨设备的进程与进程的通信</p><ul><li>单机进程间通信方式：共享内存、Unix域套接字</li></ul></li><li><p>端口的概念</p><ul><li>使用端口(Port)来标记不同的网络进程</li><li>端口(Port)使用16比特位表示(0~65535)</li></ul><table><thead><tr><th>FTP</th><th>HTTP</th><th>HTTPS</th><th>DNS</th><th>TELNET</th></tr></thead><tbody><tr><td>21</td><td>80</td><td>443</td><td>53</td><td>23</td></tr></tbody></table></li></ul><h3 id="5-2-UDP协议详解"><a href="#5-2-UDP协议详解" class="headerlink" title="5.2 UDP协议详解"></a>5.2 UDP协议详解</h3><ul><li>UDP是一个非常简单的协议</li><li>UDP(User Datagram Protocol: 用户数据报协议)</li><li>数据报(Datagram)<ul><li>不合并 不拆分</li></ul></li><li>层次位置</li></ul><table><thead><tr><th>协议层</th><th>数据格式</th></tr></thead><tbody><tr><td>物理层</td><td>001010101001110110101010101010…10101010101010101010101010101</td></tr><tr><td>数据链路层</td><td>【帧首部 】【“帧”的数据】 【帧尾部】</td></tr><tr><td>网络层</td><td>【IP首部】【 IP数据报的数据】</td></tr><tr><td>传输层</td><td>【UDP首部】【 UDP数据报的数据(应用层数据)】</td></tr></tbody></table><ul><li>报文结构<ul><li>16位源端口号 + 16位目的端口号</li><li>16位UDP长度 + 16位UDP校验和</li><li>头部报文共8个字节</li><li>UDP数据</li><li>各个报文字段的意义<ul><li>16位源端口号<ul><li>源机器使用的网络进程</li></ul></li><li>16位目的端口号<ul><li>目的机器使用的进程</li></ul></li><li>16位UDP长度<ul><li>udp数据报的长度，最小是8个字节仅包括手部</li></ul></li><li>6位UDP校验和<ul><li>检测数据报在传输过程中是否出错</li></ul></li></ul></li></ul></li><li>UDP的特点<ul><li>UDP是无连接协议</li><li>UDP不能保证可靠的交付数据，“想发就发”，“无法保证数据在网络中是否丢失”</li><li>UDP是面向报文传输的</li><li>UDP没有拥塞控制</li><li>UDP的首部开销很小</li></ul></li></ul><h3 id="5-3-TCP报文详解"><a href="#5-3-TCP报文详解" class="headerlink" title="5.3 TCP报文详解"></a>5.3 TCP报文详解</h3><ul><li>TCP(Transmission Control Protocol: 传输控制协议)</li><li>TCP协议是计算机网络中非常复杂的一个协议</li><li>层次位置</li></ul><table><thead><tr><th>协议层</th><th>数据格式</th></tr></thead><tbody><tr><td>物理层</td><td>001010101001110110101010101010…10101010101010101010101010101</td></tr><tr><td>数据链路层</td><td>【帧首部 】【“帧”的数据】 【帧尾部】</td></tr><tr><td>网络层</td><td>【IP首部】【 IP数据报的数据】</td></tr><tr><td>传输层</td><td>【TCP首部】【 TCP数据报的数据 】</td></tr></tbody></table><ul><li><p>特点</p><ul><li>TCP是面向连接的协议</li><li>TCP的一个连接有两端（点对点通信）</li><li>TCP提供可靠的传输服务</li><li>TCP协议提供全双工的通信</li><li>TCP是面向字节流的协议，合并、分拆</li></ul></li><li><p>报文结构</p><ul><li><p>16位源端口 16位目的端口</p></li><li><p>32位序号</p></li><li><p>32位确认号</p></li><li><p>数据偏移 +保留字段 +TCP标记 +窗口</p></li><li><p>16位校验和 + 16位紧急指针</p></li><li><p>以上行固定20个字节</p></li><li><p>TCP选项（可选）+ 填充</p></li><li><p>各个报文字段的意义</p><ul><li><p>16位源端口号</p><ul><li>源机器使用的网络进程</li></ul></li><li><p>16位目的端口号</p><ul><li>目的机器使用的进程</li></ul></li><li><p>32位序号</p><ul><li>0~2^32-1</li><li>面向字节流，一个字节一个序号</li><li>数据首字节序号</li></ul></li><li><p>32位确认号</p><ul><li>0~2^32-1</li><li>一个字节一个序号</li><li>期望收到数据的首字节序号</li><li>确认号为N：则表示N-1序号的数据都已经收到</li></ul></li><li><p>数据偏移</p><ul><li>占4位： 0~15，单位为： 32位字</li><li>数据偏离首部的距离</li></ul></li><li><p>保留字段</p></li><li><p>TCP标记</p><ul><li>占6位，每位各有不同意义</li><li>TCP三次握手和四次挥手会用到这里的标记为</li></ul><table><thead><tr><th>标记</th><th>含义</th></tr></thead><tbody><tr><td>URG</td><td>Urgent: 紧急位， URG=1，表示紧急数据</td></tr><tr><td>ACK</td><td>Acknowledgement: 确认位， ACK=1，确认号才生效</td></tr><tr><td>PSH</td><td>Push: 推送位， PSH=1，尽快地把数据交付给应用层</td></tr><tr><td>RST</td><td>Reset: 重置位， RST=1，重新建立连接</td></tr><tr><td>SYN</td><td>Synchronization: 同步位， SYN=1 表示连接请求报文</td></tr><tr><td>FIN</td><td>Finish: 终止位， FIN=1 表示释放连接</td></tr></tbody></table></li><li><p>窗口</p><ul><li>占16位： 0~2^16-1</li><li>窗口指明允许对方发送的数据量</li><li>确认号是500，窗口大小1000，则501-1500是可以接收的</li></ul></li><li><p>16位校验和 </p></li><li><p>16位紧急指针</p><ul><li>紧急数据（URG=1）</li><li>指定紧急数据在报文的位置</li></ul></li><li><p>TCP选项（可选）</p><ul><li>最多40字节</li><li>支持未来的拓展</li></ul></li><li><p>填充</p></li></ul></li></ul></li></ul><h3 id="5-4-TCP可靠传输的基本原理"><a href="#5-4-TCP可靠传输的基本原理" class="headerlink" title="5.4 TCP可靠传输的基本原理"></a>5.4 TCP可靠传输的基本原理</h3><ul><li><p>停止等待协议</p><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801171526.jpg" alt=""></p><ul><li>无差错的情况</li><li>出差错的情况<ul><li>发送的消息在路上丢失了</li><li>确认的消息在路上丢失了</li><li>确认的消息很久才到</li><li>超时重传</li><li>超时重传计时器<ul><li>每发送一个消息，都需要设置一个定时器</li></ul></li></ul></li><li>优缺点<ul><li>停止等待协议是最简单的可靠传输协议</li><li>停止等待协议对信道的利用效率不高</li></ul></li></ul></li><li><p>连续ARQ协议</p><ul><li>ARQ(Automatic Repeat reQuest：自动重传请求)</li><li>既然单个发送和确认效率低，可不可以批量发送和确认？</li><li>滑动窗口<ul><li>固定窗口内的字节批量发出，确认几个窗口就向后滑动几个</li></ul></li><li>累计确认<ul><li>只要收到某个消息的确认，那么这个消息之前的消息都确认了</li></ul></li></ul></li></ul><h3 id="5-5-TCP协议的可靠传输"><a href="#5-5-TCP协议的可靠传输" class="headerlink" title="5.5 TCP协议的可靠传输"></a>5.5 TCP协议的可靠传输</h3><ul><li>TCP的可靠传输基于连续ARQ协议</li><li>TCP的滑动窗口以字节为单位</li><li>滑动窗口<ul><li>【已经确认的字节序号】-【窗口】-【不允许发送的字节序号】</li><li>窗口中的字节数据：已发送未确认+可用窗口</li><li>如果没有按顺序收到窗口开始的确认，只收到中间的确认消息，窗口不滑动，执行超时重传</li><li>选择重传<ul><li>选择重传需要指定需要重传的字节</li><li>每一个字节都有唯一的32位序号</li><li>存储在TCP选项（可选）</li><li>最多40个字节，序号展4个字节，最多10个序号，每个序号表示的某段的起止位置，分段传输</li></ul></li></ul></li></ul><h3 id="5-6-TCP协议的流量控制"><a href="#5-6-TCP协议的流量控制" class="headerlink" title="5.6 TCP协议的流量控制"></a>5.6 TCP协议的流量控制</h3><ul><li>流量控制指让发送方发送速率不要太快</li><li>流量控制是使用滑动窗口来实现的</li><li>流量控制流程<ul><li><strong>窗口（rwnd）</strong>指明允许对方发送的数据量，Receiver window</li><li><strong>序号（seq）</strong>用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则TCP用序号对每个字节进行计数。序号是32bit的无符号数，序号到达232－1后又从0开始。sequence</li><li><strong>确认序号（ack）</strong> 是上次已成功收到数据字节序号加1。只有ACK标志位为1时确认序号字段才有效。acknowledgement </li><li><strong>确认位（ACK）</strong>  Acknowledgement: 确认位， ACK=1，确认号才生效</li><li>发送方：发送100字节的数据（seq=1, DATA）</li><li>发送方：发送100字节的数据（seq=101, DATA）</li><li>-&gt;接收方：确认200字节的数据，并告诉对方窗口为300（ACK=1, ack=201, rwnd=300）</li><li>发送方：发送100字节的数据（seq=301, DATA）</li><li>发送方：发送200字节的数据（seq=401, DATA）</li><li>-&gt;接收方：确认300字节的数据，并告诉对方窗口为0（ACK=1, ack=601, rwnd=0）</li><li>-&gt;接收方想再次接受数据需要发送窗口大小给发送方</li><li>如果这个窗口调整请求出错了会产生死锁吗</li><li>坚持定时器来避免死锁的情况</li></ul></li><li>坚持定时器<ul><li>当接收到窗口为0的消息，则启动坚持定时器</li><li>坚持定时器每隔一段时间发送一个窗口探测报文</li></ul></li></ul><h3 id="5-7-TCP协议的拥塞控制"><a href="#5-7-TCP协议的拥塞控制" class="headerlink" title="5.7 TCP协议的拥塞控制"></a>5.7 TCP协议的拥塞控制</h3><ul><li>一条数据链路经过非常多的设备</li><li>数据链路中各个部分都有可能成为网路传输的瓶颈</li><li>拥塞控制 VS 流量控制<ul><li>流量控制考虑点对点的通信量的控制</li><li>拥塞控制考虑整个网络，是全局性的考虑</li></ul></li><li>拥塞判断：报文超时可以认为是拥塞</li><li>拥塞控制算法<ul><li>慢启动算法<ul><li>由小到大逐渐增加发送数据量</li><li>每收到一个报文确认，就加一，例如：1 2 4 8 16 （指数增长）</li><li>慢启动阈值(ssthresh)</li></ul></li><li>拥塞避免算法<ul><li>维护一个拥塞窗口的变量，大于慢启动阈值</li><li>只要网络不拥塞，就试探着拥塞窗口调大，17 18 19</li><li>最大限度的利用管道</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801171603.jpg" alt=""></p><h3 id="5-8-TCP连接的建立"><a href="#5-8-TCP连接的建立" class="headerlink" title="5.8 TCP连接的建立"></a>5.8 TCP连接的建立</h3><ul><li>TCP标记：占6位，每位各有不同意义</li></ul><table><thead><tr><th>标记</th><th>含义</th></tr></thead><tbody><tr><td>SYN</td><td>Synchronization: 同步位， SYN=1 表示连接请求报文</td></tr><tr><td>ACK</td><td>Acknowledgement: 确认位， ACK=1，确认号才生效</td></tr><tr><td>FIN</td><td>Finish: 终止位， FIN=1 表示释放连接</td></tr><tr><td>seq</td><td>sequence，序号（seq）用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。32位</td></tr><tr><td>ack</td><td>acknowledgement，确认序号（ack）是上一次已成功收到的数据字节序号（seq）加1。标识期望发对方发来的序号是它的值，只有ACK标志位为1时确认序号字段才有效。32位</td></tr></tbody></table><ul><li>三次握手建立TCP连接的过程<ul><li>接收方：监听</li><li>发送方：SYN=1, seq=x</li><li>发送方：同步已发送</li><li>接收方：SYN=1, ACK=1, seq=y, ack=x+ 1</li><li>接收方：同步已接受</li><li>发送方：ACK=1, seq=x+ 1, ack=y+1</li><li>发送方：建立连接</li><li>接收方：建立连接</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801171620.jpg" alt=""></p><ul><li>为什么需要三次握手<ul><li>避免已经失效的连接请求报文传送到对方， 引起错误</li><li>避免两次建立连接时多次连接的情况</li><li>第三次握手时，发送方可以检查是否已经发起了第三次，如果已经发起了就忽略其它超时的连接</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801172608.jpg" alt=""></p><ul><li>TCP三次握手 <ul><li>使用TCP协议进行通信的双方必须先建立连接，然后才能开始传输数据。为了确保连接双方可靠性，在双方建立连接时, TCP协议采用了三次握手策略。</li><li>第一次握手:客户端发送带有SYN标志的连接请求报文段，然后进入SYN SEND )状态，等待服务端的确认。</li><li>第二次握手:服务端接收到客户端的SYN报文段后需要发送ACK信息对这个SYN报文段进行确认。同时，还要发送自己的SYN请求信息。服务端会将上述的信息放到一个报文段(SYN+ ACK报文段)中，一并发送给客户端此时服务端将会进入SYN RECV状态。</li><li>第三次握手:客户端接收到服务端的SYN+ ACK报文段后,会想服务端发送ACK确认报文段，这个报文段发送完毕后，客户端和服务端都进入ESTABLISHED状态,完成TCP三次握手。</li></ul></li><li>为什么需要第三次<ul><li>确认双方的收发能力，一共八个能力：自己的收发和对方的收发</li><li>第一次：服务端能知道客户端的发送和自己的接收能力正常</li><li>第二次：客户端能知道服务端的接收（第一次）和发送能力和自己的发送（第一次）能力和接收能力都正常</li><li>第三次：服务端能知道客户端的接收（第二次）和自己的发送（第二次）能力正常</li></ul></li></ul><h3 id="5-9-TCP连接的释放"><a href="#5-9-TCP连接的释放" class="headerlink" title="5.9 TCP连接的释放"></a>5.9 TCP连接的释放</h3><ul><li>TCP标记：占6位，每位各有不同意义</li></ul><table><thead><tr><th>标记</th><th>含义</th></tr></thead><tbody><tr><td>SYN</td><td>Synchronization: 同步位， SYN=1 表示连接请求报文</td></tr><tr><td>ACK</td><td>Acknowledgement: 确认位， ACK=1，确认号才生效</td></tr><tr><td>FIN</td><td>Finish: 终止位， FIN=1 表示释放连接</td></tr><tr><td>seq</td><td>sequence，序号（seq）用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。32位</td></tr><tr><td>ack</td><td>acknowledgement，确认序号（ack）是上一次已成功收到的数据字节序号（seq）加1。标识期望发对方发来的序号是它的值，只有ACK标志位为1时确认序号字段才有效。32位</td></tr></tbody></table><ul><li><p>四次释放</p><ul><li>四次释放TCP连接的过程<ul><li>发送方：FIN=1,seq=u</li><li>发送方：释放等待状态（FIN-WAIT-1）</li><li>接收方：ACK=1,seq=v,ack=u+1</li><li>发送方：释放等待状态（FIN-WAIT-2）</li><li>接收方：关闭等待状态（CLOSE-WAIT）</li><li>接收方：因为是被动关闭可能有未发出的数据需要继续完成发送</li><li>接收方：FIN=1,ACK=1,seq=w,ack=u+1</li><li>接收方：最后确认状态（LAST-ACK）</li><li>发送方：ACK=1,seq=u+1,ack=w+1</li><li>发送方：等待计时（TIME-WAIT）</li><li>接收方：关闭状态</li><li>发送方：关闭状态</li></ul></li><li>等待计时器<ul><li>等待时间：2MSL<ul><li>MSL(Max Segment Lifetime): 最长报文段寿命</li><li>MSL建议设置为2分钟</li></ul></li><li>为什么需要等待2MSL？<ul><li>确保发送方的ACK可以到达接收方</li><li>最后一个报文没有确认</li><li>接收方在 2MSL时间内没有收到，则接收方会重发确认释放请求数据报</li><li>确保当前连接的所有报文都已经过期</li></ul></li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801171643.jpg" alt=""></p><h3 id="5-10-套接字与套接字编程"><a href="#5-10-套接字与套接字编程" class="headerlink" title="5.10 套接字与套接字编程"></a>5.10 套接字与套接字编程</h3><ul><li>使用端口(Port)来标记不同的网络进程，端口(Port)使用16比特位表示(0~65535)</li><li>网络套接字<ul><li>𝐼𝑃: 𝑃𝑜𝑟𝑡—— 套接字</li><li>套接字(Socket)是抽象概念，表示TCP连接的一端</li><li>通过套接字可以进行数据发送或接收</li><li>TCP连接由两个套接字组成：TCP={ 𝑆𝑜𝑐𝑘𝑒𝑡1: 𝑆𝑜𝑐𝑘𝑒𝑡2}= { {𝐼𝑃: 𝑃𝑜𝑟𝑡}  { 𝐼𝑃: 𝑃𝑜𝑟𝑡} }</li><li>客户端 –TCP连接—服务端</li><li>服务端<ul><li>创建套接字</li><li>绑定(bind)套接字</li><li>监听(listen)套接字</li><li>接收&amp;处理信息</li></ul></li><li>客户端<ul><li>创建套接字</li><li>连接套接字</li><li>发送信息</li></ul></li></ul></li><li>客户端-服务端编程<ul><li>Java、Pathy</li></ul></li><li>网络套接字 VS 域套接字<ul><li>域套接字：域套接字文件，不会经过tcp/ip协议簇，单机跨进程建议使用</li><li>网络套接字：单机和跨机都会在tcp/ip协议栈走一圈，单机跨进程不建议使用</li></ul></li></ul><h2 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6.应用层"></a>6.应用层</h2><h3 id="6-1-应用层概述"><a href="#6-1-应用层概述" class="headerlink" title="6.1 应用层概述"></a>6.1 应用层概述</h3><ul><li>传输层以及以下的层提供完整的通信服务</li><li>应用层是面向用户的一层</li><li>已有的应用层软件 ，面向传输层的编程</li><li>UDP<ul><li>多媒体信息分发<ul><li>视频 语音 实时信息</li></ul></li></ul></li><li>TCP<ul><li>可靠消息传输<ul><li>金融交易 可靠通讯 MQ</li></ul></li></ul></li></ul><h3 id="6-2-应用层主要功能"><a href="#6-2-应用层主要功能" class="headerlink" title="6.2 应用层主要功能"></a>6.2 应用层主要功能</h3><ul><li>应用进程的报文类型（请求报文、应答报文）</li><li>报文的语法、格式</li><li>应用进程发送数据的时机、规则</li><li>定义应用间通讯的规则</li></ul><h3 id="6-3-DNS服务详解"><a href="#6-3-DNS服务详解" class="headerlink" title="6.3 DNS服务详解"></a>6.3 DNS服务详解</h3><ul><li><p>DNS（Domain Name System: 域名系统）</p><ul><li>域：Domain，网络端，自治域</li><li>名：Name，IP地址</li></ul></li><li><p>主机的进程：Web 服务、网络存储服务、远程调用服务、邮件服务</p></li><li><p>IP地址+端口：14.215.177.39:80 、14.18.245.164:25、161.23.37.215:8810</p></li><li><p>DNS的功能</p><ul><li>使用域名帮助记忆<ul><li>点分十进制转为人容易记忆的单词</li><li>域名–&gt;DNS服务–&gt;IP</li></ul></li></ul></li><li><p>域名详解</p><ul><li><p>域名由点、字母和数字组成</p></li><li><p>点分割不同的域</p></li><li><p>域名可以分为顶级域、二级域、三级域</p><ul><li>例如 ：www(三级域).taobao(二级域).com(顶级域)</li><li>顶级域<ul><li>国家<ul><li>cn：中国</li><li>us：美国</li><li>uk：英国</li><li>ca：加拿大</li></ul></li><li>通用<ul><li>com：公司</li><li>net：网络服务机构</li><li>gov：政府机构</li><li>org：其它组织机构</li></ul></li></ul></li><li>二级域<ul><li>qq、taobao、baidu、alibaba、aliyun、amazon、google、facebook</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801171724.jpg" alt=""></p></li></ul></li><li><p>域名服务器</p><ul><li>一般由国际或者机构搭建</li><li>查询过程<ul><li>本地查询，有就返回</li><li>没有去查根域名服务器</li><li>根域名服务器告诉去查哪一个顶级域名服务器</li><li>顶级域名服务器查到后告诉哪一个域名服务器</li><li>如果域名服务器没找到会返回根域名服务器再次查找</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801171736.jpg" alt=""></p></li><li><p>DNS域名解析</p><ul><li>通常我们访问一一个网站，使用的是主机名或者域名来进行访问的。因为相对于IP地址(一组纯数字)，域名更容易让人记住。但TCP/IP协议使用的是IP地址进行访问的，所以必须有个机制或服务把域名转换成IP地址。DNS服务就是用来解决这个问题的，它提供域名到IP地址之间的解析服务。</li><li>用户输入-浏览器-域名查询-获取IP-发送请求-web服务器-回传网页内容-浏览器-渲染-用户</li></ul></li><li><p>DNS解析流程</p><ul><li>就近原则</li><li>本机host文件</li><li>本机dns服务</li><li>远程13台根域名服务</li><li>转发模式</li></ul></li></ul><h3 id="6-4-DHCP协议详解"><a href="#6-4-DHCP协议详解" class="headerlink" title="6.4 DHCP协议详解"></a>6.4 DHCP协议详解</h3><ul><li>DHCP是什么<ul><li>DHCP(Dynamic Host Configuration Protocol: 动态主机设置协议)</li><li>DHCP是一个局域网协议</li><li>DHCP是应用UDP协议的应用层协议</li></ul></li><li>DHCP的功能<ul><li>即插即用联网<ul><li>临时IP，内网地址，转换为外网</li><li>租期，租期到了会回收</li></ul></li></ul></li><li>DHCP的工作机制<ul><li>DHCP服务器监听默认端口： 67</li><li>主机使用UDP协议广播DHCP发现报文</li><li>DHCP服务器发出DHCP提供报文</li><li>主机向DHCP服务器发出DHCP请求报文</li><li>DHCP服务器回应并提供IP地址</li></ul></li></ul><h3 id="6-5-HTTP协议详解"><a href="#6-5-HTTP协议详解" class="headerlink" title="6.5 HTTP协议详解"></a>6.5 HTTP协议详解</h3><ul><li><p>HTTP是什么</p><ul><li>HTTP(HyperText Transfer Protocol: 超文本传输协议)</li><li>超文本： “超级文本”， “带超链接文本”，“富文本”</li><li>http(s)://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;，例如：<a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a></li><li>HTTP协议是可靠的数据传输协议<ul><li>Web内容：文本 图片 文件 动图 音频 视频</li></ul></li><li>C/S: 客户端—&gt;HTTP协议—-&gt; 服务端</li></ul></li><li><p>Web服务器</p><ul><li><p>硬件部分 ：阿里云虚拟服务器、迷你计算机</p></li><li><p>软件部分：Apache、Nginx</p><ul><li><em>Nginx</em> (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。</li><li>Apache(音译为阿帕奇)是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。</li></ul></li><li><p>工作机制</p><ul><li>接受客户端连接 </li><li>接收请求报文 </li><li>处理请求</li><li>访问Web资源</li><li>构造应答</li><li>发送应答</li></ul></li><li><p>HTTP请求方法</p><ul><li>GET：获取指定的服务端资源</li><li>POST：提交数据到服务端</li><li>DELETE：删除指定的服务端资源</li><li>UPDATE：更新指定的服务端资源</li><li>PUT</li><li>OPTIONS</li><li>PATCH</li><li>HEAD</li><li>TRACE</li></ul></li><li><p>HTTP指定资源</p><ul><li>在地址中指定</li><li>在请求数据中指定</li></ul></li><li><p>HTTP请求报文</p><ul><li>[请求方法] [请求地址] [HTTP版本]</li><li>[请求头]</li><li>[请求内容]</li></ul></li><li><p>HTTP应答报文</p><ul><li>[HTTP版本] [状态码] [状态解释]</li><li>[应答头]</li><li>[应答内容]</li></ul></li><li><p>HTTP应答状态码</p><ul><li>状态码 含义<br>200<del>299 成功状态码<br>300</del>399 重定向状态码<br>400<del>499 客户端错误状态码<br>500</del>599 服务端错误状态码</li></ul><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>200~299</td><td>成功状态码</td></tr><tr><td>300~399</td><td>重定向状态码</td></tr><tr><td>400~499</td><td>客户端错误状态码</td></tr><tr><td>500~599</td><td>服务端错误状态码</td></tr></tbody></table></li></ul></li></ul><h3 id="6-6-HTTP工作的结构"><a href="#6-6-HTTP工作的结构" class="headerlink" title="6.6 HTTP工作的结构"></a>6.6 HTTP工作的结构</h3><ul><li>Web代理<ul><li>正向代理</li><li>反向代理</li></ul></li><li>CDN<ul><li>CDN（Content Delivery Network：内容分发网络）</li><li>多媒体内容</li></ul></li><li>爬虫<ul><li>增加网络拥塞</li><li>损耗服务器资源</li></ul></li></ul><h3 id="6-7-HTTPS协议详解"><a href="#6-7-HTTPS协议详解" class="headerlink" title="6.7 HTTPS协议详解"></a>6.7 HTTPS协议详解</h3><ul><li>敏感信息：账号密码、个人信息、账户金额、交易信息、敏感信息…</li><li>HTTPS(Secure)是安全的HTTP协议</li><li>http(s)://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;，端口：443</li><li>工作机制<ul><li>加密模型<ul><li>对称加密：使用秘钥加密 ，使用秘钥解密，两个秘钥“一致”</li><li>非对称加密：两个秘钥“不一致”<ul><li>A、 B是拥有一定数学关系的一组秘钥</li><li>私钥：私钥自己使用，不对外公开</li><li>公钥：公钥给大家使用，对外公开</li></ul></li></ul></li><li>数字证书<ul><li>数字证书是可信任组织颁发给特定对象的认证</li><li>证书格式、版本号</li><li>证书序列号</li><li>签名算法</li><li>有效期</li><li>对象名称</li><li>对象公开秘钥</li></ul></li><li>SSL<ul><li>SSL(Secure Sockets Layer: 安全套接层)</li><li>SSL位于传输层与应用层之间</li><li>数据安全和数据完整</li><li>对传输层数据进行加密后传输</li></ul></li><li>HTTPS工作流程<ul><li>443端口的TCP连接</li><li>SSL安全参数握手</li><li>客户端发送数据</li><li>服务端发送数据</li></ul></li><li>SSL安全参数握手过程<ul><li>客户端：随机数1、协议版本、加密算法</li><li>服务端：确定加密算法、数字证书、随机数2</li><li>客户端：<ul><li>确认证书是否有效</li><li>生成随机数3</li><li>使用服务器的公钥加密随机数3</li></ul></li><li>根据随机数1、 2、 3和相同的算法生成对称秘钥</li><li>双方使用对称秘钥进行加密通信</li><li>综合使用对称加密、非对称加密</li><li>双方分别生成秘钥，没有经过传输</li></ul></li></ul></li></ul><h3 id="6-8-输入域名按下回车键的过程有哪些"><a href="#6-8-输入域名按下回车键的过程有哪些" class="headerlink" title="6.8 输入域名按下回车键的过程有哪些"></a>6.8 输入域名按下回车键的过程有哪些</h3><ul><li>域名解析<ul><li>客户端生成DNS的UDP报文</li><li>查询本机配置的DNS IP地址</li><li>UDP报文经本机协议栈发送出去</li><li>网络层 数据链路层 物理层</li><li>请求顶级域名服务器</li></ul></li><li>建立连接<ul><li>TCP三次握手</li><li>SSL握手 交换秘钥</li></ul></li><li>HTTP通信<ul><li>GET</li></ul></li><li>释放连接<ul><li>四次挥手 结束连接</li></ul></li></ul><h2 id="7-HTTP协议详解"><a href="#7-HTTP协议详解" class="headerlink" title="7.HTTP协议详解"></a>7.HTTP协议详解</h2><h3 id="7-1-浏览器背后的故事"><a href="#7-1-浏览器背后的故事" class="headerlink" title="7.1 浏览器背后的故事"></a>7.1 浏览器背后的故事</h3><ul><li><a href="http://www.basedev.cn/">http://www.basedev.cn/</a></li><li>用户输入-浏览器-域名查询-获取IP-发送请求-web服务器-回传网页内容-浏览器-渲染-用户</li><li>HTTP<ul><li>超文本传输协议(HTTP)是一-种通信协议， 它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器</li><li>HTTP是- -个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展</li></ul></li><li>Web与HTTP<ul><li>WEB是一种基于超文本和HTTP的、 全球性的、动态交互的、跨平台的分布式图形信息系统</li><li>建立在Internet上的一种网络服务，为浏览者在Internet.上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超，级链接将Internet上的信息节点组织成一个互为关联的网状结构</li></ul></li></ul><h3 id="7-2-HTTP协议的前世今生"><a href="#7-2-HTTP协议的前世今生" class="headerlink" title="7.2 HTTP协议的前世今生"></a>7.2 HTTP协议的前世今生</h3><ul><li>1990年10月万维网之父TimBerners-Lee最早提出了HTTP协议</li><li>1991年HTTP0.9诞生</li><li>1996年5月HTTP1.0发布</li><li>1997年1月HTTP1.1发布</li><li>2015年5月HTTP2.0提出</li><li>HTTP3.0，QUIC协议</li></ul><h3 id="7-3-透过TCP-IP看HTTP"><a href="#7-3-透过TCP-IP看HTTP" class="headerlink" title="7.3 透过TCP/IP看HTTP"></a>7.3 透过TCP/IP看HTTP</h3><ul><li>TCP/IP协议族<ul><li>TCP/IP协议其实是一-系列与互联网相关联的协议集 合起来的总称</li><li>分层管理是TCP/IP协议的重要特征</li></ul></li><li>应用层<ul><li>应用层一般是我们编写的应用程序,决定了向用户提供的应用服务。应用层可以通过系统调用与传输层进行通信。如: FTP、DNS、HTTP等。</li></ul></li><li>传输层<ul><li>传输层通过系统调用向应用层提供处于网络连接中的两台计算机之间的数据传输功能。</li><li>在传输层有两个性质不同的协议:TCP和UDP。</li></ul></li><li>网络层<ul><li>网络层用来处理在网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径(传输路线)到达对方计算机，并把数据包传输给对方。</li></ul></li><li>链路层.<ul><li>链路层用来处理连接网络的硬件部分，包括控制操作系统、硬件设备驱动、NIC (Network Interface Card,网络适配器)以及光纤等物理可见部分。硬件. 上的范畴均在链路层的作用范围之内。</li></ul></li><li>数据包的封装过程</li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnqxpcdpezj30ig0aqzm8.jpg" alt=""></p><ul><li>http数据传输过程<ul><li>发送端发送数据时，数据会从上层传输到下层，且每经过一层都会被打上该层的头部信息。</li><li>接收端接收数据时，数据会从下层传输到上层，传输前会把下层的头部信息删除.</li></ul></li></ul><h2 id="8-计算机网络实践"><a href="#8-计算机网络实践" class="headerlink" title="8.计算机网络实践"></a>8.计算机网络实践</h2><h3 id="8-1-网络嗅探工具"><a href="#8-1-网络嗅探工具" class="headerlink" title="8.1 网络嗅探工具"></a>8.1 网络嗅探工具</h3><ul><li><p>实现流程</p><ul><li>搭建服务基本框架</li><li>Python操作字节序列<ul><li>字节序<ul><li>255 = 00000000,11111111</li><li>大端字节序：高位在前，00000000,11111111<ul><li>网络，易读</li></ul></li><li>小端字节序：高位在后，11111111, 00000000<ul><li>主机，CPU对小端字节序处理效率高效</li></ul></li><li>计算机电路先处理低位字节效率比较高</li><li>人类习惯读写大端字节序</li></ul></li><li>格式字符<ul><li>%s 字符串，%d 整数，%x 十六进制，%f 浮点数</li><li>格式字符 C++/Python类型 标准大小（字节）</li><li>B-unsigned char/整数 1</li><li>H unsigned short/整数 2</li><li>L unsigned long/整数 4</li><li>s char[]/字节串 </li></ul></li></ul></li><li>实现IP报文解析器</li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801173224.jpg" alt=""></p><ul><li>实现UDP报文解析器</li><li>实现TCP报文解析器</li></ul></li><li><p>网卡模式</p><ul><li>混杂模式 <ul><li>接受所有经过网卡设备的数据 </li></ul></li><li>非混杂模式<ul><li>只接受目的地址指向自己的数据</li></ul></li></ul></li><li><p>IP报文解析</p></li><li><p>TCP报文解析</p></li><li><p>UDP报文解析</p></li><li><p>从零到一实现HTTP服务器开发</p></li></ul><h2 id="9-关于我"><a href="#9-关于我" class="headerlink" title="9.关于我"></a>9.关于我</h2><p>一个专注基础知识的十二线小码农，本着 <strong>基础，体系，实践，分享</strong> 的学习理念，在自我提升的同时分享自己的心得体会，不断完善，周而复始。</p><p><a href="http://basedev.cn/" target="_blank" rel="noopener">个人网站 basedev.cn</a>  </p><p><a href="https://github.com/jaydroid1024" target="_blank" rel="noopener">Github</a></p><p>BaseDev系列只整理点到为止的知识纲领，不求甚解；欲知其所以然者还得回归书本且付诸实践</p><h2 id="10-参考"><a href="#10-参考" class="headerlink" title="10.参考"></a>10.参考</h2><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?sid=20-h5Url-0&amp;courseId=478&amp;lagoufrom=noapp&amp;sharetype=wx_friend#/content" target="_blank" rel="noopener">重学操作系统 | 拉钩教育</a></p><p><a href="https://coding.imooc.com/class/package/355.html" target="_blank" rel="noopener">编程必备基础 | 慕课网</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> HTTP/HTTPS </tag>
            
            <tag> OSI七层模型 </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筑基系列-Android基础知识小抄版（更新中...）</title>
      <link href="2021/07/31/android-base/"/>
      <url>2021/07/31/android-base/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/post_banner_jay.png" alt=""></p><p>Android各版本对应JDK版本</p><table><thead><tr><th align="left">平台版本</th><th align="left">版本名称</th><th align="left">SDK版本</th><th align="left">市场占有率</th><th align="left">JDK版本</th></tr></thead><tbody><tr><td align="left">2.3.3 - 2.3.7</td><td align="left">Gingerbread</td><td align="left">10</td><td align="left">0.4%</td><td align="left">6</td></tr><tr><td align="left">4.0.3 - 4.0.4</td><td align="left">Ice Cream Sandwich</td><td align="left">15</td><td align="left">0.5%</td><td align="left">6</td></tr><tr><td align="left">4.1.x</td><td align="left">Jelly Bean</td><td align="left">16</td><td align="left">2.0%</td><td align="left">6</td></tr><tr><td align="left">4.2.x</td><td align="left">Jelly Bean</td><td align="left">17</td><td align="left">3.0%</td><td align="left">6</td></tr><tr><td align="left">4.3</td><td align="left">Jelly Bean</td><td align="left">18</td><td align="left">0.9%</td><td align="left">6</td></tr><tr><td align="left">4.4</td><td align="left">KitKat</td><td align="left">19</td><td align="left">13.4%</td><td align="left">6</td></tr><tr><td align="left">5.0</td><td align="left">Lollipop</td><td align="left">21</td><td align="left">6.1%</td><td align="left">7</td></tr><tr><td align="left">5.1</td><td align="left">Lollipop</td><td align="left">22</td><td align="left">20.2%</td><td align="left">7</td></tr><tr><td align="left">6.0</td><td align="left">Marshmallow</td><td align="left">23</td><td align="left">29.7%</td><td align="left">7</td></tr><tr><td align="left">7.0</td><td align="left">Nougat</td><td align="left">24</td><td align="left">19.3%</td><td align="left">7</td></tr><tr><td align="left">7.1</td><td align="left">Nougat</td><td align="left">25</td><td align="left">4.0%</td><td align="left">7</td></tr><tr><td align="left">8.0</td><td align="left">Oreo</td><td align="left">26</td><td align="left">0.5%</td><td align="left">8</td></tr></tbody></table><p>Android Gradle 插件版本所需的 Gradle 版本。为了获得最佳性能，您应使用 Gradle 和插件这两者的最新版本。</p><table><thead><tr><th align="left">插件版本</th><th align="left">所需的 Gradle 版本</th></tr></thead><tbody><tr><td align="left">1.0.0 - 1.1.3</td><td align="left">2.2.1 - 2.3</td></tr><tr><td align="left">1.2.0 - 1.3.1</td><td align="left">2.2.1 - 2.9</td></tr><tr><td align="left">1.5.0</td><td align="left">2.2.1 - 2.13</td></tr><tr><td align="left">2.0.0 - 2.1.2</td><td align="left">2.10 - 2.13</td></tr><tr><td align="left">2.1.3 - 2.2.3</td><td align="left">2.14.1 - 3.5</td></tr><tr><td align="left">2.3.0+</td><td align="left">3.3+</td></tr><tr><td align="left">3.0.0+</td><td align="left">4.1+</td></tr><tr><td align="left">3.1.0+</td><td align="left">4.4+</td></tr><tr><td align="left">3.2.0 - 3.2.1</td><td align="left">4.6+</td></tr><tr><td align="left">3.3.0 - 3.3.3</td><td align="left">4.10.1+</td></tr><tr><td align="left">3.4.0 - 3.4.3</td><td align="left">5.1.1+</td></tr><tr><td align="left">3.5.0 - 3.5.4</td><td align="left">5.4.1+</td></tr><tr><td align="left">3.6.0 - 3.6.4</td><td align="left">5.6.4+</td></tr><tr><td align="left">4.0.0+</td><td align="left">6.1.1+</td></tr><tr><td align="left">4.1.0+</td><td align="left">6.5+</td></tr><tr><td align="left">4.2.0+</td><td align="left">6.7.1+</td></tr><tr><td align="left">7.0</td><td align="left">7.0+</td></tr></tbody></table><h1 id="1-Java"><a href="#1-Java" class="headerlink" title="1.Java"></a>1.Java</h1><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h3 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK/JRE/JVM"></a>JDK/JRE/JVM</h3><p>JDK：Java Develpment Kit java 开发工具<br>JRE：Java Runtime Environment java运行时环境<br>JVM：java Virtual Machine java 虚拟机</p><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210805234734.png" alt=""></p><h3 id="和equals比较"><a href="#和equals比较" class="headerlink" title="==和equals比较"></a>==和equals比较</h3><p><strong>==：</strong>对比的是栈中的值，基本数据类型是<strong>变量值</strong>，引用类型是堆中内存<strong>对象的地址</strong></p><p><strong>equals：</strong>object中默认也是采用==比较，通常会重写，比如字符串类重写了equals比较的是每个char的值是否相等</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Object.java</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//String.java</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String anotherString <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>anObject<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//test equals and ==</span>String str1 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>String str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String str3 <span class="token operator">=</span> str2<span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span></code></pre><h3 id="hashCode与equals"><a href="#hashCode与equals" class="headerlink" title="hashCode与equals"></a>hashCode与equals</h3><p>hashCode 是通过将对象的内部地址转换为整数来实现的，此内存地址不能通过 java sdk 获得，必须作为native方法实现。native 源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//object.java</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//view src/share/native/java/lang/Object.c</span><span class="token keyword">static</span> JNINativeMethod methods<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span><span class="token string">"hashCode"</span><span class="token punctuation">,</span>    <span class="token string">"()I"</span><span class="token punctuation">,</span>                    <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_IHashCode<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"wait"</span><span class="token punctuation">,</span>        <span class="token string">"(J)V"</span><span class="token punctuation">,</span>                   <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_MonitorWait<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"notify"</span><span class="token punctuation">,</span>      <span class="token string">"()V"</span><span class="token punctuation">,</span>                    <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_MonitorNotify<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"notifyAll"</span><span class="token punctuation">,</span>   <span class="token string">"()V"</span><span class="token punctuation">,</span>                    <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_MonitorNotifyAll<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"clone"</span><span class="token punctuation">,</span>       <span class="token string">"()Ljava/lang/Object;"</span><span class="token punctuation">,</span>   <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_Clone<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>JNIEXPORT <span class="token keyword">void</span> JNICALL <span class="token function">Java_java_lang_Object_registerNatives</span><span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>env<span class="token punctuation">,</span> jclass cls<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">RegisterNatives</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> cls<span class="token punctuation">,</span> methods<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>methods<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>methods<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>JNIEXPORT jclass JNICALL <span class="token function">Java_java_lang_Object_getClass</span><span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>env<span class="token punctuation">,</span> jobject this<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>this <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">JNU_ThrowNullPointerException</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">GetObjectClass</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> this<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>此源包含 getClass() 方法的实现。 hashCode 被定义为一个函数指针 JVM_IHashCode</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//view src/share/vm/prims/jvm.cpp</span><span class="token comment" spellcheck="true">// java.lang.Object ///////////////////////////////////////////////</span><span class="token function">JVM_ENTRY</span><span class="token punctuation">(</span>jint<span class="token punctuation">,</span> <span class="token function">JVM_IHashCode</span><span class="token punctuation">(</span>JNIEnv<span class="token operator">*</span> env<span class="token punctuation">,</span> jobject handle<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token function">JVMWrapper</span><span class="token punctuation">(</span><span class="token string">"JVM_IHashCode"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// as implemented in the classic virtual machine; return 0 if object is NULL</span>  <span class="token keyword">return</span> handle <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> ObjectSynchronizer<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">FastHashCode</span> <span class="token punctuation">(</span>THREAD<span class="token punctuation">,</span> JNIHandles<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">resolve_non_null</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>JVM_END</code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//view src/share/vm/runtime/synchronizer.cpp</span>intptr_t ObjectSynchronizer<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">FastHashCode</span> <span class="token punctuation">(</span>Thread <span class="token operator">*</span> Self<span class="token punctuation">,</span> oop obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mark<span class="token operator">-></span><span class="token function">is_neutral</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    hash <span class="token operator">=</span> mark<span class="token operator">-></span><span class="token function">hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// this is a normal header</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hash<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token comment" spellcheck="true">// if it has hash, just return it</span>      <span class="token keyword">return</span> hash<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    hash <span class="token operator">=</span> <span class="token function">get_next_hash</span><span class="token punctuation">(</span>Self<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// allocate a new hash code</span>    temp <span class="token operator">=</span> mark<span class="token operator">-></span><span class="token function">copy_set_hash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// merge the hash code into header</span>    <span class="token comment" spellcheck="true">// use (machine word version) atomic operation to install the hash</span>    test <span class="token operator">=</span> <span class="token punctuation">(</span>markOop<span class="token punctuation">)</span> Atomic<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">cmpxchg_ptr</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> obj<span class="token operator">-></span><span class="token function">mark_addr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mark<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>test <span class="token operator">==</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> hash<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// If atomic operation failed, we must inflate the header</span>    <span class="token comment" spellcheck="true">// into heavy weight monitor. We could add more code here</span>    <span class="token comment" spellcheck="true">// for fast path, but it does not worth the complexity.</span>  <span class="token punctuation">}</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  monitor <span class="token operator">=</span> ObjectSynchronizer<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">inflate</span><span class="token punctuation">(</span>Self<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Load displaced header and check it has hash code</span>  mark <span class="token operator">=</span> monitor<span class="token operator">-></span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>mark<span class="token operator">-></span><span class="token function">is_neutral</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"invariant"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>  hash <span class="token operator">=</span> mark<span class="token operator">-></span><span class="token function">hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>hash <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    hash <span class="token operator">=</span> <span class="token function">get_next_hash</span><span class="token punctuation">(</span>Self<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    temp <span class="token operator">=</span> mark<span class="token operator">-></span><span class="token function">copy_set_hash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// merge hash code into header</span>    <span class="token function">assert</span> <span class="token punctuation">(</span>temp<span class="token operator">-></span><span class="token function">is_neutral</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"invariant"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    test <span class="token operator">=</span> <span class="token punctuation">(</span>markOop<span class="token punctuation">)</span> Atomic<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">cmpxchg_ptr</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> monitor<span class="token punctuation">,</span> mark<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>test <span class="token operator">!=</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// The only update to the header in the monitor (outside GC)</span>      <span class="token comment" spellcheck="true">// is install the hash code. If someone add new usage of</span>      <span class="token comment" spellcheck="true">// displaced header, please update this code</span>      hash <span class="token operator">=</span> test<span class="token operator">-></span><span class="token function">hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">assert</span> <span class="token punctuation">(</span>test<span class="token operator">-></span><span class="token function">is_neutral</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"invariant"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>      <span class="token function">assert</span> <span class="token punctuation">(</span>hash <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"Trivial unexpected object/monitor header usage."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// We finally get the hash</span>  <span class="token keyword">return</span> hash<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token keyword">static</span> <span class="token keyword">inline</span> intptr_t <span class="token function">get_next_hash</span><span class="token punctuation">(</span>Thread <span class="token operator">*</span> Self<span class="token punctuation">,</span> oop obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  intptr_t value <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>hashCode <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// This form uses an unguarded global Park-Miller RNG,</span>     <span class="token comment" spellcheck="true">// so it's possible for two threads to race and generate the same RNG.</span>     <span class="token comment" spellcheck="true">// On MP system we'll have lots of RW access to a global, so the</span>     <span class="token comment" spellcheck="true">// mechanism induces lots of coherency traffic.</span>     value <span class="token operator">=</span> os<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>hashCode <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// This variation has the property of being stable (idempotent)</span>     <span class="token comment" spellcheck="true">// between STW operations.  This can be useful in some of the 1-0</span>     <span class="token comment" spellcheck="true">// synchronization schemes.</span>     intptr_t addrBits <span class="token operator">=</span> <span class="token function">intptr_t</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">3</span> <span class="token punctuation">;</span>     value <span class="token operator">=</span> addrBits <span class="token operator">^</span> <span class="token punctuation">(</span>addrBits <span class="token operator">>></span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">^</span> GVars<span class="token punctuation">.</span>stwRandom <span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>hashCode <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     value <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// for sensitivity testing</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>hashCode <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     value <span class="token operator">=</span> <span class="token operator">++</span>GVars<span class="token punctuation">.</span>hcSequence <span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>hashCode <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     value <span class="token operator">=</span> <span class="token function">intptr_t</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// Marsaglia's xor-shift scheme with thread-specific state</span>     <span class="token comment" spellcheck="true">// This is probably the best overall implementation -- we'll</span>     <span class="token comment" spellcheck="true">// likely make this the default in future releases.</span>     <span class="token keyword">unsigned</span> t <span class="token operator">=</span> Self<span class="token operator">-></span>_hashStateX <span class="token punctuation">;</span>     t <span class="token operator">^</span><span class="token operator">=</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;&lt;</span> <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>     Self<span class="token operator">-></span>_hashStateX <span class="token operator">=</span> Self<span class="token operator">-></span>_hashStateY <span class="token punctuation">;</span>     Self<span class="token operator">-></span>_hashStateY <span class="token operator">=</span> Self<span class="token operator">-></span>_hashStateZ <span class="token punctuation">;</span>     Self<span class="token operator">-></span>_hashStateZ <span class="token operator">=</span> Self<span class="token operator">-></span>_hashStateW <span class="token punctuation">;</span>     <span class="token keyword">unsigned</span> v <span class="token operator">=</span> Self<span class="token operator">-></span>_hashStateW <span class="token punctuation">;</span>     v <span class="token operator">=</span> <span class="token punctuation">(</span>v <span class="token operator">^</span> <span class="token punctuation">(</span>v <span class="token operator">>></span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>t <span class="token operator">^</span> <span class="token punctuation">(</span>t <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>     Self<span class="token operator">-></span>_hashStateW <span class="token operator">=</span> v <span class="token punctuation">;</span>     value <span class="token operator">=</span> v <span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>JVM_IHashCode 在 jvm.cpp 中定义。请参阅从第 504 行开始的代码。这又调用了在synchronizer.cpp 中定义的 ObjectSynchronizer::FastHashCode。请参阅第 576 行的 FastHashCode 和第 530 行的 get_next_hash 的实现。</p><p><strong>HashCode 的作用是：</strong></p><ul><li>hashCode 的作用是返回对象的哈希码值。支持此方法是为了有利于散列表，这个哈希码的作用是确定该对象在哈希表中的索引位</li></ul><p>置。</p><ul><li><p>hashCode的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p><p><strong>HashCode 的一般约定是：</strong></p></li><li><p>在 Java 应用程序的执行过程中，只要在同一个对象上多次调用它,hashCode方法必须始终如一地返回相同的整数，前提是未修改对象的  equals比较中使用的信息。该整数不需要从应用程序的一次执行到同一应用程序的另一次执行保持一致。</p></li><li><p>如果两个对象根据 equals()方法相等，则对这两个对象中的每一个调用  hashCode}方法必须产生相同的整数结果。</p></li><li><p>如果两个对象根据 equals()方法不相等，则调用 hashCode}方法这两个对象中的每一个都必须产生不同的整数结果。</p></li><li><p>两个对象有相同的hashcode值，它们也不一定是相等的</p></li><li><p>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</p></li><li><p>为不相等的对象生成不同的整数结果可能会提高哈希表的性能。</p></li><li><p>在合理可行的情况下，类 Object定义的 hashCode 方法确实为不同的对象返回不同的整数。</p></li></ul><h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><ul><li>修饰类：表示类不可被继承</li><li>修饰方法：表示方法不可被子类覆盖，但是可以重载</li><li>修饰变量：表示变量一旦被赋值就不可以更改它的值<ul><li>如果final修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。</li><li>如果final修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。</li><li>如果final修饰的是局部变量,系统不会为局部变量进行初始化，局部变量必须由程序员显示初始化。因此使用final修饰局部变量时，即可以在定义时指定默认值也可以在后面的代码中对final变量赋初值。</li><li>如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；</li><li>如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。但是引用的值是可变的</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Person p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//合法</span>p<span class="token operator">=</span>null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//非法</span></code></pre><p><strong>为什么局部内部类和匿名内部类只能访问局部final变量？</strong></p><p>首先需要知道的一点是: 内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。<br>这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有没有人再引用它时，才会死亡)。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的”copy”。这样就好像延长了局部变量的生命周期将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？就将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量和方法的局部变量的一致性。这实际上也是一种妥协。使得局部变量与内部类内建立的拷贝保持一致。</p><h3 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h3><ul><li>String是final修饰的，不可变，每次操作都会产生新的String对象</li><li>StringBuffer和StringBuilder都是在原对象上操作</li><li>StringBuffer是线程安全的，StringBuilder线程不安全的</li><li>StringBuffer方法都是synchronized修饰的</li><li>性能：StringBuilder &gt; StringBuffer &gt; String</li><li>场景：经常需要改变字符串内容时使用后面两个</li><li>优先使用StringBuilder，多线程使用共享变量时使用StringBuffer</li></ul><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><ul><li>重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</li><li>重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。</li></ul><h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul><li>抽象类可以存在普通成员函数，而接口中只能存在public abstract 方法。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的。</li><li>抽象类只能继承一个，接口可以实现多个。</li><li>接口的设计目的，是对类的行为进行约束（更准确的说是一种“有”约束，因为接口不能规定类不可以有什么行为），也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制。</li><li>而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行为的实现方式一致时（A的非真子集，记为B），可以让这些类都派生于一个抽象类。在这个抽象类中实现了B，避免让所有的子类来实现B，这就达到了代码复用的目的。而A减B的部分，留给各个子类自己实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来（否则当调用到A-B时，无法执行）。</li><li>抽象类是对类本质的抽象，表达的是 is a 的关系，比如： BMW is a Car 。抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。</li><li>而接口是对行为的抽象，表达的是 like a 的关系。比如： Bird like a Aircraft （像飞行器一样可以飞），但其本质上 is a Bird 。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。</li><li>使用场景：当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</li><li>抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度</li></ul><h2 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h2><h3 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h3><ul><li>List：有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用Iterator取出所有元素，在逐一遍历，还可以使用get(int index)获取指定下标的元素</li><li>Set：无序，不可重复，最多允许有一个Null元素对象，取元素时只能用Iterator接口取得所有元素，在逐一遍历各个元素</li></ul><h4 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h4><ul><li><p><a href="http://androidos.net.cn/android/9.0.0_r8/xref/libcore/ojluni/src/main/java/java/util/ArrayList.java" target="_blank" rel="noopener">ArrayList 源码</a></p></li><li><p><a href="http://androidos.net.cn/android/9.0.0_r8/xref/libcore/ojluni/src/main/java/java/util/LinkedList.java" target="_blank" rel="noopener">LinkedList 源码</a></p></li><li><p>⾸先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的</p></li><li><p>由于底层数据结构不同，他们所适⽤的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加，查询、添加、删除的时间复杂度不同</p></li><li><p>另外ArrayList和LinkedList都实现了List接⼝，但是LinkedList还额外实现了Deque接⼝，所以LinkedList还可以当做队列来使⽤</p></li><li><p>ArrayList：基于动态数组，连续内存存储，适合下标访问（随机访问），扩容机制：因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动（往后复制一份，插入新元素），使用尾插法并指定初始容量可以极大提升性能、甚至超过linkedList（需要创建大量的node对象）</p></li><li><p>LinkedList：基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询：需要逐一遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过get(i)取得某一元素时都需要对list重新进行遍历，性能消耗极大。另外不要试图使用indexOf等返回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结果为空时会遍历整个列表。</p></li></ul><h3 id="HashMap和HashTable有什么区别？其底层实现是什么？"><a href="#HashMap和HashTable有什么区别？其底层实现是什么？" class="headerlink" title="HashMap和HashTable有什么区别？其底层实现是什么？"></a>HashMap和HashTable有什么区别？其底层实现是什么？</h3><ul><li>HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；</li><li>HashMap允许key和value为null，而HashTable不允许</li><li>jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在</li><li>计算key的hash值，二次hash然后对数组长度取模，对应到数组下标，</li><li>如果没有产生hash冲突(下标位置没有元素)，则直接创建Node存入数组，</li><li>如果产生hash冲突，先进行equal比较，相同则取代该元素，不同，则判断链表高度插入链表，链</li><li>表高度达到8，并且数组长度到64则转变为红黑树，长度低于6则将红黑树转回链表</li></ul><h4 id="HashMap的Put⽅法的⼤体流程"><a href="#HashMap的Put⽅法的⼤体流程" class="headerlink" title="HashMap的Put⽅法的⼤体流程"></a>HashMap的Put⽅法的⼤体流程</h4><ul><li><a href="http://androidos.net.cn/android/9.0.0_r8/xref/libcore/ojluni/src/main/java/java/util/HashMap.java" target="_blank" rel="noopener">HashMap 源码1.8</a></li><li><a href="http://androidos.net.cn/android/7.1.1_r28/xref/libcore/ojluni/src/main/java/java/util/HashMap.java" target="_blank" rel="noopener">HashMap 源码1.7</a></li><li>根据Key通过哈希算法与与运算得出数组下标</li><li>如果数组下标位置元素为空，则将key和value封装为Entry对象（JDK1.7中是Entry对象，JDK1.8中是Node对象）并放⼊该位置</li><li>如果数组下标位置元素不为空，则要分情况讨论<ul><li>如果是JDK1.7，则先判断是否需要扩容，如果要扩容就进⾏扩容，如果不⽤扩容就⽣成Entry对象，并使⽤头插法添加到当前位置的链表中</li><li>如果是JDK1.8，则会先判断当前位置上的Node的类型，看是红⿊树Node，还是链表Node<ul><li>如果是红⿊树Node，则将key和value封装为⼀个红⿊树节点并添加到红⿊树中去，在这个过程中会判断红⿊树中是否存在当前key，如果存在则更新value</li><li>如果此位置上的Node对象是链表节点，则将key和value封装为⼀个链表Node并通过尾插法插⼊到链表的最后位置去，因为是尾插法，所以需要遍历链表，在遍历链表的过程中会判断是否存在当前key，如果存在则更新value，当遍历完链表后，将新链表Node插⼊到链表中，插⼊到链表后，会看当前链表的节点个数，如果⼤于等于8，那么则会将该链表转成红⿊树</li><li>将key和value封装为Node插⼊到链表或红⿊树中后，再判断是否需要进⾏扩容，如果需要就<br>扩容，如果不需要就结束PUT⽅法</li></ul></li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="Java-多线程"><a href="#Java-多线程" class="headerlink" title="Java 多线程"></a>Java 多线程</h2><h4 id="ThreadLocal-简述"><a href="#ThreadLocal-简述" class="headerlink" title="ThreadLocal 简述"></a>ThreadLocal 简述</h4><ul><li><p><a href="http://androidos.net.cn/android/9.0.0_r8/xref/libcore/ojluni/src/main/java/java/lang/ThreadLocal.java" target="_blank" rel="noopener">ThreadLocal 源码</a></p></li><li><p>ThreadLocal是Java中所提供的线程本地存储机制，可以利⽤该机制将数据缓存在某个线程内部，该线<br>程可以在任意时刻、任意⽅法中获取缓存的数据</p></li><li><p>ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象（注意不是ThreadLocal对象）中都存在⼀个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓<br>存的值</p></li><li><p>如果在线程池中使⽤ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使⽤完之后，应该要把设置的key，value，也就是Entry对象进⾏回收，但线程池中的线程不会回收，⽽线程对象是通过强引⽤指向ThreadLocalMap，ThreadLocalMap也是通过强引⽤指向Entry对象，线程不被回收，Entry对象也就不会被回收，从⽽出现内存泄漏，解决办法是，在使⽤了ThreadLocal对象之后，⼿动调⽤ThreadLocal的remove⽅法，⼿动清楚Entry对象</p></li><li><p>ThreadLocal经典的应⽤场景就是连接管理（⼀个线程持有⼀个连接，该连接对象可以在不同的⽅法之间进⾏传递，线程之间不共享同⼀个连接）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 组件化-组件aar化实战</title>
      <link href="2021/07/31/android-component-aar/"/>
      <url>2021/07/31/android-component-aar/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/post_banner_jay.png" alt=""></p><h1 id="Android-组件化-组件aar化实战"><a href="#Android-组件化-组件aar化实战" class="headerlink" title="Android 组件化-组件aar化实战"></a>Android 组件化-组件aar化实战</h1><p>[toc]</p><h2 id="1-Gradle-推送插件-Maven-Publish-Plugin"><a href="#1-Gradle-推送插件-Maven-Publish-Plugin" class="headerlink" title="1.Gradle 推送插件|Maven Publish Plugin"></a>1.Gradle 推送插件|Maven Publish Plugin</h2><p>Maven Publish 插件提供将构建产物发布到<a href="http://maven.apache.org/" target="_blank" rel="noopener">Apache Maven</a>存储库的功能。发布到 Maven 存储库的模块可以被 Maven、Gradle和其他了解 Maven 存储库格式的工具使用。</p><h3 id="1-1-插件任务-Tasks"><a href="#1-1-插件任务-Tasks" class="headerlink" title="1.1 插件任务|Tasks"></a>1.1 插件任务|Tasks</h3><ul><li><p><code>generatePomFileFor*PubName*Publication</code>—<a href="https://docs.gradle.org/7.0/dsl/org.gradle.api.publish.maven.tasks.GenerateMavenPom.html" target="_blank" rel="noopener">生成MavenPom</a></p><p>为名为<em>PubName</em>的发布创建 POM 文件，填充已知元数据，例如项目名称、项目版本和依赖项。POM 文件的默认位置是<em>build/publications/$pubName/pom-default.xml</em>。</p></li><li><p><code>publish*PubName*PublicationTo*RepoName*Repository</code>— <a href="https://docs.gradle.org/7.0/dsl/org.gradle.api.publish.maven.tasks.PublishToMavenRepository.html" target="_blank" rel="noopener">PublishToMavenRepository</a></p><p>将<em>PubName</em>发布发布到名为<em>RepoName</em>的存储库。如果您有一个没有明确名称的存储库定义，<em>RepoName</em>将是“Maven”。</p></li><li><p><code>publish*PubName*PublicationToMavenLocal</code>— <a href="https://docs.gradle.org/7.0/javadoc/org/gradle/api/publish/maven/tasks/PublishToMavenLocal.html" target="_blank" rel="noopener">PublishToMavenLocal</a></p><p>将<em>PubName*发布与发布的 POM 文件和其他元数据一起复制到本地 Maven 缓存——通常是</em>$USER_HOME/.m2/repository*。</p></li><li><p><code>publish</code></p><p><em>取决于</em>：所有任务<code>publish*PubName*PublicationTo*RepoName*Repository</code>将所有定义的发布发布到所有定义的存储库的聚合任务。它<em>不</em>包括复制出版物本地Maven缓存。</p></li><li><p><code>publishToMavenLocal</code></p><p><em>取决于</em>：所有任务<code>publish*PubName*PublicationToMavenLocal</code>将所有定义的发布复制到本地 Maven 缓存，包括它们的元数据（POM 文件等）。</p></li></ul><pre class=" language-groovy"><code class="language-groovy"><span class="token comment" spellcheck="true">//生成MavenPom</span>generateMetadataFileForDebugPublicationgenerateMetadataFileForReleasePublicationgeneratePomFileForDebugPublication generatePomFileForReleasePublication<span class="token comment" spellcheck="true">//PublishToMavenRepository</span>publishpublishAllPublicationsToMavenRepositorypublishDebugPublicationToMavenRepositorypublishReleasePublicationToMavenRepository<span class="token comment" spellcheck="true">//PublishToMavenLocal</span>publishToMavenLocalpublishDebugPublicationToMavenLocalpublishReleasePublicationToMavenLocal<span class="token comment" spellcheck="true">//如果你的项目使用了gralde wrapper组件的话请使用以下命令</span><span class="token operator">.</span><span class="token operator">/</span>gradlew task <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token operator">.</span><span class="token operator">/</span>gradlew task <span class="token punctuation">:</span>lib<span class="token operator">-</span>net<span class="token punctuation">:</span>publishToMavenLocal</code></pre><h3 id="1-2-构建产物-Publications"><a href="#1-2-构建产物-Publications" class="headerlink" title="1.2 构建产物|Publications"></a>1.2 构建产物|Publications</h3><p>您可以在 Maven 出版物中配置四项主要内容：</p><ul><li>A <a href="https://docs.gradle.org/7.0/userguide/dependency_management_terminology.html#sub:terminology_component" target="_blank" rel="noopener">component</a>  例如 一个 java module、Android library module<ul><li>通过该方法指定 MavenPublication.from(org.gradle.api.component.SoftwareComponent)</li></ul></li><li><a href="https://docs.gradle.org/7.0/userguide/publishing_customization.html#sec:publishing_custom_artifacts_to_maven" target="_blank" rel="noopener">Custom artifacts</a> <ul><li>自定义构建产物通过这个方法 <a href="https://docs.gradle.org/7.0/dsl/org.gradle.api.publish.maven.MavenPublication.html#org.gradle.api.publish.maven.MavenPublication:artifact(java.lang.Object)" target="_blank" rel="noopener">MavenPublication.artifact(java.lang.Object)</a> method.</li></ul></li><li>标准的元数据 <ul><li>例如 artifactId、groupId、version.</li></ul></li><li>POM file 的其它配置<ul><li>通过这个方法设置 MavenPublication.pom(org.gradle.api.Action)</li></ul></li></ul><h3 id="1-3-仓库-Repositories"><a href="#1-3-仓库-Repositories" class="headerlink" title="1.3 仓库|Repositories"></a>1.3 仓库|Repositories</h3><p>插件提供 MavenArtifactRepository 类型的存储库</p><p>定义发布存储库：</p><pre class=" language-groovy"><code class="language-groovy">publishing <span class="token punctuation">{</span>   repositories <span class="token punctuation">{</span>      maven <span class="token punctuation">{</span>          url <span class="token string">"url"</span>          credentials <span class="token punctuation">{</span>              username <span class="token operator">=</span> <span class="token string">'name'</span>              password <span class="token operator">=</span> <span class="token string">'pwd'</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Snapshot and release repositories</p><pre class=" language-groovy"><code class="language-groovy">publishing <span class="token punctuation">{</span>    repositories <span class="token punctuation">{</span>        maven <span class="token punctuation">{</span>            <span class="token keyword">def</span> releasesRepoUrl <span class="token operator">=</span> layout<span class="token operator">.</span>buildDirectory<span class="token operator">.</span><span class="token function">dir</span><span class="token punctuation">(</span><span class="token string">'repos/releases'</span><span class="token punctuation">)</span>            <span class="token keyword">def</span> snapshotsRepoUrl <span class="token operator">=</span> layout<span class="token operator">.</span>buildDirectory<span class="token operator">.</span><span class="token function">dir</span><span class="token punctuation">(</span><span class="token string">'repos/snapshots'</span><span class="token punctuation">)</span>            url <span class="token operator">=</span> version<span class="token operator">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">'SNAPSHOT'</span><span class="token punctuation">)</span> <span class="token operator">?</span> snapshotsRepoUrl <span class="token punctuation">:</span> releasesRepoUrl        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="1-4-完整示例"><a href="#1-4-完整示例" class="headerlink" title="1.4 完整示例"></a>1.4 完整示例</h3><p>以下示例演示了如何签署和发布包含源代码、Javadoc 和自定义 POM 的 Java 库：</p><p>build.gradle</p><pre class=" language-groovy"><code class="language-groovy">plugins <span class="token punctuation">{</span>    id <span class="token string">'java-library'</span>    id <span class="token string">'maven-publish'</span>    id <span class="token string">'signing'</span><span class="token punctuation">}</span>group <span class="token operator">=</span> <span class="token string">'com.example'</span>version <span class="token operator">=</span> <span class="token string">'1.0'</span>java <span class="token punctuation">{</span>    <span class="token function">withJavadocJar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">withSourcesJar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>publishing <span class="token punctuation">{</span>    publications <span class="token punctuation">{</span>        <span class="token function">mavenJava</span><span class="token punctuation">(</span>MavenPublication<span class="token punctuation">)</span> <span class="token punctuation">{</span>            artifactId <span class="token operator">=</span> <span class="token string">'my-library'</span>            from components<span class="token operator">.</span>java            versionMapping <span class="token punctuation">{</span>                <span class="token function">usage</span><span class="token punctuation">(</span><span class="token string">'java-api'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">fromResolutionOf</span><span class="token punctuation">(</span><span class="token string">'runtimeClasspath'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>                <span class="token function">usage</span><span class="token punctuation">(</span><span class="token string">'java-runtime'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">fromResolutionResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            pom <span class="token punctuation">{</span>                name <span class="token operator">=</span> <span class="token string">'My Library'</span>                description <span class="token operator">=</span> <span class="token string">'A concise description of my library'</span>                url <span class="token operator">=</span> <span class="token string">'http://www.example.com/library'</span>                properties <span class="token operator">=</span> <span class="token punctuation">[</span>                    myProp<span class="token punctuation">:</span> <span class="token string">"value"</span><span class="token punctuation">,</span>                    <span class="token string">"prop.with.dots"</span><span class="token punctuation">:</span> <span class="token string">"anotherValue"</span>                <span class="token punctuation">]</span>                licenses <span class="token punctuation">{</span>                    license <span class="token punctuation">{</span>                        name <span class="token operator">=</span> <span class="token string">'The Apache License, Version 2.0'</span>                        url <span class="token operator">=</span> <span class="token string">'http://www.apache.org/licenses/LICENSE-2.0.txt'</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                developers <span class="token punctuation">{</span>                    developer <span class="token punctuation">{</span>                        id <span class="token operator">=</span> <span class="token string">'johnd'</span>                        name <span class="token operator">=</span> <span class="token string">'John Doe'</span>                        email <span class="token operator">=</span> <span class="token string">'john.doe@example.com'</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                scm <span class="token punctuation">{</span>                    connection <span class="token operator">=</span> <span class="token string">'scm:git:git://example.com/my-library.git'</span>                    developerConnection <span class="token operator">=</span> <span class="token string">'scm:git:ssh://example.com/my-library.git'</span>                    url <span class="token operator">=</span> <span class="token string">'http://example.com/my-library/'</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    repositories <span class="token punctuation">{</span>        maven <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// change URLs to point to your repos, e.g. http://my.org/repo</span>            <span class="token keyword">def</span> releasesRepoUrl <span class="token operator">=</span> layout<span class="token operator">.</span>buildDirectory<span class="token operator">.</span><span class="token function">dir</span><span class="token punctuation">(</span><span class="token string">'repos/releases'</span><span class="token punctuation">)</span>            <span class="token keyword">def</span> snapshotsRepoUrl <span class="token operator">=</span> layout<span class="token operator">.</span>buildDirectory<span class="token operator">.</span><span class="token function">dir</span><span class="token punctuation">(</span><span class="token string">'repos/snapshots'</span><span class="token punctuation">)</span>            url <span class="token operator">=</span> version<span class="token operator">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">'SNAPSHOT'</span><span class="token punctuation">)</span> <span class="token operator">?</span> snapshotsRepoUrl <span class="token punctuation">:</span> releasesRepoUrl            credentials <span class="token punctuation">{</span>              username <span class="token operator">=</span> <span class="token string">'name'</span>              password <span class="token operator">=</span> <span class="token string">'pwd'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>signing <span class="token punctuation">{</span>    sign publishing<span class="token operator">.</span>publications<span class="token operator">.</span>mavenJava<span class="token punctuation">}</span>javadoc <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>JavaVersion<span class="token operator">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token function">isJava9Compatible</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        options<span class="token operator">.</span><span class="token function">addBooleanOption</span><span class="token punctuation">(</span><span class="token string">'html5'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上配置的结果是将发布以下工件：</p><ul><li>POM文件: <code>my-library-1.0.pom</code></li><li>主要的 JAR 工件 : <code>my-library-1.0.jar</code></li><li>已显式配置的源代码: <code>my-library-1.0-sources.jar</code></li><li>已显式配置的 Javadoc： <code>my-library-1.0-javadoc.jar</code></li></ul><p>签名插件用于为每个工件生成签名文件。此外，将为所有工件和签名文件生成校验和文件。</p><h3 id="1-5-Android-中-使用-Maven-发布插件"><a href="#1-5-Android-中-使用-Maven-发布插件" class="headerlink" title="1.5 Android 中 使用 Maven 发布插件"></a>1.5 Android 中 使用 Maven 发布插件</h3><p>Android Gradle 插件 3.6.0 及更高版本包括对 <a href="https://docs.gradle.org/current/userguide/publishing_maven.html" target="_blank" rel="noopener">Maven Publish Gradle 插件的支持</a>，它允许您将构建工件发布到 Apache Maven 存储库。Android Gradle 插件 为您的应用程序或库模块中的每个构建变体工件创建一个 <a href="https://docs.gradle.org/current/userguide/dependency_management_terminology.html#sub:terminology_component" target="_blank" rel="noopener"><em>组件</em></a>，您可以使用它来自定义 <a href="https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:publications" target="_blank" rel="noopener"><em>发布</em></a> 到 Maven 存储库。</p><p>Android 插件创建的组件取决于模块是使用应用程序插件还是库插件，如下表所述。</p><table><thead><tr><th align="left">Android Gradle 插件</th><th align="left">出版神器</th><th align="left">组件名称</th></tr></thead><tbody><tr><td align="left"><code>com.android.library</code></td><td align="left">AAR</td><td align="left"><code>components.variant</code></td></tr><tr><td align="left"><code>com.android.application</code></td><td align="left">APK 的 ZIP，以及可用的 ProGuard 或 R8 映射文件</td><td align="left"><code>components.variant_apk</code></td></tr><tr><td align="left"><code>com.android.application</code></td><td align="left">一个 Android 应用程序包 (AAB)</td><td align="left"><code>components.variant_aab</code></td></tr></tbody></table><h3 id="1-6-Android-版示例"><a href="#1-6-Android-版示例" class="headerlink" title="1.6 Android 版示例"></a>1.6 Android 版示例</h3><pre class=" language-groovy"><code class="language-groovy"><span class="token comment" spellcheck="true">// Because the components are created only during the afterEvaluate phase, you must</span><span class="token comment" spellcheck="true">// configure your publications using the afterEvaluate() lifecycle method.</span>afterEvaluate <span class="token punctuation">{</span>    publishing <span class="token punctuation">{</span>        publications <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Creates a Maven publication called "release".</span>            <span class="token function">release</span><span class="token punctuation">(</span>MavenPublication<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Applies the component for the release build variant.</span>                from components<span class="token operator">.</span>release                <span class="token comment" spellcheck="true">// You can then customize attributes of the publication as shown below.</span>                groupId <span class="token operator">=</span> GROUP                artifactId <span class="token operator">=</span> ARTIFACT_ID                version <span class="token operator">=</span> VERSION            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Creates a Maven publication called “debug”.</span>            <span class="token function">debug</span><span class="token punctuation">(</span>MavenPublication<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Applies the component for the debug build variant.</span>                from components<span class="token operator">.</span>debug                groupId <span class="token operator">=</span> GROUP                artifactId <span class="token operator">=</span> ARTIFACT_ID <span class="token operator">+</span> <span class="token string">"-debug"</span>                version <span class="token operator">=</span> VERSION            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        repositories <span class="token punctuation">{</span>            maven <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// change URLs to point to your repos, e.g. http://my.org/repo</span>                url <span class="token operator">=</span> URL                credentials <span class="token punctuation">{</span>                    username USER_NAME                    password PASSWORD                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="1-7-Android-自定义POM文件版示例"><a href="#1-7-Android-自定义POM文件版示例" class="headerlink" title="1.7 Android 自定义POM文件版示例"></a>1.7 Android 自定义POM文件版示例</h3><pre class=" language-groovy"><code class="language-groovy">apply plugin<span class="token punctuation">:</span> <span class="token string">'maven-publish'</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--------${project.name}：Maven Publish Gradle--------"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//release 和 snapshot 的控制开关</span><span class="token keyword">def</span> isUploadToRelease <span class="token operator">=</span> rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'isUploadToRelease'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//远程Maven仓库的URL Release</span><span class="token keyword">def</span> MAVEN_REPO_RELEASE_URL <span class="token operator">=</span> rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'mavenRepoUrlRelease'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//远程Maven仓库的URL snapshots</span><span class="token keyword">def</span> MAVEN_REPO_SNAPSHOTS_URL <span class="token operator">=</span> rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'mavenRepoUrlSnapshots'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//远程Maven仓库用户名</span><span class="token keyword">def</span> USER_NAME <span class="token operator">=</span> rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'userName'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//远程Maven仓库密码</span><span class="token keyword">def</span> PASSWORD <span class="token operator">=</span> rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 唯一标识 每个组件都要指定</span><span class="token keyword">def</span> GROUP <span class="token operator">=</span> group<span class="token operator">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// todo 默认为项目名称</span><span class="token keyword">def</span> ARTIFACT_ID <span class="token operator">=</span> project<span class="token operator">.</span>name<span class="token comment" spellcheck="true">// 版本号 每个组件都要指定</span><span class="token keyword">def</span> VERSION <span class="token operator">=</span> version<span class="token operator">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//远程Maven仓库的URL</span><span class="token keyword">def</span> URL <span class="token operator">=</span> isUploadToRelease <span class="token operator">?</span> MAVEN_REPO_RELEASE_URL <span class="token punctuation">:</span> MAVEN_REPO_SNAPSHOTS_URL<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"dependencies_path: $GROUP:$ARTIFACT_ID:$VERSION"</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MAVEN_REPO_RELEASE_URL: $MAVEN_REPO_RELEASE_URL"</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MAVEN_REPO_SNAPSHOTS_URL: $MAVEN_REPO_SNAPSHOTS_URL"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//https://docs.gradle.org/7.0/userguide/publishing_maven.html#publishing_maven</span><span class="token comment" spellcheck="true">//https://developer.android.com/studio/build/maven-publish-plugin</span><span class="token comment" spellcheck="true">// Because the components are created only during the afterEvaluate phase, you must</span><span class="token comment" spellcheck="true">// configure your publications using the afterEvaluate() lifecycle method.</span>task <span class="token function">sourceJar</span><span class="token punctuation">(</span>type<span class="token punctuation">:</span> Jar<span class="token punctuation">)</span> <span class="token punctuation">{</span>    from android<span class="token operator">.</span>sourceSets<span class="token operator">.</span>main<span class="token operator">.</span>java<span class="token operator">.</span>srcDirs    classifier <span class="token string">"sources"</span><span class="token punctuation">}</span>afterEvaluate <span class="token punctuation">{</span>    publishing <span class="token punctuation">{</span>        publications <span class="token punctuation">{</span>            <span class="token function">maven</span><span class="token punctuation">(</span>MavenPublication<span class="token punctuation">)</span> <span class="token punctuation">{</span>                groupId GROUP                artifactId ARTIFACT_ID                version VERSION                artifact bundleReleaseAar                artifact sourceJar                <span class="token comment" spellcheck="true">//根据输入数据生成 POM 后，自定义配置 POM。</span>                pom<span class="token operator">.</span>withXml <span class="token punctuation">{</span>                    <span class="token keyword">final</span> dependenciesNode <span class="token operator">=</span> <span class="token function">asNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'dependencies'</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">//dependenciesNode:dependencies[attributes={}; value=[]]</span>                    println <span class="token string">"dependenciesNode:"</span> <span class="token operator">+</span> dependenciesNode                    ext<span class="token operator">.</span>addDependency <span class="token operator">=</span> <span class="token punctuation">{</span> Dependency dep<span class="token punctuation">,</span> String scope <span class="token operator">-></span>                        <span class="token comment" spellcheck="true">//Dependency:DefaultExternalModuleDependency{group='com.qlife.android', name='lib-baidu-face', version='1.0.0', configuration='default'}</span>                        <span class="token comment" spellcheck="true">//scope:compile</span>                        println <span class="token string">"Dependency:"</span> <span class="token operator">+</span> dep                        println <span class="token string">"scope:"</span> <span class="token operator">+</span> scope                        <span class="token keyword">if</span> <span class="token punctuation">(</span>dep<span class="token operator">.</span>group <span class="token operator">==</span> null <span class="token operator">||</span> dep<span class="token operator">.</span>version <span class="token operator">==</span> null <span class="token operator">||</span> dep<span class="token operator">.</span>name <span class="token operator">==</span> null <span class="token operator">||</span> dep<span class="token operator">.</span>name <span class="token operator">==</span> <span class="token string">"unspecified"</span><span class="token punctuation">)</span>                            <span class="token keyword">return</span> <span class="token comment" spellcheck="true">// invalid dependencies should be ignored</span>                        <span class="token keyword">final</span> dependencyNode <span class="token operator">=</span> dependenciesNode<span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'dependency'</span><span class="token punctuation">)</span>                        dependencyNode<span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'artifactId'</span><span class="token punctuation">,</span> dep<span class="token operator">.</span>name<span class="token punctuation">)</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>dep<span class="token operator">.</span>version <span class="token operator">==</span> <span class="token string">'unspecified'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            dependencyNode<span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'groupId'</span><span class="token punctuation">,</span> project<span class="token operator">.</span>ext<span class="token operator">.</span>pomGroupID<span class="token punctuation">)</span>                            dependencyNode<span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'version'</span><span class="token punctuation">,</span> project<span class="token operator">.</span>ext<span class="token operator">.</span>pomVersion<span class="token punctuation">)</span>                            System<span class="token operator">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"${project.ext.pomGroupID} ${dep.name} ${project.ext.pomVersion}"</span><span class="token punctuation">)</span>                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                            dependencyNode<span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'groupId'</span><span class="token punctuation">,</span> dep<span class="token operator">.</span>group<span class="token punctuation">)</span>                            dependencyNode<span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'version'</span><span class="token punctuation">,</span> dep<span class="token operator">.</span>version<span class="token punctuation">)</span>                            System<span class="token operator">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"${dep.group} ${dep.name} ${dep.version}"</span><span class="token punctuation">)</span>                        <span class="token punctuation">}</span>                        dependencyNode<span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'scope'</span><span class="token punctuation">,</span> scope<span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">//一些依赖可能有类型，比如aar，应该在POM文件中提到</span>                        <span class="token comment" spellcheck="true">// Some dependencies may have types, such as aar, that should be mentioned in the POM file</span>                        <span class="token keyword">def</span> artifactsList <span class="token operator">=</span> dep<span class="token operator">.</span>properties<span class="token punctuation">[</span><span class="token string">'artifacts'</span><span class="token punctuation">]</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>artifactsList <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> artifactsList<span class="token operator">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">final</span> artifact <span class="token operator">=</span> artifactsList<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                            dependencyNode<span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">,</span> artifact<span class="token operator">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dep<span class="token operator">.</span>transitive<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">//在非传递依赖的情况下，它的所有依赖都应该从 POM 文件中强制排除</span>                            <span class="token comment" spellcheck="true">// In case of non transitive dependency, all its dependencies should be force excluded from them POM file</span>                            <span class="token keyword">final</span> exclusionNode <span class="token operator">=</span> dependencyNode<span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'exclusions'</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'exclusion'</span><span class="token punctuation">)</span>                            exclusionNode<span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'groupId'</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span>                            exclusionNode<span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'artifactId'</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span>                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dep<span class="token operator">.</span>properties<span class="token operator">.</span>excludeRules<span class="token operator">.</span>empty<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">//对于带排除的传递，应将所有排除规则添加到 POM 文件中</span>                            <span class="token comment" spellcheck="true">// For transitive with exclusions, all exclude rules should be added to the POM file</span>                            <span class="token keyword">final</span> exclusions <span class="token operator">=</span> dependencyNode<span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'exclusions'</span><span class="token punctuation">)</span>                            dep<span class="token operator">.</span>properties<span class="token operator">.</span>excludeRules<span class="token operator">.</span>each <span class="token punctuation">{</span> ExcludeRule rule <span class="token operator">-></span>                                <span class="token keyword">final</span> exclusionNode <span class="token operator">=</span> exclusions<span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'exclusion'</span><span class="token punctuation">)</span>                                exclusionNode<span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'groupId'</span><span class="token punctuation">,</span> rule<span class="token operator">.</span>group <span class="token operator">?:</span> <span class="token string">'*'</span><span class="token punctuation">)</span>                                exclusionNode<span class="token operator">.</span><span class="token function">appendNode</span><span class="token punctuation">(</span><span class="token string">'artifactId'</span><span class="token punctuation">,</span> rule<span class="token operator">.</span>module <span class="token operator">?:</span> <span class="token string">'*'</span><span class="token punctuation">)</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// List all "api" dependencies (for new Gradle) as "compile" dependencies</span>                    configurations<span class="token operator">.</span>api<span class="token operator">.</span><span class="token function">getDependencies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">.</span>each <span class="token punctuation">{</span> dep <span class="token operator">-></span> <span class="token function">addDependency</span><span class="token punctuation">(</span>dep<span class="token punctuation">,</span> <span class="token string">"compile"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// List all "implementation" dependencies (for new Gradle) as "runtime" dependencies</span>                    configurations<span class="token operator">.</span>implementation<span class="token operator">.</span><span class="token function">getDependencies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">.</span>each <span class="token punctuation">{</span> dep <span class="token operator">-></span> <span class="token function">addDependency</span><span class="token punctuation">(</span>dep<span class="token punctuation">,</span> <span class="token string">"runtime"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        repositories <span class="token punctuation">{</span>            maven <span class="token punctuation">{</span>                url <span class="token operator">=</span> URL                credentials <span class="token punctuation">{</span>                    username USER_NAME                    password PASSWORD                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>task <span class="token function">cleanBuildPublishLocal</span><span class="token punctuation">(</span>type<span class="token punctuation">:</span> GradleBuild<span class="token punctuation">)</span> <span class="token punctuation">{</span>    tasks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'clean'</span><span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">,</span> <span class="token string">'publishToMavenLocal'</span><span class="token punctuation">]</span><span class="token punctuation">}</span>task <span class="token function">cleanBuildPublish</span><span class="token punctuation">(</span>type<span class="token punctuation">:</span> GradleBuild<span class="token punctuation">)</span> <span class="token punctuation">{</span>    tasks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'clean'</span><span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">,</span> <span class="token string">'publish'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="1-8-Maven-pom-文件格式"><a href="#1-8-Maven-pom-文件格式" class="headerlink" title="1.8 Maven pom 文件格式"></a>1.8 Maven pom 文件格式</h3><p>POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p><p>执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。</p><p>POM 中可以指定以下配置：</p><ul><li>项目依赖</li><li>插件</li><li>执行目标</li><li>项目构建 profile</li><li>项目版本</li><li>项目开发者列表</li><li>相关邮件列表信息</li></ul><p>所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。</p><table><thead><tr><th align="left">节点</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">project</td><td align="left">工程的根标签。</td></tr><tr><td align="left">modelVersion</td><td align="left">模型版本需要设置为 4.0.0。</td></tr><tr><td align="left">groupId</td><td align="left">公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group</td></tr><tr><td align="left">artifactId</td><td align="left">项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。</td></tr><tr><td align="left">version</td><td align="left">这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。</td></tr><tr><td align="left">packaging</td><td align="left">项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型</td></tr><tr><td align="left">dependencies</td><td align="left">该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。</td></tr><tr><td align="left">dependency</td><td align="left">依赖项</td></tr><tr><td align="left">scope</td><td align="left">依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 <br>- compile ：默认范围，用于编译<br> - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath   <br>- runtime: 在执行时需要使用 <br>- test: 用于test任务时使用 <br>- system: 需要外在提供相应的元素。通过systemPath来取得                 <br>- systemPath: 仅用于范围为system。提供相应的路径 <br>- optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用</td></tr></tbody></table><p><a href="https://www.runoob.com/maven/maven-pom.html" target="_blank" rel="noopener">POM 标签大全详解</a></p><p>一个简单的Android 依赖库的pom文件如下</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- This module was also published with a richer model, Gradle metadata,  --></span>  <span class="token comment" spellcheck="true">&lt;!-- which should be used instead. Do not delete the following line which  --></span>  <span class="token comment" spellcheck="true">&lt;!-- is to indicate to Gradle or any Gradle module metadata file consumer  --></span>  <span class="token comment" spellcheck="true">&lt;!-- that they should prefer consuming it instead. --></span>  <span class="token comment" spellcheck="true">&lt;!-- do_not_remove: published-with-gradle-metadata --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.qlife.android<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lib-net-release<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>aar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.squareup.retrofit2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>retrofit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.6.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.squareup.okhttp3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>logging-interceptor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.2.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.github.jaydroid1024.JDispatcher<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jdispatcher-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    。。。  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h2 id="2-阿里云-云效-Maven-仓库"><a href="#2-阿里云-云效-Maven-仓库" class="headerlink" title="2.阿里云-云效 Maven 仓库"></a>2.阿里云-云效 Maven 仓库</h2><p>如果想自己搭建 NXRM(Nexus Repository Manager)私服，可参考 <a href="https://help.sonatype.com/repomanager3" target="_blank" rel="noopener">Nexus 官网</a> <a href="https://help.sonatype.com/repomanager3/download" target="_blank" rel="noopener">下载NXRM</a></p><p>阿里云Maven中央仓库为 <a href="https://devops.aliyun.com/?channel=maven.aliyun" target="_blank" rel="noopener">阿里云云效</a> 提供的公共代理仓库，帮助研发人员提高研发生产效率，使用阿里云Maven中央仓库作为下载源，速度更快更稳定。</p><p><a href="https://devops.aliyun.com/?channel=maven.aliyun" target="_blank" rel="noopener">阿里云云效</a> 是企业级一站式 DevOps 平台，覆盖产品从需求到运营的研发全生命周期，其中云效也提供了免费、可靠的Maven私有仓库 <a href="https://packages.aliyun.com/?channel=maven.aliyun" target="_blank" rel="noopener">Packages</a></p><h3 id="2-1-公共代理仓库"><a href="#2-1-公共代理仓库" class="headerlink" title="2.1 公共代理仓库"></a>2.1 公共代理仓库</h3><table><thead><tr><th align="left">仓库名称</th><th align="left">阿里云仓库地址</th><th align="left">阿里云仓库地址(老版)</th><th align="left">源地址</th></tr></thead><tbody><tr><td align="left">central</td><td align="left"><a href="https://maven.aliyun.com/repository/central" target="_blank" rel="noopener">https://maven.aliyun.com/repository/central</a></td><td align="left"><a href="https://maven.aliyun.com/nexus/content/repositories/central" target="_blank" rel="noopener">https://maven.aliyun.com/nexus/content/repositories/central</a></td><td align="left"><a href="https://repo1.maven.org/maven2/" target="_blank" rel="noopener">https://repo1.maven.org/maven2/</a></td></tr><tr><td align="left">jcenter</td><td align="left"><a href="https://maven.aliyun.com/repository/public" target="_blank" rel="noopener">https://maven.aliyun.com/repository/public</a></td><td align="left"><a href="https://maven.aliyun.com/nexus/content/repositories/jcenter" target="_blank" rel="noopener">https://maven.aliyun.com/nexus/content/repositories/jcenter</a></td><td align="left"><a href="http://jcenter.bintray.com/" target="_blank" rel="noopener">http://jcenter.bintray.com/</a></td></tr><tr><td align="left">public</td><td align="left"><a href="https://maven.aliyun.com/repository/public" target="_blank" rel="noopener">https://maven.aliyun.com/repository/public</a></td><td align="left"><a href="https://maven.aliyun.com/nexus/content/groups/public" target="_blank" rel="noopener">https://maven.aliyun.com/nexus/content/groups/public</a></td><td align="left">central仓和jcenter仓的聚合仓</td></tr><tr><td align="left">google</td><td align="left"><a href="https://maven.aliyun.com/repository/google" target="_blank" rel="noopener">https://maven.aliyun.com/repository/google</a></td><td align="left"><a href="https://maven.aliyun.com/nexus/content/repositories/google" target="_blank" rel="noopener">https://maven.aliyun.com/nexus/content/repositories/google</a></td><td align="left"><a href="https://maven.google.com/" target="_blank" rel="noopener">https://maven.google.com/</a></td></tr><tr><td align="left">gradle-plugin</td><td align="left"><a href="https://maven.aliyun.com/repository/gradle-plugin" target="_blank" rel="noopener">https://maven.aliyun.com/repository/gradle-plugin</a></td><td align="left"><a href="https://maven.aliyun.com/nexus/content/repositories/gradle-plugin" target="_blank" rel="noopener">https://maven.aliyun.com/nexus/content/repositories/gradle-plugin</a></td><td align="left"><a href="https://plugins.gradle.org/m2/" target="_blank" rel="noopener">https://plugins.gradle.org/m2/</a></td></tr><tr><td align="left">spring</td><td align="left"><a href="https://maven.aliyun.com/repository/spring" target="_blank" rel="noopener">https://maven.aliyun.com/repository/spring</a></td><td align="left"><a href="https://maven.aliyun.com/nexus/content/repositories/spring" target="_blank" rel="noopener">https://maven.aliyun.com/nexus/content/repositories/spring</a></td><td align="left"><a href="http://repo.spring.io/libs-milestone/" target="_blank" rel="noopener">http://repo.spring.io/libs-milestone/</a></td></tr><tr><td align="left">spring-plugin</td><td align="left"><a href="https://maven.aliyun.com/repository/spring-plugin" target="_blank" rel="noopener">https://maven.aliyun.com/repository/spring-plugin</a></td><td align="left"><a href="https://maven.aliyun.com/nexus/content/repositories/spring-plugin" target="_blank" rel="noopener">https://maven.aliyun.com/nexus/content/repositories/spring-plugin</a></td><td align="left"><a href="http://repo.spring.io/plugins-release/" target="_blank" rel="noopener">http://repo.spring.io/plugins-release/</a></td></tr><tr><td align="left">grails-core</td><td align="left"><a href="https://maven.aliyun.com/repository/grails-core" target="_blank" rel="noopener">https://maven.aliyun.com/repository/grails-core</a></td><td align="left"><a href="https://maven.aliyun.com/nexus/content/repositories/grails-core" target="_blank" rel="noopener">https://maven.aliyun.com/nexus/content/repositories/grails-core</a></td><td align="left"><a href="https://repo.grails.org/grails/core" target="_blank" rel="noopener">https://repo.grails.org/grails/core</a></td></tr><tr><td align="left">apache snapshots</td><td align="left"><a href="https://maven.aliyun.com/repository/apache-snapshots" target="_blank" rel="noopener">https://maven.aliyun.com/repository/apache-snapshots</a></td><td align="left"><a href="https://maven.aliyun.com/nexus/content/repositories/apache-snapshots" target="_blank" rel="noopener">https://maven.aliyun.com/nexus/content/repositories/apache-snapshots</a></td><td align="left"><a href="https://repository.apache.org/snapshots/" target="_blank" rel="noopener">https://repository.apache.org/snapshots/</a></td></tr></tbody></table><h3 id="2-2-Android-相关代理仓库"><a href="#2-2-Android-相关代理仓库" class="headerlink" title="2.2 Android 相关代理仓库"></a>2.2 Android 相关代理仓库</h3><table><thead><tr><th>仓库名称</th><th>阿里云仓库地址</th></tr></thead><tbody><tr><td>central</td><td><a href="https://maven.aliyun.com/repository/central" target="_blank" rel="noopener">https://maven.aliyun.com/repository/central</a></td></tr><tr><td>jcenter</td><td><a href="https://maven.aliyun.com/repository/public" target="_blank" rel="noopener">https://maven.aliyun.com/repository/public</a></td></tr><tr><td>public</td><td><a href="https://maven.aliyun.com/repository/public" target="_blank" rel="noopener">https://maven.aliyun.com/repository/public</a></td></tr><tr><td>google</td><td><a href="https://maven.aliyun.com/repository/google" target="_blank" rel="noopener">https://maven.aliyun.com/repository/google</a></td></tr><tr><td>gradle-plugin</td><td><a href="https://maven.aliyun.com/repository/gradle-plugin" target="_blank" rel="noopener">https://maven.aliyun.com/repository/gradle-plugin</a></td></tr></tbody></table><p><strong>拿来就用</strong></p><pre class=" language-groovy"><code class="language-groovy">buildscript <span class="token punctuation">{</span>    repositories <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//central</span>      maven <span class="token punctuation">{</span> url <span class="token string">'https://maven.aliyun.com/repository/central'</span> <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//jcenter&amp;public</span>      maven <span class="token punctuation">{</span> url <span class="token string">'https://maven.aliyun.com/repository/public'</span> <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//google</span>      maven <span class="token punctuation">{</span> url <span class="token string">'https://maven.aliyun.com/repository/google'</span> <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//gradle-plugin</span>      maven <span class="token punctuation">{</span> url <span class="token string">'https://maven.aliyun.com/repository/gradle-plugin'</span> <span class="token punctuation">}</span>      <span class="token function">mavenCentral</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      maven <span class="token punctuation">{</span> url <span class="token string">"https://jitpack.io"</span> <span class="token punctuation">}</span>      <span class="token function">google</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token function">jcenter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-3-制品私有仓库"><a href="#2-3-制品私有仓库" class="headerlink" title="2.3 制品私有仓库"></a>2.3 制品私有仓库</h3><ul><li><p>云效 Packages 为您自动创建了两个 Maven 仓库，一个 release 库和一个 snapshot 库。</p><ul><li><p>Maven Release 库用于存储功能趋于稳定、当前更新停止，可以用于发行的版本。</p></li><li><p>Maven Snapchat 库用于存储不稳定、尚处于开发中的版本，即快照版本。</p></li><li><p>您的制品文件具体推送到哪个库，根据您项目目录的build.gradle文件中version字段中是否配置了-SNAPSHOT。</p></li></ul></li><li><p>进入仓库后，可以通过仓库指南完成 仓库凭证设置、制品文件的上传和下载、私有库迁移。</p></li><li><p>包列表下展示仓库下所有二进制包文件，支持通过 Group Id 和 Artifacts Id 进行包文件搜索。</p></li><li><p>点击包文件展示包文件信息，默认展示最新版本信息，点击可切换版本。</p></li><li><p>默认企业拥有者为仓库拥有者，其他企业成员需要在仓库中设置成员和角色。仓库公开性、成员角色之间的关系如下：</p></li></ul><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>仓库角色</td><td>仓库公开性：私有仓库</td><td>仓库公开性：企业内可见</td></tr><tr><td>拥有者</td><td>访问、下载、上传、删除、仓库管理</td><td>访问、下载、上传、删除、仓库管理</td></tr><tr><td>管理员</td><td>访问、下载、上传、删除、仓库管理</td><td>访问、下载、上传、删除、仓库管理</td></tr><tr><td>开发成员</td><td>访问、下载、上传</td><td>访问、下载、上传</td></tr><tr><td>普通成员</td><td>访问、下载</td><td>访问、下载</td></tr><tr><td>非仓库成员</td><td>无</td><td>访问、下载</td></tr></tbody></table><h3 id="2-4-Gradle-推送"><a href="#2-4-Gradle-推送" class="headerlink" title="2.4 Gradle 推送"></a>2.4 Gradle 推送</h3><ol><li>设置仓库凭证</li></ol><pre class=" language-groovy"><code class="language-groovy">apply plugin<span class="token punctuation">:</span> <span class="token string">'maven-publish'</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--------${project.name}：Maven Publish Gradle--------"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//release 和 snapshot 的控制开关</span><span class="token keyword">def</span> isUploadToRelease <span class="token operator">=</span> rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'isUploadToRelease'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//远程Maven仓库的URL Release</span><span class="token keyword">def</span> MAVEN_REPO_RELEASE_URL <span class="token operator">=</span> rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'mavenRepoUrlRelease'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//远程Maven仓库的URL snapshots</span><span class="token keyword">def</span> MAVEN_REPO_SNAPSHOTS_URL <span class="token operator">=</span> rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'mavenRepoUrlSnapshots'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//远程Maven仓库用户名</span><span class="token keyword">def</span> USER_NAME <span class="token operator">=</span> rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'userName'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//远程Maven仓库密码</span><span class="token keyword">def</span> PASSWORD <span class="token operator">=</span> rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 唯一标识 每个组件都要指定</span><span class="token keyword">def</span> GROUP <span class="token operator">=</span> group<span class="token operator">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// todo 默认为项目名称</span><span class="token keyword">def</span> ARTIFACT_ID <span class="token operator">=</span> project<span class="token operator">.</span>name<span class="token comment" spellcheck="true">// 版本号 每个组件都要指定</span><span class="token keyword">def</span> VERSION <span class="token operator">=</span> version<span class="token operator">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//远程Maven仓库的URL</span><span class="token keyword">def</span> URL <span class="token operator">=</span> isUploadToRelease <span class="token operator">?</span> MAVEN_REPO_RELEASE_URL <span class="token punctuation">:</span> MAVEN_REPO_SNAPSHOTS_URL<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"dependencies_path: $GROUP:$ARTIFACT_ID:$VERSION"</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MAVEN_REPO_RELEASE_URL: $MAVEN_REPO_RELEASE_URL"</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MAVEN_REPO_SNAPSHOTS_URL: $MAVEN_REPO_SNAPSHOTS_URL"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//https://docs.gradle.org/7.0/userguide/publishing_maven.html#publishing_maven</span><span class="token comment" spellcheck="true">//https://developer.android.com/studio/build/maven-publish-plugin</span><span class="token comment" spellcheck="true">// Because the components are created only during the afterEvaluate phase, you must</span><span class="token comment" spellcheck="true">// configure your publications using the afterEvaluate() lifecycle method.</span>afterEvaluate <span class="token punctuation">{</span>    publishing <span class="token punctuation">{</span>        publications <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Creates a Maven publication called "release".</span>            <span class="token function">release</span><span class="token punctuation">(</span>MavenPublication<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Applies the component for the release build variant.</span>                from components<span class="token operator">.</span>release                <span class="token comment" spellcheck="true">// You can then customize attributes of the publication as shown below.</span>                groupId <span class="token operator">=</span> GROUP                artifactId <span class="token operator">=</span> ARTIFACT_ID                version <span class="token operator">=</span> VERSION            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Creates a Maven publication called “debug”.</span>            <span class="token function">debug</span><span class="token punctuation">(</span>MavenPublication<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Applies the component for the debug build variant.</span>                from components<span class="token operator">.</span>debug                groupId <span class="token operator">=</span> GROUP                artifactId <span class="token operator">=</span> ARTIFACT_ID <span class="token operator">+</span> <span class="token string">"-debug"</span>                version <span class="token operator">=</span> VERSION            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        repositories <span class="token punctuation">{</span>            maven <span class="token punctuation">{</span>                url <span class="token operator">=</span> URL                credentials <span class="token punctuation">{</span>                    username USER_NAME                    password PASSWORD                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>设置仓库下载配置</li></ol><pre class=" language-groovy"><code class="language-groovy">allprojects <span class="token punctuation">{</span>    repositories <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//central</span>        maven <span class="token punctuation">{</span> url <span class="token string">'https://maven.aliyun.com/repository/central'</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//jcenter&amp;public</span>        maven <span class="token punctuation">{</span> url <span class="token string">'https://maven.aliyun.com/repository/public'</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//google</span>        maven <span class="token punctuation">{</span> url <span class="token string">'https://maven.aliyun.com/repository/google'</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//gradle-plugin</span>        maven <span class="token punctuation">{</span> url <span class="token string">'https://maven.aliyun.com/repository/gradle-plugin'</span> <span class="token punctuation">}</span>        <span class="token function">mavenCentral</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        maven <span class="token punctuation">{</span> url <span class="token string">"https://jitpack.io"</span> <span class="token punctuation">}</span>        <span class="token function">google</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">jcenter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">/**Maven 私服配置*/</span>        <span class="token comment" spellcheck="true">// 仓库类型 local dev production</span>        <span class="token keyword">def</span> currentMavenRepositoryType <span class="token operator">=</span> rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'currentMavenRepositoryType'</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> localMavenRepositoryType <span class="token operator">=</span> rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepositoryType<span class="token punctuation">[</span><span class="token string">'local'</span><span class="token punctuation">]</span>        maven <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//区分本地仓库和远程仓库</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>currentMavenRepositoryType <span class="token operator">!=</span> localMavenRepositoryType<span class="token punctuation">)</span> <span class="token punctuation">{</span>                credentials <span class="token punctuation">{</span>                    username rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'userName'</span><span class="token punctuation">]</span>                    password rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            url rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'mavenRepoUrlRelease'</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span>        maven <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//区分本地仓库和远程仓库</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>currentMavenRepositoryType <span class="token operator">!=</span> localMavenRepositoryType<span class="token punctuation">)</span> <span class="token punctuation">{</span>                credentials <span class="token punctuation">{</span>                    username rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'userName'</span><span class="token punctuation">]</span>                    password rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            url rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'mavenRepoUrlSnapshots'</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-5-Gradle-拉取"><a href="#2-5-Gradle-拉取" class="headerlink" title="2.5 Gradle 拉取"></a>2.5 Gradle 拉取</h3><ol><li>设置仓库凭证</li></ol><pre class=" language-groovy"><code class="language-groovy">allprojects <span class="token punctuation">{</span>    repositories <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//central</span>        maven <span class="token punctuation">{</span> url <span class="token string">'https://maven.aliyun.com/repository/central'</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//jcenter&amp;public</span>        maven <span class="token punctuation">{</span> url <span class="token string">'https://maven.aliyun.com/repository/public'</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//google</span>        maven <span class="token punctuation">{</span> url <span class="token string">'https://maven.aliyun.com/repository/google'</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//gradle-plugin</span>        maven <span class="token punctuation">{</span> url <span class="token string">'https://maven.aliyun.com/repository/gradle-plugin'</span> <span class="token punctuation">}</span>        <span class="token function">mavenCentral</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        maven <span class="token punctuation">{</span> url <span class="token string">"https://jitpack.io"</span> <span class="token punctuation">}</span>        <span class="token function">google</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">jcenter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">/**Maven 私服配置*/</span>        <span class="token comment" spellcheck="true">// 仓库类型 local dev production</span>        <span class="token keyword">def</span> currentMavenRepositoryType <span class="token operator">=</span> rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'currentMavenRepositoryType'</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> localMavenRepositoryType <span class="token operator">=</span> rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepositoryType<span class="token punctuation">[</span><span class="token string">'local'</span><span class="token punctuation">]</span>        maven <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//区分本地仓库和远程仓库</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>currentMavenRepositoryType <span class="token operator">!=</span> localMavenRepositoryType<span class="token punctuation">)</span> <span class="token punctuation">{</span>                credentials <span class="token punctuation">{</span>                    username rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'userName'</span><span class="token punctuation">]</span>                    password rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            url rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'mavenRepoUrlRelease'</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span>        maven <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//区分本地仓库和远程仓库</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>currentMavenRepositoryType <span class="token operator">!=</span> localMavenRepositoryType<span class="token punctuation">)</span> <span class="token punctuation">{</span>                credentials <span class="token punctuation">{</span>                    username rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'userName'</span><span class="token punctuation">]</span>                    password rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            url rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'mavenRepoUrlSnapshots'</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>配置包信息</li></ol><pre class=" language-groovy"><code class="language-groovy">dependencies <span class="token punctuation">{</span>    <span class="token keyword">def</span> currentMavenRepositoryType <span class="token operator">=</span> rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>mavenRepo<span class="token punctuation">[</span><span class="token string">'dependenceTypeIsModule'</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentMavenRepositoryType<span class="token punctuation">)</span> <span class="token punctuation">{</span>        implementation <span class="token function">project</span><span class="token punctuation">(</span>path<span class="token punctuation">:</span> <span class="token string">':lib-net'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        implementation rootProject<span class="token operator">.</span>ext<span class="token operator">.</span>libNet    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="3-Grade依赖管理"><a href="#3-Grade依赖管理" class="headerlink" title="3.Grade依赖管理"></a>3.Grade依赖管理</h2><h3 id="3-1-依赖项类型"><a href="#3-1-依赖项类型" class="headerlink" title="3.1 依赖项类型"></a>3.1 依赖项类型</h3><pre class=" language-groovy"><code class="language-groovy">dependencies <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 对本地库模块的依赖</span>    implementation <span class="token function">project</span><span class="token punctuation">(</span><span class="token string">":mylibrary"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 对本地二进制文件的依赖</span>    implementation <span class="token function">fileTree</span><span class="token punctuation">(</span>dir<span class="token punctuation">:</span> <span class="token string">'libs'</span><span class="token punctuation">,</span> include<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'*.jar'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>      implementation <span class="token function">files</span><span class="token punctuation">(</span><span class="token string">'libs/foo.jar'</span><span class="token punctuation">)</span>    implementation <span class="token function">project</span><span class="token punctuation">(</span>path<span class="token punctuation">:</span> <span class="token string">':foo-aar-module'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 对远程二进制文件的依赖</span>    implementation <span class="token string">'com.example.android:app-magic:12.3'</span><span class="token punctuation">}</span></code></pre><p><strong>本地库模块依赖</strong></p><p>这里依赖了一个名为“mylibrary”（此名称必须与在您的 settings.gradle 文件中使用 <code>include:</code> 定义的库名称相符）的Android 库模块。在构建您的应用时，构建系统会编译该库模块，并将生成的编译内容打包到 APK 中。</p><p><strong>本地二进制文件依赖</strong></p><p>Gradle 声明了对项目的 <code>module_name/libs/</code> 目录中 JAR 文件的依赖关系（因为 Gradle 会读取 <code>build.gradle</code> 文件的相对路径）。</p><p>也可指定各个jar/aar文件或者通过创建一个aar/jar 模块建立像对本地库模块一样的依赖</p><p><strong>远程二进制文件依赖</strong></p><pre><code>implementation 'com.example.android:app-magic:12.3'</code></pre><p>这实际上是以下代码的简写形式：</p><pre><code>implementation group: 'com.example.android', name: 'app-magic', version: '12.3'</code></pre><p>这声明了对“com.example.android”命名空间组内的 12.3 版“app-magic”库的依赖关系。</p><p>此类远程依赖项要求您声明适当的远程代码库，Gradle 应在其中查找相应的库。如果本地不存在相应的库，Gradle 会从远程站点提取它。</p><h3 id="3-2-依赖项依赖方式配置"><a href="#3-2-依赖项依赖方式配置" class="headerlink" title="3.2 依赖项依赖方式配置"></a>3.2 依赖项依赖方式配置</h3><p>在 <code>dependencies</code> 代码块内，您可以从多种不同的依赖项配置中选择其一,每种依赖项配置都向 Gradle 提供了有关如何使用该依赖项的不同说明。下表介绍了Android 项目中的依赖项使用的各种配置。</p><table><thead><tr><th align="center">新配置</th><th align="center">已弃用配置</th><th align="left">行为描述</th></tr></thead><tbody><tr><td align="center"><code>implementation</code></td><td align="center"><code>compile</code></td><td align="left">Gradle 会将依赖项添加到编译类路径，并将依赖项打包到构建输出。 当模块配置 <code>implementation</code> 依赖项时，Gradle在编译时<strong>不会将该依赖项传递给其他模块</strong>。也就是说，其他模块只有在运行时才能使用该依赖项。 使用此依赖项配置代替 <code>api</code> 或 <code>compile</code>（已弃用）可以<strong>显著缩短构建时间</strong>，因为这样可以减少构建系统需要重新编译的模块数。例如，如果 <code>implementation</code> 依赖项更改了其 API，Gradle 只会重新编译该依赖项以及直接依赖于它的模块。大多数应用和测试模块都应使用此配置。</td></tr><tr><td align="center"><code>api</code></td><td align="center"><code>compile</code></td><td align="left">Gradle 会将依赖项添加到编译类路径和构建输出。当一个模块包含 <code>api</code> 依赖项时，会让 Gradle <strong>以传递方式将该依赖项导出到其他模块</strong>，以便这些模块在运行时和编译时都可以使用该依赖项。 此配置的行为类似于 <code>compile</code>（现已弃用），但使用它时应格外小心，只能对需要以传递方式导出到其它上游消费者的依赖项时才使用它。这是因为，如果 <code>api</code> 依赖项更改了其外部 API，Gradle 会在编译时重新编译所有有权访问该依赖项的模块。因此，拥有大量的 <code>api</code> 依赖项会显<strong>著增加构建时间</strong>。除非要将依赖项的 API 公开给单独的模块，否则库模块应改用 <code>implementation</code> 依赖项。</td></tr><tr><td align="center"><code>compileOnly</code></td><td align="center"><code>provided</code></td><td align="left">Gradle 只会将依赖项添加到编译类路径也就是说，<strong>不会将其添加到构建输出</strong>。如果您创建 Android 模块时在编译期间需要相应依赖项，但它在运行时可有可无，此配置会很有用。如果您使用此配置，那么您的库模块必须包含一个运行时条件，用于检查是否提供了相应依赖项，然后适当地改变该模块的行为，以使该模块在未提供相应依赖项的情况下仍可正常运行。这样做<strong>不会添加不重要的瞬时依赖项</strong>，因而<strong>有助于减小最终 APK 的大小</strong>。此配置的行为类似于 <code>provided</code>（现已弃用）。<strong>注意</strong>：您不能将 <code>compileOnly</code> 配置与 AAR 依赖项配合使用。</td></tr><tr><td align="center"><code>runtimeOnly</code></td><td align="center"><code>apk</code></td><td align="left">Gradle 只会将依赖项添加到构建输出，以便在运行时使用。也就是说，不会将其添加到编译类路径。此配置的行为类似于 <code>apk</code>（现已弃用）。</td></tr><tr><td align="center"><code>annotationProcessor</code></td><td align="center"><code>compile</code></td><td align="left">如需添加对作为注释处理器的库的依赖关系，您必须使用 <code>annotationProcessor</code> 配置将其添加到注释处理器类路径。这是因为，使用此配置可以<strong>将编译类路径与注释处理器类路径分开，从而提高构建性能</strong>。如果 Gradle 在编译类路径上找到注释处理器，则会禁用<a href="https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_compile_avoidance" target="_blank" rel="noopener">避免编译</a>功能，这样会对构建时间产生负面影响（Gradle 5.0 及更高版本会忽略在编译类路径上找到的注释处理器）。如果 JAR 文件包含以下文件，则 Android Gradle 插件会假定依赖项是注释处理器： <code>META-INF/services/javax.annotation.processing.Processor</code>。如果插件检测到编译类路径上包含注释处理器，则会生成构建错误。</td></tr></tbody></table><h3 id="3-3-依赖项顺序"><a href="#3-3-依赖项顺序" class="headerlink" title="3.3 依赖项顺序"></a>3.3 依赖项顺序</h3><p>依赖项的列出顺序指明了每个库的优先级：第一个库的优先级高于第二个，第二个库的优先级高于第三个，依此类推。在<a href="https://developer.android.com/studio/write/add-resources#resource_merging" target="_blank" rel="noopener">合并资源</a>或<a href="https://developer.android.com/studio/build/manifest-merge" target="_blank" rel="noopener">将清单元素从库中合并</a>到应用中时，此顺序很重要。</p><p>例如，如果您的项目声明以下内容：</p><ul><li>依赖 <code>LIB_A</code> 和 <code>LIB_B</code>（按此顺序）</li><li><code>LIB_A</code> 依赖于 <code>LIB_C</code> 和 <code>LIB_D</code>（按此顺序）</li><li><code>LIB_B</code> 也依赖于 <code>LIB_C</code></li></ul><pre class=" language-groovy"><code class="language-groovy"><span class="token comment" spellcheck="true">//app</span>dependencies <span class="token punctuation">{</span>    <span class="token function">implementation</span><span class="token punctuation">(</span><span class="token string">'LIB_A'</span><span class="token punctuation">)</span>    <span class="token function">implementation</span><span class="token punctuation">(</span><span class="token string">'LIB_B'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//LIB_A</span>dependencies <span class="token punctuation">{</span>    <span class="token function">implementation</span><span class="token punctuation">(</span><span class="token string">'LIB_C'</span><span class="token punctuation">)</span>    <span class="token function">implementation</span><span class="token punctuation">(</span><span class="token string">'LIB_D'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//LIB_B</span>dependencies <span class="token punctuation">{</span>    <span class="token function">implementation</span><span class="token punctuation">(</span><span class="token string">'LIB_C'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>![image-20210826160438305](/Users/xuejiewang/Library/Application Support/typora-user-images/image-20210826160438305.png)</p><p>那么，扁平型依赖项顺序将如下所示：</p><ol><li><code>LIB_A</code></li><li><code>LIB_D</code></li><li><code>LIB_B</code></li><li><code>LIB_C</code></li></ol><p>这可以确保 <code>LIB_A</code> 和 <code>LIB_B</code> 都可以替换 <code>LIB_C</code>；并且 <code>LIB_D</code> 的优先级仍高于 <code>LIB_B</code>，因为 <code>LIB_A</code>（依赖前者）的优先级高于 <code>LIB_B</code>。</p><h3 id="3-4-依赖冲突问题"><a href="#3-4-依赖冲突问题" class="headerlink" title="3.4 依赖冲突问题"></a>3.4 依赖冲突问题</h3><p><strong>解决类路径之间的冲突</strong></p><p>当 Gradle 解析编译类路径时，会先解析运行时类路径，然后使用所得结果确定应添加到编译类路径的依赖项版本。换句话说，运行时类路径决定了下游类路径上完全相同的依赖项所需的版本号。</p><p>应用的运行时类路径还决定了 Gradle 需要对应用的测试 APK 的运行时类路径中的匹配依赖项使用的版本号。图 1 说明了类路径的层次结构。</p><p><img src="https://developer.android.com/studio/images/build/classpath_sync-2x.png" alt="img"></p><p>例如，当应用使用 <code>implementation</code> <a href="https://developer.android.com/studio/build/dependencies#dependency_configurations" target="_blank" rel="noopener">依赖项配置</a>加入某个依赖项的一个版本，而库模块使用 <code>runtimeOnly</code> 配置加入该依赖项的另一个版本时，就可能会发生多个类路径中出现同一依赖项的不同版本的冲突。</p><p>在解析对运行时和编译时类路径的依赖关系时，Android Gradle 插件 3.3.0 及更高版本会尝试自动解决某些下游版本冲突。例如，如果运行时类路径包含库 A 版本 2.0，而编译类路径包含库 A 版本 1.0，则插件会自动将对编译类路径的依赖关系更新为库 A 版本 2.0，以避免错误。</p><p>不过，如果运行时类路径包含库 A 版本 1.0，而编译类路径包含库 A 版本 2.0，插件不会将对编译类路径的依赖关系降级为库 A 版本 1.0，您仍会收到一条与以下内容类似的错误：</p><pre><code>Conflict with dependency 'com.example.library:some-lib:2.0' in project 'my-library'.Resolved versions for runtime classpath (1.0) and compile classpath (2.0) differ.</code></pre><p>如需解决此问题，请执行以下某项操作：</p><ul><li>将所需版本的依赖项作为 <code>api</code> 依赖项添加到库模块。也就是说，只有库模块声明相应依赖项，但应用模块也能以传递方式访问其 API。 - 或者，您也可以同时在两个模块中声明相应依赖项，但应确保每个模块使用的版本相同。不妨考虑<a href="https://developer.android.com/studio/build/gradle-tips#configure-project-wide-properties" target="_blank" rel="noopener">配置项目全局属性</a>，以确保每个依赖项的版本在整个项目中保持一致。</li></ul><p><strong>排除传递依赖项</strong></p><p>随着应用的范围不断扩大，它可能会包含许多依赖项，包括直接依赖项和传递依赖项（应用中导入的库所依赖的库）。如需排除不再需要的传递依赖项，您可以使用 <code>exclude</code> 关键字，如下所示：</p><pre><code>dependencies {    implementation('some-library') {        exclude group: 'com.example.imgtools', module: 'native'    }}</code></pre><p>如果在configuration中定义一个exclude,那么所有依赖的transitive dependency (指定的)都会被去除。定义exclude时候，或只指定group, 或只指定module名字，或二者都指定。</p><p>下面是一些使用exclude的典型场合：</p><ul><li>有licensing问题</li><li>从远程仓库上无法获取到依赖</li><li>runtime时候用不到</li><li>有版本冲突</li></ul><p><strong>强制使用当前版本</strong></p><pre><code>implementation('com.squareup.okhttp:okhttp-mt:2.5.0') {    force = true}</code></pre><p>如上，我们在依赖okhttp的时候很可能发生冲突，就比如依赖的依赖中也包含了okhttp，这种场合下，就会产生版本冲突的问题，加上force = true表明的意思就是即使在有依赖库版本冲突的情况下坚持使用被标注的这个依赖库版本。</p><p><strong>间接依赖 transitive</strong></p><p>transitive dependencies 被称为依赖的依赖，称为“间接依赖”比较合适。</p><pre><code>implementation('com.meituan.android.terminus:library:6.6.1.16@aar') {    transitive = true}</code></pre><p>在后面加上@aar，意指你只是下载该aar包，而并不下载该aar包所依赖的其他库，那如果想在使用@aar的前提下还能下载其依赖库，则需要添加transitive=true的条件。</p><h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4.参考资料"></a>4.参考资料</h2><ul><li><a href="https://developer.aliyun.com/mvn/guide" target="_blank" rel="noopener">阿里云 | 云效 Maven</a> </li><li><a href="https://thoughts.aliyun.com/sharespace/5e8c436d546fd9001aee824a/docs/5e8c436d546fd9001aee8244?spm=a2c4g.11186623.2.2.5db21b3frHmIbF" target="_blank" rel="noopener">阿里云 | 云效制品仓库 Package 官方文档</a></li><li><a href="https://packages.aliyun.com/maven" target="_blank" rel="noopener">阿里云 | 云效制品仓库 Package 地址</a></li><li><a href="https://developer.android.com/studio/build/maven-publish-plugin" target="_blank" rel="noopener">Android 开发者 | Android Maven Publish docs</a></li><li><a href="https://docs.gradle.org/current/userguide/publishing_maven.html" target="_blank" rel="noopener">Gradle 用户指南 | Gradle Maven Publish official page</a></li><li><a href="http://maven.apache.org/what-is-maven.html" target="_blank" rel="noopener">What is Maven</a> </li><li><a href="https://www.runoob.com/maven/maven-pom.html" target="_blank" rel="noopener">菜鸟教程 | Maven 教程</a></li><li><a href="https://stackoverflow.com/questions/26874498/publish-an-android-library-to-maven-with-aar-and-source-jar" target="_blank" rel="noopener">Publish an Android library to Maven with aar and source jar</a></li><li><a href="https://developer.android.com/studio/build/dependencies" target="_blank" rel="noopener"> Android 开发者 | 添加构建依赖项 </a></li><li><a href="https://docs.gradle.org/current/userguide/dependency_management.html#dependency_management_in_gradle" target="_blank" rel="noopener">Gradle 用户指南 | Gradle中的依赖管理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 组件化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化 </tag>
            
            <tag> Maven </tag>
            
            <tag> aar化 </tag>
            
            <tag> 编译优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筑基系列-操作系统基础知识小抄版</title>
      <link href="2021/07/01/computer-os/"/>
      <url>2021/07/01/computer-os/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/post_banner_jay.png" alt=""></p><h1 id="筑基系列-操作系统基础知识小抄版"><a href="#筑基系列-操作系统基础知识小抄版" class="headerlink" title="筑基系列-操作系统基础知识小抄版"></a>筑基系列-操作系统基础知识小抄版</h1><blockquote><p>计算机基础知识筑基三部曲：</p><ul><li><p><strong><a href="https://juejin.cn/post/6991367806772052004" target="_blank" rel="noopener">第一部：筑基系列-计算机基础知识小抄版</a></strong></p><ul><li>包括发展史、CPU、总线、存储器、指令系统、控制器、运算器、位运算等</li></ul></li><li><p><strong><a href="https://juejin.cn/post/6991385109509193764" target="_blank" rel="noopener">第二部：筑基系列-操作系统基础知识小抄版</a></strong></p><ul><li>包括进程与线程同步管理、作业管理、存储管理、虚拟内存、Linux、文件管理等</li></ul></li><li><p><strong><a href="https://juejin.cn/post/6991397445251334151" target="_blank" rel="noopener">第三部：筑基系列-计算机网络基础知识小抄版</a></strong></p><ul><li>包括OSI七层模型各层详解、IP协议、TCP\IP协议、Http协议、DNS协议等</li></ul></li></ul></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1.操作系统概览">1.操作系统概览</a><ul><li><a href="#11-什么是操作系统">1.1 什么是操作系统</a></li><li><a href="#12-为什么需要操作系统">1.2 为什么需要操作系统</a></li><li><a href="#13-操作系统的基本功能">1.3 操作系统的基本功能</a></li><li><a href="#14-操作系统相关概念">1.4 操作系统相关概念</a></li></ul></li><li><a href="#2.进程管理">2.进程管理</a><ul><li><a href="#21-进程概述">2.1 进程概述</a></li><li><a href="#22-进程管理五状态模型">2.2 进程管理五状态模型</a></li><li><a href="#23-进程同步">2.3 进程同步</a></li><li><a href="#24-linux的进程管理">2.4 Linux的进程管理</a></li></ul></li><li><a href="#3.作业管理">3.作业管理</a><ul><li><a href="#31-进程调度">3.1 进程调度</a></li><li><a href="#32-死锁">3.2 死锁</a></li></ul></li><li><a href="#4.存储管理">4.存储管理</a><ul><li><a href="#41-计算机进行存储管理的必要性">4.1 计算机进行存储管理的必要性</a></li><li><a href="#42-内存的分配过程">4.2 内存的分配过程</a></li><li><a href="#43-内存的回收过程">4.3 内存的回收过程</a></li><li><a href="#44-进程的存储管理">4.4 进程的存储管理</a></li><li><a href="#45-虚拟内存">4.5 虚拟内存</a></li><li><a href="#46-linux的存储管理">4.6 Linux的存储管理</a></li></ul></li><li><a href="#5.文件管理">5.文件管理</a><ul><li><a href="#51-操作系统的文件管理">5.1 操作系统的文件管理</a></li><li><a href="#52-linux文件的基本操作">5.2 Linux文件的基本操作</a></li></ul></li><li><a href="#6设备管理">6.设备管理</a></li><li><a href="#7.实践">7.实践</a><ul><li><a href="#71-线程同步实践">7.1 线程同步实践</a></li><li><a href="#72-进程同步实践">7.2 进程同步实践</a></li></ul></li><li><a href="#8关于我">8.关于我</a></li><li><a href="#9参考">9.参考</a></li></ul><h2 id="1-操作系统概览"><a href="#1-操作系统概览" class="headerlink" title="1 操作系统概览"></a>1 操作系统概览</h2><h3 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h3><ul><li>管理配置内存、决定资源供需顺序、控制输入输出设备等</li><li>操作系统是管理计算机硬件和软件资源的计算机程序</li><li>操作系统提供让用户和系统交互的操作界面</li><li>从手机到超级计算机，操作系统可简单也可复杂</li><li>操作系统的种类是多种多样的，不局限于计算机</li><li>在不同的设备上，操作系统可向用户呈现多种操作手段</li><li>Android，IOS，HarmonyOS</li><li>Windows ，Linux ，MacOS</li><li>总结：管理硬件、提供用户交互的软件系统</li></ul><h3 id="1-2-为什么需要操作系统"><a href="#1-2-为什么需要操作系统" class="headerlink" title="1.2 为什么需要操作系统"></a>1.2 为什么需要操作系统</h3><ul><li>我们不可能直接操作计算机硬件</li><li>设备种类繁多复杂，需要统一界面</li><li>设备种类繁多复杂，需要统一界面</li></ul><h3 id="1-3-操作系统的基本功能"><a href="#1-3-操作系统的基本功能" class="headerlink" title="1.3 操作系统的基本功能"></a>1.3 操作系统的基本功能</h3><ul><li>操作系统统一管理着计算机资源<ul><li>处理器资源</li><li>IO设备资源</li><li>存储器资源</li><li>文件资源</li></ul></li><li>操作系统实现了对计算机资源的抽象<ul><li>IO设备管理软件，提供读写接口</li><li>用户无需面向硬件接口编程</li><li>文件管理软件，提供操作文件接口</li></ul></li><li>操作系统提供了用户与计算机之间的接口<ul><li>命令形式</li><li>图像窗口形式</li><li>系统调用形式</li></ul></li></ul><h3 id="1-4-操作系统相关概念"><a href="#1-4-操作系统相关概念" class="headerlink" title="1.4 操作系统相关概念"></a>1.4 操作系统相关概念</h3><ul><li>并发性/并行性<ul><li>多道程序设计<ul><li>多道程序设计是指在计算机内存中同时存放多个程序</li><li>多道程序在计算机的管理程序之下相互穿插运行</li></ul></li><li>并行是指两个或多个事件可以在同一个时刻发生</li><li>并发是指两个或多个事件可以在同一个时间间隔发生</li></ul></li><li>共享性<ul><li>共享性表现为操作系统中的资源可供多个并发的程序共同使用</li><li>这种共同使用的形式称之为资源共享</li><li>多个程序可以同时使用主存资源</li><li>资源共享根据属性可分为两种方式<ul><li>互斥共享形式 <ul><li>当资源被程序A占用时，其他想使用的话只能等待</li><li>只有进程A使用完以后，其他进程才可以使用该资源</li><li>打印机</li></ul></li><li>同时访问形式<ul><li>某种资源在一段时间内并发地被多个程序访问</li><li>这种“同时”是宏观的，从宏观去看该资源可以被同时访问</li><li>向磁盘写数据</li></ul></li></ul></li></ul></li><li>虚拟性<ul><li>虚拟性表现为把一个物理实体转变为若干个逻辑实体</li><li>物理实体是真实存在的，逻辑实体是虚拟的</li><li>虚拟的技术主要有时分复用技术和空分复用技术</li><li>时分复用技术<ul><li>资源在时间上进行复用，不同程序并发使用</li><li>多道程序分时使用计算机的硬件资源</li><li>提高资源的利用率</li><li>虚拟处理器技术 <ul><li>借助多道程序设计技术</li><li>为每个程序建立进程</li><li>多个程序分时复用处理器</li></ul></li><li>虚拟设备技术<ul><li>物理设备虚拟为多个逻辑设备</li><li>每个程序占用一个逻辑设备</li><li>多个程序通过逻辑设备并发访问</li></ul></li></ul></li><li>空分复用技术<ul><li>空分复用技术用来实现虚拟磁盘、虚拟内存等</li><li>提高资源的利用率，提升编程效率</li><li>虚拟磁盘技术 <ul><li>物理磁盘虚拟为逻辑磁盘</li><li>C、 D、 E等逻辑盘</li><li>使用起来更加安全、方便</li></ul></li><li>虚拟内存技术<ul><li>在逻辑上扩大程序的存储容量</li><li>使用比实际内存更大的容量</li><li>大大提升编程效率</li></ul></li></ul></li></ul></li><li>异步性<ul><li>在多道程序环境下，允许多个进程并发执行</li><li>进程在使用资源时可能需要等待或放弃</li><li>进程的执行并不是一气呵成的，而是以走走停停的形式推进</li><li>进程以不可预知的速度向前推进</li></ul></li></ul><h2 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2.进程管理"></a>2.进程管理</h2><h3 id="2-1-进程概述"><a href="#2-1-进程概述" class="headerlink" title="2.1 进程概述"></a>2.1 进程概述</h3><ul><li><p>为什么需要进程</p><ul><li>没有配置OS之前，资源属于当前运行的程序</li><li>配置OS之后，引入多道程序设计的概念</li><li>合理的隔离资源、运行环境，提升资源利用率</li><li>进程是系统进行资源分配和调度的基本单位</li><li>进程作为程序独立运行的载体保障程序正常执行</li><li>进程的存在使得操作系统资源的利用率大幅提升</li></ul></li><li><p>主存中的进程形态-进程控制块（PCB）</p><ul><li>用于描述和控制进程运行的通用数据结构</li><li>记录进程当前状态和控制进程运行的全部信息</li><li>PCB的使得进程是能够独立运行的基本单位</li><li>PCB是操作系统进行调度经常会被读取的信息</li><li>PCB是常驻内存的，存放在系统专门开辟的PCB区域内</li><li>标识符<ul><li>标识符唯一标记一个进程，用于区别其他进程</li></ul></li><li>状态<ul><li>标记进程的进程状态，如：运行态</li></ul></li><li>优先级</li><li>程序计数器<ul><li>进程即将被执行的下一条指令的地址</li></ul></li><li>内存指针<ul><li>程序代码、进程数据相关指针</li></ul></li><li>上下文数据<ul><li>进程执行时处理器存储的数据</li></ul></li><li>IO状态信息<ul><li>被进程IO操作所占用的文件列表</li></ul></li><li>记账信息<ul><li>使用处理器时间、时钟数总和等</li></ul></li></ul></li><li><p>进程与线程</p><ul><li>关系<ul><li>一个进程可以有一个或多个线程</li><li>进程是系统进行资源分配和调度的基本单位</li><li>线程是操作系统进行运行调度的最小单位</li><li>包含在进程之中，是进程中实际运行工作的单位</li><li>一个进程可以并发多个线程，每个线程执行不同的任务</li><li>进程的线程共享进程资源</li></ul></li><li>区别</li></ul><table><thead><tr><th></th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>资源</td><td>资源分配的基本单位</td><td>不拥有资源</td></tr><tr><td>调度</td><td>独立调度的基本单位</td><td>独立调度的最小单位</td></tr><tr><td>系统开销</td><td>进程系统开销大</td><td>线程系统开销小</td></tr><tr><td>通信</td><td>进程IPC</td><td>读写同一进程数据通信</td></tr></tbody></table></li></ul><h3 id="2-2-进程管理五状态模型"><a href="#2-2-进程管理五状态模型" class="headerlink" title="2.2 进程管理五状态模型"></a>2.2 进程管理五状态模型</h3><ul><li>就绪状态<ul><li>当进程被分配到除CPU以外所有必要的资源后</li><li>只要再获得CPU的使用权，就可以立即运行</li><li>其他资源都准备好、只差CPU资源的状态为就绪状态</li><li>就绪队列：在一个系统中多个处于就绪状态的进程通常排成一个队列</li></ul></li><li>阻塞状态<ul><li>进程因某种原因如：其他设备未就绪而无法继续执行</li><li>从而放弃CPU的状态称为阻塞状态</li><li>阻塞队列</li></ul></li><li>执行状态<ul><li>进程获得CPU，其程序正在执行称为执行状态</li><li>在单处理机中，在某个时刻只能有一个进程是处于执行状态</li></ul></li><li>创建状态<ul><li>分配PCB—&gt; 插入就绪队列</li><li>创建进程时拥有PCB但其他资源尚未就绪的状态称为创建状态</li><li>操作系统提供fork函数接口创建进程</li></ul></li><li>终止状态<ul><li>系统清理 —&gt;PCB归还</li><li>进程结束由系统清理或者归还PCB的状态称为终止状态</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801163657.jpg" alt=""></p><h3 id="2-3-进程同步"><a href="#2-3-进程同步" class="headerlink" title="2.3 进程同步"></a>2.3 进程同步</h3><ul><li><p>为什么需要进程间同步</p><ul><li><p>生产者-消费者问题</p><ul><li>生产者进程将生产的产品提供给消费者进程进行消费</li><li>生产者进程和消费者进程可以并发执行</li><li>在两者之间设置了一个具有n个缓冲区的缓冲池</li><li>生产者将产品缓冲区中，消费者进程从缓冲区取走产品消费</li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801163907.jpg" alt=""></p><ul><li>单从生产者程序或消费者程序去看是没问题的</li><li>单两者并发执行时就可能出差错</li><li>临界资源：缓存区</li></ul></li><li><p>哲学家进餐问题</p><ul><li>有五个哲学家，他们的生活方式是交替地进行思考和进餐</li><li>哲学家们共同使用一张圆桌，分别坐在周围的五张椅子上</li><li>在圆桌上有五个碗和五支筷子。平时哲学家们只进行思考，饥饿时则试图取靠近他们的左、右两支筷子</li><li>只有两支筷子都被他拿到的时候才能进餐</li><li>进餐完毕之后，放下左右筷子继续思考</li><li>五个哲学家同时拿起左边筷子</li><li>五个哲学家都等待右边筷子释放</li><li>五个哲学家饿死</li><li>临界资源：筷子</li></ul></li><li><p>问题的根源</p><ul><li>根源问题是：彼此相互之间没有通信</li><li>如果生产者通知消费者我已经完成一件生产</li><li>哲学家向旁边哲学家说我要进餐了</li></ul></li><li><p>进程同步的目的</p><ul><li>对竞争资源在多进程间进行使用次序的协调</li><li>使得并发执行的多个进程之间可以有效使用资源和相互合作</li></ul></li><li><p>临界资源</p><ul><li>临界资源指的是一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源。</li><li>当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使<br>用共享资源。</li></ul></li></ul></li><li><p>进程间同步的原则</p><ul><li>空闲让进：资源无占用，允许使用</li><li>忙则等待：资源有占用，请求进程等待</li><li>有限等待：保证有限等待时间能够使用资源</li><li>让权等待：等待时，进程需要让出CPU</li></ul></li><li><p>进程间同步的方法</p><ul><li>消息队列</li><li>共享存储</li><li>信号量</li></ul></li><li><p>线程同步</p><ul><li>进程的线程共享进程资源</li><li>当多个线程并发使用进程资源时，也需要同步</li><li>线程间同步的方法<ul><li>互斥量</li><li>读写锁</li><li>自旋锁</li><li>条件变量</li></ul></li></ul></li></ul><h3 id="2-4-Linux的进程管理"><a href="#2-4-Linux的进程管理" class="headerlink" title="2.4 Linux的进程管理"></a>2.4 Linux的进程管理</h3><ul><li><p>进程的类型</p><ul><li>前台进程<ul><li>前台进程就是具有终端，可以和用户交互的进程</li></ul></li><li>后台进程<ul><li>与前台进程相对，没有占用终端的就是后台进程</li><li>后台程序基本上不和用户交互，优先级比前台进程低</li><li>将需要执行的命令以“&amp;”符号结束</li></ul></li><li>守护进程<ul><li>守护(daemon)进程是特殊的后台进程</li><li>很多守护进程在系统引导的时候启动，一直运行直到系统关闭</li><li>Linux有很多典型的守护进程</li><li>进程名字以“d”结尾的一般都是守护进程<ul><li>crond</li><li>httpd</li><li>sshd</li><li>mysqld</li></ul></li></ul></li></ul></li><li><p>进程的标记</p><ul><li><p>进程ID</p><ul><li>进程ID是进程的唯一标记，每个进程拥有不同的ID</li><li>进程ID表现为一个非负整数，最大值由操作系统限定</li><li>top命令查看系统中的所有进程信息</li><li>ID为0的进程为idle进程，是系统创建的第一个进程</li><li>ID为1的进程为init进程，是0号进程的子进程，完成系统初始化</li><li>Init进程是所有用户进程的祖先进程</li></ul></li><li><p>进程的状态标记</p><ul><li>man ps 命令查看用户命令帮助文档</li></ul><table><thead><tr><th>状态符号</th><th>状态说明</th></tr></thead><tbody><tr><td>R</td><td>(TASK_RUNNING)，进程正处于运行状态</td></tr><tr><td>S</td><td>(TASK_INTERRUPTIBLE)，进程正处于睡眠状态</td></tr><tr><td>D</td><td>(TASK_UNINTERRUPTIBLE)，进程正在处于IO等待的睡眠状态</td></tr><tr><td>T</td><td>(TASK_STOPPED)，进程正处于暂停状态</td></tr><tr><td>Z</td><td>(TASK_DEAD or EXIT_ZOMBIE)，进程正处于退出状态，或僵尸进程</td></tr></tbody></table></li><li><p>父子进程</p><ul><li>操作系统提供fork函数接口创建进程</li><li>父子进程关系:进程A调用fork函数创建进程B,进程A就是进程B的父进程</li><li>父子进程关系可以通过pstree命令查看</li></ul></li></ul></li><li><p>操作进程的相关命令</p><ul><li>ps命令<ul><li>ps命令常用于显示当前进程的状态</li><li>ps命令常配合aux参数或ef参数和grep命令检索特定进程</li></ul></li><li>jobs<ul><li>只有(SIGKILL 9)信号可以无条件终止进程，其他信号进程有权忽略</li></ul></li><li>nohup<ul><li>不挂断地运行命令</li></ul></li><li>fg/bg命令<ul><li>fg命令将一个后台命令调换至前台终端继续执行</li><li>bg命令将一个后台暂停的命令变成继续执行</li><li>ctrl+z将前台工作暂停</li></ul></li><li>kill<ul><li>kill命令发送指定信号给进程</li><li>kill –l 可以查看操作系统支持的信号</li><li>只有(SIGKILL 9)信号可以无条件终止进程，其他信号进程有权忽略</li></ul></li></ul></li></ul><h2 id="3-作业管理"><a href="#3-作业管理" class="headerlink" title="3.作业管理"></a>3.作业管理</h2><h3 id="3-1-进程调度"><a href="#3-1-进程调度" class="headerlink" title="3.1 进程调度"></a>3.1 进程调度</h3><ul><li><p>进程调度是指计算机通过决策决定哪个就绪进程可以获得CPU使用权</p></li><li><p>保留旧进程的运行信息，请出旧进程（收拾包袱）</p></li><li><p>选择新进程，准备运行环境并分配CPU（新进驻）</p></li><li><p>调度机制</p><ul><li>就绪队列的委派机制<ul><li>将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程</li></ul></li><li>选择运行进程的委派机制<ul><li>调度程序以一定的策略选择就绪进程，将CPU资源分配给它</li></ul></li><li>新老进程的上下文切换机制<ul><li>保存当前进程的上下文信息，装入被委派执行进程的运行上下文</li><li>老进程的上下文存入主存</li><li>新进程的上下文装载到高速缓存中</li></ul></li></ul></li><li><p>调度方式</p><ul><li>非抢占式的调度<ul><li>处理器一旦分配给某个进程，就让该进程一直使用下去</li><li>调度程序不以任何原因抢占正在被使用的处理器</li><li>直到进程完成工作或因为IO阻塞才会让出处理器</li></ul></li><li>抢占式的调度<ul><li>允许调度程序以一定的策略暂停当前运行的进程</li><li>保存好旧进程的上下文信息，分配处理器给新进程</li></ul></li></ul><table><thead><tr><th></th><th>抢占式调度</th><th>抢占式调度</th></tr></thead><tbody><tr><td>系统开销</td><td>频繁切换，开销大</td><td>切换次数少，开销小</td></tr><tr><td>公平性</td><td>相对公平</td><td>不公平</td></tr><tr><td>应用</td><td>通用系统</td><td>专用系统</td></tr></tbody></table></li><li><p>调度算法</p><ul><li>先来先服务调度算法<ul><li>从就绪队列按照顺序从队列头开始调度</li></ul></li><li>短进程优先调度算法<ul><li>调度程序优先选择就绪队列中估计运行时间最短的进程</li><li>短进程优先调度算法不利于长作业进程的执行</li></ul></li><li>高优先权优先调度算法<ul><li>进程附带优先权，调度程序优先选择权重高的进程</li><li>高优先权优先调度算法使得紧迫的任务可以优先处理</li><li>前台进程优先级高于后台进程</li></ul></li><li>时间片轮转算法<ul><li>按先来先服务的原则排列就绪进程</li><li>每次从队列头部取出待执行进程，分配一个时间片执行</li><li>是相对公平的调度算法，但不能保证及时响应用户</li></ul></li></ul></li></ul><h3 id="3-2-死锁"><a href="#3-2-死锁" class="headerlink" title="3.2 死锁"></a>3.2 死锁</h3><ul><li><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p></li><li><p>死锁的产生</p><ul><li><p>基本原因</p><ul><li>竞争资源<ul><li>共享资源数量不满足各个进程需求</li><li>各个进程之间发生资源竞争导致死锁</li></ul></li><li>进程调度顺序不当<ul><li>调度顺序导致共享资源被多个进程互相持有无法释放，可以优先满足进程A的调度再调度B</li></ul></li></ul></li><li><p>必要条件</p><ul><li>互斥条件<ul><li>进程对资源的使用是排他性的使用</li><li>某资源只能由一个进程使用，其他进程需要使用只能等待</li></ul></li><li>请求保持条件<ul><li>进程至少保持一个资源，又提出新的资源请求</li><li>新资源被占用，请求被阻塞</li><li>被阻塞的进程不释放自己保持的资源</li></ul></li><li>不可剥夺条件<ul><li>进程获得的资源在未完成使用前不能被剥夺</li><li>获得的资源只能由进程自身释放</li></ul></li><li>环路等待条件<ul><li>发生死锁时，必然存在进程-资源环形链</li><li>P1(R1)-&gt; P2(R2)-&gt;P3(R3-&gt;)P4(R4) -&gt;P1(R1)</li></ul></li></ul></li></ul></li><li><p>死锁的处理</p><ul><li><p>预防死锁的方法-破坏必要条件</p><ul><li>摒弃请求保持条件<ul><li>系统规定进程运行之前，一次性申请所有需要的资源</li><li>进程在运行期间不会提出资源请求，从而摒弃请求保持条件</li></ul></li><li>摒弃不可剥夺条件<ul><li>当一个进程请求新的资源得不到满足时，必须释放占有的资源</li><li>进程运行时占有的资源可以被释放，意味着可以被剥夺</li></ul></li><li>摒弃环路等待条件<ul><li>可用资源线性排序，申请必须按照需要递增申请</li><li>线性申请不再形成环路，从而摒弃了环路等待条件，A B C D E</li></ul></li></ul></li><li><p>银行家算法</p><ul><li>是一个可操作的著名的避免死锁的算法</li><li>以银行借贷系统分配策略为基础的算法</li><li>客户申请的贷款是有限的，每次申请需声明最大资金量</li><li>银行家在能够满足贷款时，都应该给用户贷款</li><li>客户在使用贷款后，能够及时归还贷款用来满足其它客户</li><li>已分配资源表 </li></ul><table><thead><tr><th align="center"></th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th></tr></thead><tbody><tr><td align="center">P1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">4</td></tr><tr><td align="center">P2</td><td align="center">1</td><td align="center">4</td><td align="center">3</td><td align="center">2</td></tr><tr><td align="center">P3</td><td align="center">1</td><td align="center">3</td><td align="center">5</td><td align="center">4</td></tr><tr><td align="center">P4</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><ul><li>所需资源表</li></ul><table><thead><tr><th align="center"></th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th></tr></thead><tbody><tr><td align="center">P1</td><td align="center">0</td><td align="center">6</td><td align="center">5</td><td align="center">6</td></tr><tr><td align="center">P2</td><td align="center">1</td><td align="center">9</td><td align="center">4</td><td align="center">2</td></tr><tr><td align="center">P3</td><td align="center">1</td><td align="center">3</td><td align="center">5</td><td align="center">6</td></tr><tr><td align="center">P4</td><td align="center">1</td><td align="center">7</td><td align="center">5</td><td align="center">0</td></tr></tbody></table><ul><li>可分配资源表</li></ul><table><thead><tr><th align="center"></th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">1</td><td align="center">5</td><td align="center">2</td><td align="center">0</td></tr></tbody></table><ul><li>还需分配资源表</li><li>通过可分配资源表看它能够满足哪一个进程所需就把可分配资源给谁，不满足的就不执行知道有资源能够满足任何一个为止</li><li>所以P2会先获得资源</li></ul><table><thead><tr><th align="center"></th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th></tr></thead><tbody><tr><td align="center">P1</td><td align="center">0</td><td align="center">6</td><td align="center">4</td><td align="center">2</td></tr><tr><td align="center">P2</td><td align="center">0</td><td align="center">5</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">P3</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">2</td></tr><tr><td align="center">P4</td><td align="center">0</td><td align="center">7</td><td align="center">5</td><td align="center">0</td></tr></tbody></table></li></ul></li></ul><h2 id="4-存储管理"><a href="#4-存储管理" class="headerlink" title="4.存储管理"></a>4.存储管理</h2><h3 id="4-1-计算机进行存储管理的必要性"><a href="#4-1-计算机进行存储管理的必要性" class="headerlink" title="4.1 计算机进行存储管理的必要性"></a>4.1 计算机进行存储管理的必要性</h3><ul><li>早期计算机编程并不需要过多的存储管理</li><li>随着计算机和程序越来越复杂，存储管理成为必要</li><li>确保计算机有足够的内存处理数据</li><li>确保程序可以从可用内存中获取一部分内存使用</li><li>确保程序可以归还使用后的内存以供其他程序使用</li></ul><h3 id="4-2-内存的分配过程"><a href="#4-2-内存的分配过程" class="headerlink" title="4.2 内存的分配过程"></a>4.2 内存的分配过程</h3><ul><li><p>分配方法</p></li><li><p>单一连续分配</p><ul><li>单一连续分配是最简单的内存分配方式</li><li>只能在单用户、单进程的操作系统中使用</li><li>分为系统区，用户区</li></ul></li><li><p>固定分区分配</p><ul><li>固定分区分配是支持多道程序的最简单存储分配方式</li><li>内存空间被划分为若干固定大小的区域</li><li>每个分区只提供给一个程序使用，互不干扰</li></ul></li><li><p>动态分区分配（常用）</p><ul><li>根据进程实际需要，动态分配内存空间</li><li>相关数据结构、分配算法</li><li>动态分区空闲表数据结构，1：已使用，0：未使用</li></ul><table><thead><tr><th>分区</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>标记</td><td>0</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><ul><li>动态分区空闲链数据结构<ul><li>采用双向链表将内存块链接起来，连续的空闲区可以合并在一个链表节点里</li><li>节点需记录可存储的容量</li></ul></li><li>动态分区分配算法<ul><li>首次适应算法(FF算法)<ul><li>分配内存时从开始顺序查找适合内存区</li><li>若没有合适的空闲区，则该次分配失败</li><li>每次从头部开始，使得头部地址空间不断被划分</li><li>循环适应算法，每次分配不从头开始，从上一次结束的地方开始分配</li></ul></li><li>最佳适应算法(BF算法)<ul><li>最佳适应算法要求空闲区链表按照容量大小排序</li><li>遍历空闲区链表找到最佳合适空闲区</li></ul></li><li>快速适应算法(QF算法)<ul><li>快速适应算法要求有多个空闲区链表</li><li>每个空闲区链表存储一种容量的空闲区</li></ul></li></ul></li></ul></li></ul><h3 id="4-3-内存的回收过程"><a href="#4-3-内存的回收过程" class="headerlink" title="4.3 内存的回收过程"></a>4.3 内存的回收过程</h3><ul><li>存在回收内存的四种情况<ul><li>回收区与空闲区链接在一起并且链接在后面<ul><li>不需要新建空闲链表节点</li><li>只需要把空闲区1的容量增大为空闲区即可</li></ul></li><li>回收区与空闲区链接在一起并且链接在前面<ul><li>将回收区与空闲区合并</li><li>新的空闲区使用回收区的地址</li></ul></li><li>回收区与空闲区链接在一起并且链接在中间<ul><li>将空闲区1、空闲区2和回收区合并</li><li>新的空闲区使用空闲区1的地址</li></ul></li><li>未链接空闲区，单一的回收区<ul><li>为回收区创建新的空闲节点</li><li>插入到相应的空闲区链表中去</li></ul></li></ul></li></ul><h3 id="4-4-进程的存储管理"><a href="#4-4-进程的存储管理" class="headerlink" title="4.4 进程的存储管理"></a>4.4 进程的存储管理</h3><ul><li><p>页式存储管理</p><ul><li>字块是相对物理设备的定义，页面则是相对逻辑空间的定义</li><li>将进程逻辑空间等分成若干大小的页面</li><li>相应的把物理内存空间分成与页面大小的物理块</li><li>以页面为单位把进程空间装进物理内存中分散的物理块</li><li>页面大小应该适中，过大难以分配，过小内存碎片过多</li><li>页面大小通常是512B~8K</li><li><strong>页表</strong>：记录进程逻辑空间与物理空间的映射，表示为 [页面编号，字块编号]</li><li><strong>页地址</strong>：[地址，页内偏移]</li><li><strong>问题</strong>：现代计算机系统中，可以支持非常大的逻辑地址空间（2^32~2^64），这样，页表就变得非常大，要占用非常大的内存空间，如，具有32位逻辑地址空间的分页系统，规定页面大小为4KB，则在每个进程页表中的页表项可达1M(2^20)个，如果每个页表项占用1Byte，故每个进程仅仅页表就要占用1MB的内存空间<ul><li>2^32/2^12=2^20=1M个页表项</li></ul></li><li><strong>多级页表</strong>：根页表的字块存的是子页表的地址，在运行时可以按需加载子页表</li><li><strong>不足</strong>：有一段连续的逻辑分布在多个页面中，将大大降低执行效率</li></ul></li><li><p>段式存储管理</p><ul><li>将进程逻辑空间划分成若干段（非等分）</li><li>段的长度由连续逻辑的长度决定</li><li>主函数MAIN、子程序段X、子函数Y等</li><li><strong>段表</strong>：[段号 ,基址. 段长]</li><li><strong>段地址</strong>：[段号, 段内偏移]</li></ul></li><li><p>页式存储管理与段式存储管理的对比</p><ul><li>段式存储和页式存储都离散地管理了进程的逻辑空间</li><li>页是物理单位，段是逻辑单位</li><li>分页是为了合理利用空间，分段是满足用户要求</li><li>页大小由硬件固定，段长度可动态变化</li><li>页表信息是一维的，段表信息是二维的</li></ul></li><li><p>段页式存储管理</p><ul><li>分页可以有效提高内存利用率（虽然说存在页内碎片）</li><li>分段可以更好满足用户需求，因为逻辑可以通过用户来写</li><li>两者结合，形成段页式存储管理</li><li>先将逻辑空间按段式管理分成若干段</li><li>再把段内空间按页式管理等分成若干页</li><li><strong>段页地址</strong>：[段号, 段内页号. 页内地址]</li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801164213.jpg" alt=""></p></li></ul><h3 id="4-5-虚拟内存"><a href="#4-5-虚拟内存" class="headerlink" title="4.5 虚拟内存"></a>4.5 虚拟内存</h3><ul><li>虚拟内存概述<ul><li>有些进程实际需要的内存很大，超过物理内存的容量</li><li>多道程序设计，使得每个进程可用物理内存更加稀缺</li><li>不可能无限增加物理内存，物理内存总有不够的时候</li><li>虚拟内存是操作系统内存管理的关键技术</li><li>使得多道程序运行和大程序运行成为现实</li><li>把程序使用内存划分，将部分暂时不使用的内存放置在辅存</li><li>虚拟内存实际是对物理内存的补充，速度接近于内存，成本接近于辅存</li></ul></li><li>程序的局部性原理<ul><li>局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。</li><li>程序运行时，无需全部装入内存，装载部分即可</li><li>如果访问页不在内存，则发出缺页中断，发起页面置换</li><li>从用户层面看，程序拥有很大的空间，即是虚拟内存</li></ul></li><li>虚拟内存的置换</li><li>替换策略发生在Cache-主存层次、主存-辅存层次<ul><li>Cache-主存层次的替换策略主要是为了解决速度问题</li><li>主存-辅存层次主要是为了解决容量问题</li><li>置换时机<ul><li>高速缓存的替换时机<ul><li>缓存没有数据，需要从主存载入所需数据</li></ul></li><li>主存页面的替换时机<ul><li>主存缺页，需要从辅存载入页面数据</li></ul></li></ul></li><li>置换算法<ul><li>先进先出算法(FIFO)<ul><li>把主存看做是一个先进先出的队列</li><li>优先替换最先进入队列的字块</li></ul></li><li>最不经常使用算法(LFU)<ul><li>优先淘汰最不经常使用的字块</li><li>需要额外的空间记录字块的使用频率</li></ul></li><li>最近最少使用算法(LRU)<ul><li>优先淘汰一段时间内没有使用的字块</li><li>如果正在使用的字块在缓存就将其移到表头，保证链表头部节点是最近使用的</li><li>有多种实现方法，一般使用双向链表</li></ul></li></ul></li></ul></li></ul><h3 id="4-6-Linux的存储管理"><a href="#4-6-Linux的存储管理" class="headerlink" title="4.6 Linux的存储管理"></a>4.6 Linux的存储管理</h3><ul><li><p>页内碎片 </p><ul><li>内部碎片是已经被分配出去（能明确指出属于哪个进程）的内存空间大于请求所需的内存空间，不能被利用的内存空间就是内部碎片。</li></ul></li><li><p>页外碎片</p><ul><li>外部碎片是指还没有分配出去（不属于任何进程），但是由于大小而无法分配给申请内存空间的新进程的内存空闲块。</li></ul></li><li><p>Buddy内存管理算法</p><ul><li>Buddy算法是经典的内存管理算法</li><li>算法基于计算机处理二进制的优势具有极高的效率</li><li>算法主要是为了解决内存外碎片的问题</li><li>实际是将内存外碎片问题 转移成内存内碎片问题</li><li>努力让内存分配与相邻内存合并能快速进行</li><li>内存分配原则<ul><li>向上取整为2的幂大小</li><li>70k→128k</li><li>129k→256k</li><li>666k→1024k</li></ul></li><li>伙伴系统<ul><li>“伙伴”指的是内存的“伙伴”</li><li>一片连续内存的“伙伴”是相邻的另一片大小一样的连续内存</li></ul></li><li>分配过程<ul><li>创建一系列空闲块链表，每一种都是2的幂</li><li>假设存储空间有1M大小，分配100k内存</li><li>100k向上取2的幂=128k</li><li>查询是否有128k空闲内存块？</li><li>没有！查询是否有256k空闲内存块？</li><li>没有！查询是否有512k空闲内存块？</li><li>没有！查询是否有1M空闲内存块？</li><li>有，摘下1M空闲内存块，分配出去</li><li>拆下512k放在512k的空闲链表，其余的分配出去</li><li>拆下256k放在256k的空闲链表，其余的分配出去</li><li>拆下128k放在128k的空闲链表，其余的分配出去</li><li>分配完毕</li></ul></li><li>回收过程<ul><li>判断刚才分配的内存伙伴在空闲链表上吗？</li><li>在！移除伙伴，合并为256k空闲内存，判断</li><li>在！移除伙伴，合并为512k空闲内存，判断</li><li>在！移除伙伴，合并为1M空闲内存</li><li>插入1M空闲链表，回收完成</li></ul></li></ul></li><li><p>Linux交换空间</p><ul><li>交换空间(Swap)是磁盘的一个分区</li><li>Linux物理内存满时，会把一些内存交换至Swap空间</li><li>Swap空间是初始化系统时配置的</li><li>top命令可以查看交换空间的分配情况</li><li>主要用途：<ul><li>冷启动内存依赖</li><li>系统睡眠依赖</li><li>大进程空间依赖</li></ul></li><li>交换空间VS虚拟内存<ul><li>Swap空间是操作系统概念</li><li>Swap空间解决系统物理内存不足问题</li><li>Swap空间存在于磁盘</li><li>Swap空间与主存发生置换</li><li>虚拟内存是进程概念</li><li>虚拟内存解决进程物理内存不足问题</li><li>虚拟内存存在于磁盘</li><li>虚拟内存与主存发生置换</li></ul></li></ul></li></ul><h2 id="5-文件管理"><a href="#5-文件管理" class="headerlink" title="5.文件管理"></a>5.文件管理</h2><h3 id="5-1-操作系统的文件管理"><a href="#5-1-操作系统的文件管理" class="headerlink" title="5.1 操作系统的文件管理"></a>5.1 操作系统的文件管理</h3><ul><li><p>文件的逻辑结构</p><ul><li>逻辑结构的文件类型<ul><li>有结构文件<ul><li>文本文件、 文档 、媒体文件</li><li>文件内容由定长记录和可变长记录组成</li><li>定长记录存储文件格式、文件描述等结构化数据项</li><li>可变长记录存储文件具体内容</li><li>例如：PNG文件标记–PNG数据块–文件结束标记</li></ul></li><li>无结构文件<ul><li>exe文件、 dll链接库文件、 so文件</li><li>二进制文件 、链接库</li><li>也称为流式文件</li><li>文件内容长度以字节为单位</li></ul></li></ul></li><li>顺序文件<ul><li>顺序文件是指按顺序存放在存储介质中的文件</li><li>磁带的存储特性使得磁带文件只能存储顺序文件</li><li>顺序文件是所有逻辑文件当中存储效率最高的</li><li>顺序文件的增删改效率低</li></ul></li><li>索引文件<ul><li>可变长文件不适合使用顺序文件格式存储</li><li>索引文件是为了解决可变长文件存储而发明的一种文件格式</li><li>索引文件需要配合索引表完成存储的操作</li><li>索引表：[键 ,逻辑地址]</li></ul></li></ul></li><li><p>辅存的存储空间分配</p><ul><li>辅存的分配方式<ul><li>连续分配<ul><li>顺序读取文件内容非常容易，速度很快</li><li>对存储要求高，要求满足容量的连续存储空间</li></ul></li><li>链接分配<ul><li>链接分配可以将文件存储在离散的盘块中<br>需要额外的存储空间存储文件的盘块链接顺序</li><li>隐式链接 <ul><li>隐式分配的下一个链接指向存储在当前盘块内</li><li>隐式分配适合顺序访问，随机访问效率很低</li><li>可靠性差，任何一个链接出问题都影响整个文件</li></ul></li><li>显式链接<ul><li>FAT( File Allocation Table)  [物理块 ,下一盘块]</li><li>不支持高效的直接存储（FAT记录项多）</li><li>检索时FAT表占用较大的存储空间（需要将整个FAT加载到内存）</li></ul></li></ul></li><li>索引分配<ul><li>把文件的所有盘块集中存储（索引）</li><li>读取某个文件时，将文件索引读取进内存即可</li><li>每个文件拥有一个索引块，记录所有盘块信息</li><li>索引分配方式支持直接访问盘块</li><li>文件较大时，索引分配方式具有明显优势</li></ul></li></ul></li></ul></li><li><p>辅存的存储空间管理</p><ul><li><p>空闲表</p><ul><li>[序号, 第一个空闲盘块号, 空闲盘块数]</li><li>空闲盘区的分配与内存分配类似</li><li>首次适应算法、循环适应算法等</li><li>回收过程也与内存回收类似</li></ul></li><li><p>空闲链表 </p><ul><li>空闲链表法把所有空闲盘区组成一个空闲链表</li><li>每个链表节点存储空闲盘块和空闲的数目</li></ul></li><li><p>位示图</p><ul><li>位示图维护成本很低</li><li>位示图可以非常容易找到空闲盘块</li><li>位示图使用0/1比特位，占用空间很小</li><li>0：未使用，1：已使用</li></ul><table><thead><tr><th align="center">盘块/磁道</th><th align="center">1</th><th align="center">2</th><th align="center">3</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">2</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr></tbody></table></li></ul></li><li><p>目录管理</p><ul><li>目录树：<ul><li>任何文件或目录都只有唯一路径</li></ul></li><li>文件描述信息<ul><li>文件标识符 文件类型 文件权限 文件物理地址 文件长度 文件连接计数 文件存取时间 索引节点编号 文件状态 访问计数 链接指针</li></ul></li></ul></li></ul><h3 id="5-2-Linux文件的基本操作"><a href="#5-2-Linux文件的基本操作" class="headerlink" title="5.2 Linux文件的基本操作"></a>5.2 Linux文件的基本操作</h3><ul><li><p>Linux目录</p><ul><li>Linux一切皆文件</li><li>常用目录：/bin /etc /home /usr /opt /proc /dev /mnt /lib /var …</li></ul><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td>/bin</td><td>存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里</td></tr><tr><td>/etc</td><td>存放系统管理和配置文件</td></tr><tr><td>/home</td><td>存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user</td></tr><tr><td>/usr</td><td>用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录</td></tr><tr><td>/opt</td><td>额外安装的可选应用程序包所放置的位置</td></tr><tr><td>/proc</td><td>虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。</td></tr><tr><td>/root</td><td>超级用户（系统管理员）的主目录</td></tr><tr><td>/sbin</td><td>存放二进制可执行文件，只有root才能访问</td></tr><tr><td>/dev</td><td>用于存放设备文件</td></tr><tr><td>/mnt</td><td>系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。</td></tr><tr><td>/boot</td><td>存放用于系统引导时使用的各种文件</td></tr><tr><td>/lib</td><td>存放跟文件系统中的程序运行所需要的共享库及内核模块</td></tr><tr><td>/var</td><td>用于存放运行时需要改变数据的文件</td></tr></tbody></table><ul><li>相对路径：相对当前目录开始的目录</li><li>绝对路径：相对根目录开始的目录</li></ul></li><li><p>Linux文件常用操作</p><ul><li>创建：<ul><li>touch file </li><li>vim file2 创建并编辑file2</li><li>mkdir dir1 创建文件夹dir1</li></ul></li><li>删除<ul><li>rm file </li><li>rm -r dir1/ 递归删除文件夹dir1</li></ul></li><li>读取<ul><li>cat file2</li></ul></li><li>写入<ul><li>vim file2 创建并编辑file2</li></ul></li></ul></li><li><p>文件类型</p><ul><li>普通文件(-)</li><li>目录文件(d) </li><li>符号链接(l) </li><li>设备文件(b、 c)</li><li>套接字(s) </li><li>FIFO(p)</li></ul></li><li><p>Linux的文件系统</p><ul><li><p>文件系统概览</p><ul><li>FAT<ul><li>FAT(File Allocation Table)</li><li>FAT16、 FAT32等，微软Dos/Windows使用的文件系统</li></ul></li></ul></li><li><p>使用一张表保存盘块的信息</p><ul><li>NTFS</li></ul></li><li><p>NTFS (New Technology File System)</p><ul><li>WindowsNT环境的文件系统</li><li>NTFS对FAT进行了改进，取代了旧的文件系统<ul><li>EXT2/3/4</li></ul></li><li>EXT(Extended file system)：扩展文件系统</li><li>Linux的文件系统</li><li>EXT2/3/4 数字表示第几代</li></ul></li><li><p>Ext文件系统</p><ul><li>Boot Sector：启动扇区，安装开机管理程序</li></ul></li><li><p>Block Group：块组，存储数据的实际位置</p><ul><li><p>Boot Sector</p></li><li><p>Block Group</p><ul><li>SuperBlock<ul><li>记录整个文件系统相关信息的地方</li><li>Block和Inode的使用情况</li><li>时间信息、控制信息等</li></ul></li><li>Inode Bitmap<ul><li>Inode的位示图</li><li>记录已分配的Inode和未分配的Inode</li></ul></li><li>Block Bitmap<ul><li>功能与Inode bitmap类似</li><li>记录Data block的使用情况</li></ul></li><li>Inode Table<ul><li>存放文件Inode的地方</li><li>每一个文件（目录）都有一个Inode</li><li>是每一个文件（目录）的索引节点</li><li>Inode：<ul><li>文件类型 文件权限 文件物理地址 文件长度 文件连接计数 文件存取时间 索引节点编号 文件状态 访问计数 链接指针 …</li><li>文件名不是存放在Inode节点上的，而是存放在目录的Inode节点</li><li>列出目录文件的时候无需加载文件的Inode</li></ul></li></ul></li><li>Data Block<ul><li>Data block是存放文件内容的地方</li><li>每个block都有唯一的编号</li><li>文件的block记录在文件的Inode上</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnhudx17c4j30ku0b9dhl.jpg" alt=""></p></li></ul></li></ul></li></ul><h2 id="6-设备管理"><a href="#6-设备管理" class="headerlink" title="6.设备管理"></a>6.设备管理</h2><ul><li><p>广义的IO设备</p><ul><li>对CPU而言，凡是对CPU进行数据输入的都</li><li>对CPU而言，凡是CPU进行数据输出的都是输出设备是输入设备</li></ul></li><li><p>广义的IIO设备分类</p><ul><li>使用特性分类<ul><li>存储设备： U盘 内存 磁盘 </li><li>交互IO设备：键盘 显示器 鼠标</li></ul></li><li>信息交换的单位<ul><li>块设备 ：磁盘 SD卡 </li><li>字符设备：打印机 Shell终端</li></ul></li><li>设备共享属性<ul><li>独占设备 </li><li>共享设备 </li><li>虚拟设备</li></ul></li><li>传输速率<ul><li>低速设备 </li><li>中速设备 </li><li>高速设备</li></ul></li></ul></li><li><p>IO设备的缓冲区</p><ul><li>背景：CPU与IO设备的速率不匹配</li><li>减少CPU处理IO请求的频率</li><li>提高CPU与IO设备之间的并行性</li><li>专用缓冲区只适用于特定的IO进程</li><li>当这样的IO进程比较多时，对内存的消耗也很大</li><li>操作系统划出可供多个进程使用的公共缓冲区，称之为缓冲池</li></ul></li><li><p>SPOOLing技术</p><ul><li>虚拟设备技术</li><li>是关于慢速字符设备如何与计算机主机交换信息的一种技术</li><li>利用高速共享设备将低速的独享设备模拟为高速的共享设备</li><li>逻辑上，系统为每一个用户都分配了一台独立的高速独享设备</li><li>SPOOLing技术把同步调用低速设备改为异步调用</li><li>在输入、输出之间增加了排队转储环节（输入井、输出井）</li><li>SPOOLing负责输入（出）井与低速设备之间的调度</li><li>逻辑上，进程直接与高速设备交互，减少了进程的等待时间</li></ul></li></ul><h2 id="7-实践"><a href="#7-实践" class="headerlink" title="7.实践"></a>7.实践</h2><h3 id="7-1-线程同步实践"><a href="#7-1-线程同步实践" class="headerlink" title="7.1 线程同步实践"></a>7.1 线程同步实践</h3><ul><li>互斥量<ul><li>两个线程的指令交叉执行导致了同步问题</li><li>互斥量可以保证先后执行</li><li>原子性<ul><li>这一系列操作要么全部执行完成，要么全部没有执行</li><li>原子性是指一系列操作不可被中断的特性</li><li>不存在部分执行部分未执行的情况 </li></ul></li><li>互斥量（互斥锁），处于两态之一的变量：解锁和加锁</li><li>互斥量是最简单的线程同步的方法</li><li>两个状态可以保证资源访问的串行</li><li>开发者可以直接使用API完成资源的加锁、解锁操作</li><li>操作系统直接提供了互斥量的API<ul><li>C 语言<ul><li>pthread_mutex_lock</li><li>pthread_mutex_t</li><li>pthread_mutex_unlock</li></ul></li><li>Java<ul><li>synchronized</li></ul></li></ul></li></ul></li><li>自旋锁<ul><li>和互斥锁有什么不一样的？</li><li>使用自旋锁的线程会反复检查锁变量是否可用</li><li>自旋锁也是一种多线程同步的变量</li><li>自旋锁不会让出CPU，是一种忙等待状态</li><li>死循环等待锁被释放</li><li>操作系统内部很多地方使用的是自旋锁</li><li>自旋锁避免了进程或线程上下文切换的开销</li><li>自旋锁不适合在单核CPU使用，因为自旋锁不会让出CPU</li><li>api<ul><li>pthread_spinlock_t</li><li>pthread_ spinlock <em>lock</em></li><li>pthread_ spinlock _unlock</li></ul></li></ul></li><li>读写锁<ul><li>读取的时候并不会改变临界资源的值</li><li>临界资源多读少写</li><li>是否存在效率更高的同步方法？</li><li>允许多个读者同时访问资源以提高读性能</li><li>读写锁是一种特殊的自旋锁</li><li>对于写操作则是互斥的</li><li>API<ul><li>pthread_rwlock_t</li><li>pthread_rwlock_rdlock（读锁）</li><li>pthread_rwlock_wrlock（写锁）</li></ul></li><li>互斥量、自旋锁、读写锁 同步过程：等待解锁–加锁–【临界资源】–解锁</li></ul></li><li>条件变量<ul><li>条件变量允许线程睡眠，直到满足某种条件</li><li>条件变量是一种相对复杂的线程同步方法</li><li>当满足条件时，可以向该线程信号，通知唤醒</li><li>生产者消费者问题<ul><li>缓冲区满时，不允许生产者往缓冲区生产，生产者必须等待</li><li>缓冲区小于等于0时，不允许消费者消费，消费者必须等待</li><li>当生产者生产一个产品时，唤醒可能等待的消费者</li><li>当消费者消费一个产品时，唤醒可能等待的生产者</li></ul></li><li>API<ul><li>pthread_cond_t,配合互斥量使用</li><li>pthread_cond_wait(等待条件满足)</li><li>pthread_cond_signal(等待被唤醒)</li></ul></li><li>条件变量同步流程：等待解锁–加锁保护条件变量–等待条件满足被唤醒–【临界资源】–解锁</li></ul></li></ul><table><thead><tr><th>同步方法</th><th>描述</th></tr></thead><tbody><tr><td>互斥锁</td><td>最简单的一种线程同步方法，会阻塞线程</td></tr><tr><td>自旋锁</td><td>避免切换的一种线程同步方法，属于“忙等待”，不让出CPU</td></tr><tr><td>读写锁</td><td>为“读多写少” 的资源设计的线程同步方法，可以显著提高性能</td></tr><tr><td>条件变量</td><td>相对复杂的一种线程同步方法，有更灵活的使用场景</td></tr></tbody></table><h3 id="7-2-进程同步实践"><a href="#7-2-进程同步实践" class="headerlink" title="7.2 进程同步实践"></a>7.2 进程同步实践</h3><ul><li><p>使用fork系统调用创建进程</p><ul><li>fork创建的进程初始化状态与父进程一样</li><li>fork系统调用是用于创建进程的</li><li>系统会为fork的进程分配新的资源</li><li>fork会返回两次，分别返回子进程id和0</li><li>fork系统调用无参数</li><li>返回子进程id的是父进程，返回0的是子进程</li></ul></li><li><p>共享内存</p><ul><li>进程的线程共享进程资源</li><li>进程共享计算机资源</li><li>在某种程度上，多进程是共同使用物理内存的</li><li>由于操作系统的进程管理，进程间的内存空间是独立的</li><li>进程默认是不能访问进程空间之外的内存空间的</li><li>共享存储允许不相关的进程访问同一片物理内存</li><li>共享内存是两个进程之间共享和传递数据最快的方式</li><li>共享内存未提供同步机制，需要借助其他机制管理访问，比如通过一个Boolean的变量来控制是否可读可写</li><li>共享内存是高性能后台开发中最常用的进程同步方式</li><li>共享内存 使用流程<ul><li>申请共享内存 </li><li>连接到进程空间</li><li>脱离进程空间 </li><li>使用共享内存&amp;删除</li></ul></li><li>代码实现</li></ul></li><li><p>Unix域套接字</p><ul><li>域套接字是一种高级的进程间通信的方法</li><li>Unix域套接字可以用于同一机器进程间通信</li><li>套接字(socket)原是网络通信中使用的术语</li><li>Unix系统提供的域套接字提供了网络套接字类似的功能</li><li>Nginx、uWSGI</li><li>服务端<ul><li>创建套接字</li><li>绑定(bind)套接字</li><li>监听(listen)套接字</li><li>接收&amp;处理信息</li></ul></li><li>客户端<ul><li>创建套接字</li><li>连接套接字</li><li>发送信息</li></ul></li><li>代码实现</li><li>提供了单机简单可靠的进程通信同步服务</li><li>只能在单机使用，不能跨机器使用</li></ul></li></ul><h2 id="8-关于我"><a href="#8-关于我" class="headerlink" title="8.关于我"></a>8.关于我</h2><p>一个专注基础知识的十二线小码农，本着 <strong>基础，体系，实践，分享</strong> 的学习理念，在自我提升的同时分享自己的心得体会，不断完善，周而复始。</p><p><a href="http://basedev.cn/" target="_blank" rel="noopener">个人网站 basedev.cn</a>  </p><p><a href="https://github.com/jaydroid1024" target="_blank" rel="noopener">Github</a></p><p>BaseDev系列只整理点到为止的知识纲领，不求甚解；欲知其所以然者还得回归书本且付诸实践</p><h2 id="9-参考"><a href="#9-参考" class="headerlink" title="9.参考"></a>9.参考</h2><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?sid=20-h5Url-0&amp;courseId=478&amp;lagoufrom=noapp&amp;sharetype=wx_friend#/content" target="_blank" rel="noopener">重学操作系统 | 拉钩教育</a></p><p><a href="https://coding.imooc.com/class/package/355.html" target="_blank" rel="noopener">编程必备基础 | 慕课网</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 作业管理 </tag>
            
            <tag> 文件管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筑基系列-计算机基础知识小抄版</title>
      <link href="2021/05/31/computer-composition/"/>
      <url>2021/05/31/computer-composition/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/post_banner_jay.png" alt=""></p><h1 id="筑基系列-计算机基础知识小抄版"><a href="#筑基系列-计算机基础知识小抄版" class="headerlink" title="筑基系列-计算机基础知识小抄版"></a>筑基系列-计算机基础知识小抄版</h1><blockquote><p>计算机基础知识筑基三部曲：</p><ul><li><strong><a href="https://juejin.cn/post/6991367806772052004" target="_blank" rel="noopener">第一部：筑基系列-计算机基础知识小抄版</a></strong><ul><li>包括发展史、CPU、总线、存储器、指令系统、控制器、运算器、位运算等</li></ul></li><li><strong><a href="https://juejin.cn/post/6991385109509193764" target="_blank" rel="noopener">第二部：筑基系列-操作系统基础知识小抄版</a></strong><ul><li>包括进程与线程同步管理、作业管理、存储管理、虚拟内存、Linux、文件管理等</li></ul></li><li><strong><a href="https://juejin.cn/post/6991397445251334151" target="_blank" rel="noopener">第三部：筑基系列-计算机网络基础知识小抄版</a></strong><ul><li>包括OSI七层模型各层详解、IP协议、TCP\IP协议、Http协议、DNS协议等</li></ul></li></ul></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1.背景篇">1.背景篇</a><ul><li><a href="#11-计算机发展史">1.1 计算机发展史</a></li><li><a href="#12-cpu发展史">1.2 CPU发展史</a></li><li><a href="#13-32-位-vs-64-位">1.3 32 位 VS 64 位</a></li><li><a href="#14-计算机的分类">1.4 计算机的分类</a></li><li><a href="#15-计算机的体系与结构">1.5 计算机的体系与结构</a></li><li><a href="#16-程序翻译与解释">1.6 程序翻译与解释</a></li><li><a href="#17-计算机的层次">1.7 计算机的层次</a></li><li><a href="#18-计算机的计算单位">1.8 计算机的计算单位</a></li><li><a href="#19-计算机的字符与编码集">1.9 计算机的字符与编码集</a></li></ul></li><li><a href="#2.组成篇">2.组成篇</a><ul><li><a href="#21-计算机的总线">2.1 计算机的总线</a></li><li><a href="#22-计算机的输入输出设备">2.2 计算机的输入输出设备</a></li><li><a href="#23-计算机存储器">2.3 计算机存储器</a></li><li><a href="#24-主存储器与辅助存储器">2.4 主存储器与辅助存储器</a></li><li><a href="#25-高速缓存">2.5 高速缓存</a></li><li><a href="#26-计算机的指令系统">2.6 计算机的指令系统</a></li><li><a href="#27-计算机的控制器">2.7 计算机的控制器</a></li><li><a href="#28-计算机的运算器">2.8 计算机的运算器</a></li><li><a href="#29-计算机指令的执行过程">2.9 计算机指令的执行过程</a></li></ul></li><li><a href="#3.计算篇">3.计算篇</a><ul><li><a href="#31-进制运算的基础">3.1 进制运算的基础</a></li><li><a href="#32-原码反码补码">3.2 原码&amp;反码&amp;补码</a></li><li><a href="#33-定点数与浮点数">3.3 定点数与浮点数</a></li><li><a href="#34-定点数的加减法运算">3.4 定点数的加减法运算</a></li><li><a href="#35-浮点数的加减法运算">3.5 浮点数的加减法运算</a></li><li><a href="#36-浮点数的乘除法运算">3.6 浮点数的乘除法运算</a></li></ul></li><li><a href="#4.关于我">4.关于我</a></li><li><a href="#5.参考">5.参考</a></li></ul><h2 id="1-背景篇"><a href="#1-背景篇" class="headerlink" title="1.背景篇"></a>1.背景篇</h2><h3 id="1-1-计算机发展史"><a href="#1-1-计算机发展史" class="headerlink" title="1.1 计算机发展史"></a>1.1 计算机发展史</h3><ul><li>电子管计算机 (1946-1957)<ul><li>埃尼阿克(ENIAC)</li></ul></li><li>晶体管计算机(1957-1964)<ul><li>贝尔实验室、MIT林肯实验室的TX-0、PDP-1配备4k内存和显示器</li></ul></li><li>集成电路计算机 (1964-1980)<ul><li>德州仪器的工程师发明了集成电路(IC)、IBM(7094,1401) 、System/360 操作系统</li></ul></li><li>超大规模集成电路计算机 (1980-现在)<ul><li>乔布斯 Apple 和 Apple二代</li></ul></li><li>未来的计算机 <ul><li>生物计算机</li><li>量子计算机</li></ul></li></ul><h3 id="1-2-CPU发展史"><a href="#1-2-CPU发展史" class="headerlink" title="1.2 CPU发展史"></a>1.2 CPU发展史</h3><ul><li>摩尔定律<ul><li>定义：当价格不变时，集成电路中可容纳的晶体管数目约每隔 18～24 个月就会增加一倍，性能也将提升一倍。</li><li>这一定律揭示了信息技术发展的速度，但到今天，摩尔定律失效了。因为随着芯片越来越小，在尺寸和散热等方面已经挑战了人类的极限，芯片中无法再放入更多的电子元件了。</li><li>所以计算能力又开始以另一种方式发展，那就是多核心，比如一个普普通通的 NVIDA 显卡中就拥有了几百个核心，这样就可以进行大量的并发计算；另外，一个分布式的大数据集群，里面就可能有上千个核心。</li></ul></li><li>单核CPU发展史<ul><li>（1971～ 1973） 500KHz频率的微型计算机（字长8位）</li><li>（1978～ 1985） 500MHz频率的微型计算机（字长16位）</li><li>（1985～ 2000） 高于1GHz频率的微型计算机（字长32位）</li><li>（1973～ 1978） 高于1MHz频率的微型计算机（字长8位）</li><li>（2000～ 现在） 高于2GHz频率的微型计算机（字长为64位）</li></ul></li><li>多核CPU发展史<ul><li>（2005） Intel奔腾系列双核CPU、 AMD速龙系列</li><li>（2006） Intel酷睿四核CPU</li><li>Intel酷睿系列十六核CPU</li><li>Intel至强系列五十六核CPU</li></ul></li><li>CPU数字能量是如何产生的<ul><li>时间是最重要的输入：晶振</li><li>电能供给给芯片，芯片中的一种电子元件晶振（也就是石英晶体）通电后产生震荡</li><li>震荡会产生频率稳定的脉冲信号，通常这是一种高频的脉冲信号，每秒可达百万次</li><li>然后通过谐振效应发放这个信号，形成方波</li><li>再通过电子元件调整这种脉冲的频率，把脉冲信号转换为需要的频率，这就形成了驱动芯片工作的时钟信号</li><li>最后，时钟信号驱动着芯片工作，就像人体的脉搏一样，每一次脉冲到来，都让芯片的状态发生一次变化，最终存储器中的指令被一行行执行</li></ul></li></ul><h3 id="1-3-32-位-VS-64-位"><a href="#1-3-32-位-VS-64-位" class="headerlink" title="1.3 32 位 VS 64 位"></a>1.3 32 位 VS 64 位</h3><ul><li>32、64 位可以表示操作系统、软件、 CPU等</li><li>32位的容量：2^32 = 4 × 2^30 = 4𝐺𝐵 </li><li>64位的容量：2^64 = 2^34 × 2^30 = 2^34𝐺𝐵=2^24T𝐵=2^14EB=2^4EB</li><li>如果是 CPU，那么有 32 位 CPU，也有 64 位 CPU<ul><li>如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU</li><li>如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU</li><li>这里的 32 和 64，称作 CPU 的位宽</li><li>64 位 CPU 可以执行更大数字的运算，这个优势在普通应用上不明显，但是对于数值计算较多的应用就非常明显。</li><li>64 位 CPU 可以寻址更大的内存空间</li></ul></li><li>如果 32 位/64 位说的是程序，那么说的是指令是 64 位还是 32 位的。<ul><li>32 位指令在 64 位机器上执行，困难不大，可以兼容。 </li><li>如果是 64 位指令，在 32 位机器上执行就困难了，32 位的寄存器都存不下指令的参数。</li></ul></li><li>如果 32 位/64 位说的是操作系统<ul><li>操作系统也是一种程序，如果是 64 位操作系统，也就是操作系统中程序的指令都是 64 位指令，因此不能安装在 32 位机器上。</li></ul></li></ul><h3 id="1-4-计算机的分类"><a href="#1-4-计算机的分类" class="headerlink" title="1.4 计算机的分类"></a>1.4 计算机的分类</h3><ul><li>超级计算机<ul><li>功能最强</li><li>运算速度的单位是TFlop/s（1TFlop/s=每秒一万亿次浮点计算）</li><li>Intel(R) Core(TM) i7-6700K CPU @ 4.00GHz： 44.87 GFlop/s（  0.04487TFlop/s）</li><li>世界排名：Summit IBM（美国) &gt; 神威太湖之光(中国)  &gt; Sierra IBM（美国） </li><li>中国排名：神威 太湖之光 &gt; 天河二号&gt;  天河一号</li></ul></li><li>大型机 (又称大型机、大型主机、主机等)<ul><li>IBM Z9 </li><li>大型机造价高昂</li><li>去“IOE”行动 (I(IBM) O(Oracle) E(EMC)) –阿里云</li></ul></li><li>迷你计算机（服务器）<ul><li>普通服务器已经代替了传统的大型机，成为大规模企业计算的中枢</li></ul></li><li>工作站<ul><li>高端的通用微型计算机，提供比个人计算机更强大的性能</li><li>类似于普通台式电脑，体积较大，但性能强劲</li></ul></li><li>微型计算机<ul><li>麻雀虽小、五脏俱全</li><li>从构成的本质上来讲，个人计算机与前面的分类无异</li></ul></li></ul><h3 id="1-5-计算机的体系与结构"><a href="#1-5-计算机的体系与结构" class="headerlink" title="1.5 计算机的体系与结构"></a>1.5 计算机的体系与结构</h3><ul><li><p>阿兰.图灵</p><ul><li>英国(1912-1954) 数学家成逻辑学家网密肯进分析家和理论生物学家，被誉为计算机科学和人工智能之父。</li><li>图灵机</li><li>图灵测试</li><li>图灵完备</li><li>可判定性</li></ul></li><li><p>图灵机</p><ul><li><p>图灵机拥有一条无限长的纸带，纸带上是一个格子挨着一个格子，格子中可以写字符，你可以把纸带看作内存，而这些字符可以看作是内存中的数据或者程序。</p></li><li><p>图灵机有一个读写头，读写头可以读取任意格子上的字符，也可以改写任意格子的字符。</p></li><li><p>读写头上面的盒子里是一些精密的零件，包括图灵机的存储、控制单元和运算单元。</p></li><li><p>图灵通过数学证明了，一个问题如果可以拆解成图灵机的可执行步骤，那问题就是可计算的。</p></li><li><p>另一方面，图灵机定义了计算机的组成以及工作原理，但是没有给出具体的实现。</p></li></ul></li><li><p>冯诺依曼体系</p><ul><li><p>将程序指令和数据一起存储的计算机设计概念结构,现代计算机都是冯诺依曼机</p></li><li><p>能够长期记忆程序、数据、中间结果及最终运算结果的能力</p></li><li><p>能够把需要的程序和数据送至计算机中</p></li><li><p>能够具备算术、逻辑运算和数据传送等数据加工处理的能力</p></li><li><p>能够按照要求将处理结果输出给用户</p></li><li><p>冯诺依曼瓶颈：CPU和存储器速率之间的问题无法调和导致CPU经常空转等待数据传输</p></li></ul></li><li><p>冯诺依曼机组成结构</p><ul><li>输入设备<ul><li>鼠标、键盘</li></ul></li><li>输出设备<ul><li>显示器</li></ul></li><li>存储器<ul><li>CPU、内存、硬盘</li></ul></li><li>控制器<ul><li>CPU</li></ul></li><li>运算器<ul><li>CPU</li></ul></li></ul></li></ul><h3 id="1-6-程序翻译与解释"><a href="#1-6-程序翻译与解释" class="headerlink" title="1.6 程序翻译与解释"></a>1.6 程序翻译与解释</h3><ul><li><p>人类语言与计算机语言需要进行语言之间的转换</p></li><li><p>程序翻译</p><ul><li><p>L1是描述程序逻辑的高级语言</p></li><li><p>L0是计算机实际执行的低级语言</p></li><li><p>编译器：高级语言对应的编译器</p></li><li><p>程序翻译就是编译器将L1语言翻译并生成L0语言</p></li><li><p>翻译过程生成新的L0程序</p></li><li><p>通过编译器执行的相关语言</p><ul><li>C/C++</li><li>Object-C</li><li>Go</li></ul></li></ul></li><li><p>程序解释</p><ul><li><p>L1是描述程序逻辑的高级语言</p></li><li><p>L0是计算机实际执行的低级语言</p></li><li><p>解释器：使用L0语言实现的程序</p></li><li><p>程序解释的过程就是解释器将L1语言解释为L0语言</p></li><li><p>解释过程不生成新的L0程序</p></li><li><p>相关语言</p><ul><li>Python</li><li>Php</li><li>Javascript</li></ul></li></ul></li><li><p>混合型语言 </p><ul><li>Java （java程序翻译成字节码， 字节码解释成机器码）</li><li>C#</li></ul></li></ul><h3 id="1-7-计算机的层次"><a href="#1-7-计算机的层次" class="headerlink" title="1.7 计算机的层次"></a>1.7 计算机的层次</h3><ul><li>硬件逻辑层<ul><li>门、触发器等逻辑电路组成</li><li>属于电子工程的领域</li></ul></li><li>微程序机器层<ul><li>编程语言是微指令集</li><li>微指令所组成的微程序直接交由硬件执行</li><li>一般是硬件厂商公司处理该层</li></ul></li><li>传统机器层<ul><li>编程语言是CPU指令集（机器指令）</li><li>一条机器指令对应一个微程序，一个微程序对应一组微指令</li><li>编程语言和硬件是直接相关</li><li>不同架构的CPU使用不同的CPU指令集 （英特尔、AMD、x86/X86_64）</li></ul></li><li>操作系统层<ul><li>向上提供了简易的操作界面</li><li>向下对接了指令系统，管理硬件资源</li><li>操作系统层是在软件和硬件之间的适配层</li></ul></li><li>汇编语言层<ul><li>编程语言是汇编语言（PUSH DS/PUSH DS）</li><li>汇编语言可以翻译成可直接执行的机器语言</li><li>完成翻译的过程的程序就是汇编器</li></ul></li><li>高级语言层<ul><li>高级语言的类别非常多，由几百种</li><li>常见的高级语言有： Python、 Java、 C/C++、 Golang等</li></ul></li><li>应用层<ul><li>满足计算机针对某种用途而专门设计</li><li>WPS、IDE</li></ul></li></ul><h3 id="1-8-计算机的计算单位"><a href="#1-8-计算机的计算单位" class="headerlink" title="1.8 计算机的计算单位"></a>1.8 计算机的计算单位</h3><ul><li><p>容量单位</p><ul><li><p>在物理层面，高低电平记录信息</p></li><li><p>理论上只认识0/1两种状态，0/1称为bit（比特位）</p></li><li><p>0/1能够表示的内容太少了，需要更大的容量表示方法</p></li><li><p>更大的容量单位：字节、千字节、兆字节、吉字节、太字节、拍字节、艾字节</p></li><li><p>为什么网上买的移动硬盘500G，格式化之后就只剩465G了？</p><ul><li>硬盘商一般用10进位标记容量 𝟓𝟎𝟎 ∗ 𝟏𝟎𝟎𝟎^3/𝟏𝟎𝟐𝟒^3约等于𝟒𝟔𝟓</li><li>厂商采用十进制更好沟通</li></ul></li></ul></li></ul><table><thead><tr><th align="center">容量单位</th><th align="center">bit</th><th align="center">Byte</th><th align="center">KB</th><th align="center">MB</th><th align="center">GB</th><th align="center">TB</th><th align="center">PB</th><th align="center">EB</th></tr></thead><tbody><tr><td align="center">名字</td><td align="center">比特位</td><td align="center">字节</td><td align="center">千字节（kilobyte）</td><td align="center">兆字节=百万字节（megabyte）</td><td align="center">吉字节=十亿字节（GigaByte）</td><td align="center">太字节=万亿字节(terabyte)</td><td align="center">拍字节=千万亿字节（petabyte）</td><td align="center">艾字节=2^60字节（ExaByte）</td></tr><tr><td align="center">换算</td><td align="center">-</td><td align="center">8bits</td><td align="center">1024B</td><td align="center">1024K</td><td align="center">1024M</td><td align="center">1024G</td><td align="center">1024T</td><td align="center">1024P</td></tr><tr><td align="center">常见设备</td><td align="center">门电路</td><td align="center"></td><td align="center">寄存器</td><td align="center">高速缓存</td><td align="center">内存/硬盘</td><td align="center">硬盘</td><td align="center">云硬盘</td><td align="center">数据仓库</td></tr></tbody></table><ul><li>速度单位<ul><li>网络速度<ul><li>100M带宽=100M/s</li><li>为什么电信拉的100M光纤，测试峰值速度只有12M每秒？<ul><li>网络常用单位为(Mbps) </li><li>bps(bits per second):每秒传送位数 </li><li>100M/s = 100Mbps = 100Mbit/s</li><li>100Mbit/s=(100/8)MB/s=12.5MB/s</li></ul></li></ul></li><li>计算速度<ul><li>CPU的速度一般体现为CPU的时钟频率</li><li>CPU的时钟频率的单位一般是赫兹Hz（hertz）</li><li>目前主流CPU的时钟频率都在2GHz以上</li><li>Hz其实就是秒分之，并不只是描述计算机领域所专有的单位</li><li>Hz它是每秒中的周期性变动重复次数的计量</li><li>在CPU中就表示高低电瓶在每秒中变化的次数，2GHz = 2*1000^3Hz = 每秒20亿次</li></ul></li></ul></li></ul><h3 id="1-9-计算机的字符与编码集"><a href="#1-9-计算机的字符与编码集" class="headerlink" title="1.9 计算机的字符与编码集"></a>1.9 计算机的字符与编码集</h3><ul><li><p>早期英美的ASCII码</p><ul><li><p>美国信息交换标准码（American Standard Code for Information Interchange）</p></li><li><p>使用7个bits就可以完全表示ASCII码</p></li><li><p>包含95个可打印字符，33个不可打印字符（包括控制字符）</p></li><li><p>很多应用或者国家中的符号都无法表示</p></li><li><p>无法表示数学符号：“÷ ≠ ≥ ≈ π”</p></li><li><p>𝟑𝟑 + 𝟗𝟓 = 𝟏𝟐𝟖 = 𝟐^7</p><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801143402.jpg" alt=""></p></li></ul></li><li><p>Externed ASCII码</p><ul><li><p>第一次对ASCII码进行扩充， 7bits =&gt; 8bits</p></li><li><p>常见数学运算符</p></li><li><p>带音标的欧洲字符</p></li><li><p>其他常用符、表格符等</p><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801143429.jpg" alt=""></p></li></ul></li><li><p>国际化</p><ul><li>欧洲、中亚、东亚、拉丁美洲国家的语言多样性</li><li>语言体系不一样，不以有限字符组合的语言</li><li>中国、韩国、日本等的语言最为复杂</li><li>中文编码集<ul><li>GB2312<ul><li>《信息交换用汉字编码字符集——基本集》</li><li>一共收录了 7445 个字符</li><li>包括 6763 个汉字和 682 个其它符号</li><li>不兼容国际标准</li></ul></li><li>GBK<ul><li>向下兼容GB2312，向上支持国际ISO标准</li><li>《汉字内码扩展规范》</li><li>收录了21003个汉字，支持全部中日韩汉字</li><li>国际电脑不安装GBK编码就会显示乱码</li><li>国内的Windows系统默认使用GBK编码</li></ul></li></ul></li><li>Unicode<ul><li>Unicode：统一码、万国码、单一码，兼容全球的字符集</li><li>Unicode定义了世界通用的符号集， UTF-*实现了编码</li><li>UTF-8以字节为单位对Unicode进行编码</li></ul></li></ul></li></ul><h2 id="2-组成篇"><a href="#2-组成篇" class="headerlink" title="2.组成篇"></a>2.组成篇</h2><h3 id="2-1-计算机的总线"><a href="#2-1-计算机的总线" class="headerlink" title="2.1 计算机的总线"></a>2.1 计算机的总线</h3><ul><li><p>总线的概述</p><ul><li><p>USB = Universal Serial Bus ，通用串行总线</p><ul><li>提供了对外连接的接口</li><li>不同设备可以通过USB接口进行连接</li><li>连接的标准，促使外围设备接口的统一</li></ul></li><li><p>总线的分类</p><ul><li>片内总线<ul><li>芯片内部的总线</li><li>寄存器与寄存器之间</li><li>寄存器与控制器、运算器之间</li></ul></li><li>系统总线<ul><li>CPU、主内存、 IO设备、各组件之间的信息传输线</li><li>数据总线<ul><li>双向传输各个部件的数据信息</li><li>一般与CPU位数相同（32位、 64位）</li><li>数据总线的位数（总线宽度）是数据总线的重要参数，64位总线一次可传输8个字节的数据</li></ul></li><li>地址总线<ul><li>指定源数据或目的数据在内存中的地址</li><li>地址总线位数=n，寻址范围： 0~𝟐^n</li><li>地址总线的位数与存储单元有关</li></ul></li><li>控制总线<ul><li>控制总线是用来发出各种控制信号的传输线</li><li>控制信号经由控制总线从一个组件发给另外一个组件</li><li>控制总线可以监视不同组件之间的状态（就绪/未就绪）</li></ul></li></ul></li></ul></li></ul></li><li><p>总线的仲裁</p><ul><li>为了解决总线使用权的冲突问题</li><li>总线的仲裁的方法<ul><li>链式查询-串联<ul><li>所有设备都可想仲裁器发出使用权申请，仲裁器在分配使用权时是按照链式顺序逐个询问，轮到谁就是谁</li><li>好处：电路复杂度低，仲裁方式简单</li><li>坏处：优先级低的设备难以获得总线使用权</li><li>坏处：优先级低的设备难以获得总线使用权</li></ul></li><li>计时器定时查询-并联<ul><li>仲裁控制器对设备编号并使用计数器累计计数</li><li>接收到仲裁信号后，往所有设备同时发出计数值</li><li>计数值与设备编号一致则获得总线使用权</li></ul></li><li>独立请求-循环<ul><li>每个设备均有总线独立连接仲裁器</li><li>设备可单独向仲裁器发送请求和接收请求</li><li>当同时收到多个请求信号，仲裁器有权按优先级分配使用权</li><li>好处：响应速度快，优先顺序可动态改变</li><li>好处：响应速度快，优先顺序可动态改变</li></ul></li></ul></li></ul></li></ul><h3 id="2-2-计算机的输入输出设备"><a href="#2-2-计算机的输入输出设备" class="headerlink" title="2.2 计算机的输入输出设备"></a>2.2 计算机的输入输出设备</h3><ul><li><p>常见输入输出设备</p><ul><li><p>输入设备</p><ul><li>字符输入设备<ul><li>键盘：<ul><li>薄膜键盘</li><li>机械键盘（根据段落感、声音、压力、键程的不同分为：黑轴、红轴、青轴、茶轴）</li><li>电容键盘</li></ul></li></ul></li><li>图像输入设备<ul><li>鼠标</li><li>数位板：常用于绘图设计创作，输入板和压感笔</li><li>扫描仪：将图形信息转换为数字信号</li></ul></li></ul></li><li><p>输出设备</p><ul><li>显示器<ul><li>CRT显示器</li><li>液晶显示器</li></ul></li><li>打印机</li><li>投影仪</li></ul></li></ul></li><li><p>输入输出接口的通用设计</p><ul><li>通用设计考虑的问题：读取数据、向设备发送数据、设备有没有被占用？、设备是否已经启动？、设备是否已经连接？</li><li>数据线<ul><li>是I/O设备与主机之间进行数据交换的传送线</li><li>单向传输数据线</li><li>双向传输数据线</li></ul></li><li>状态线<ul><li>IO设备状态向主机报告的信号线</li><li>查询设备是否已经正常连接并就绪</li><li>查询设备是否已经被占用</li></ul></li><li>命令线<ul><li>CPU向设备发送命令的信号线</li><li>发送读写信号</li><li>发送启动停止信号</li></ul></li><li>设备选择线<ul><li>主机选择I/O设备进行操作的信号线</li><li>对连在总线上的设备进行选择</li></ul></li></ul></li><li><p>CPU与IO设备的通信</p><ul><li><p>CPU速度与IO设备速度不一致</p></li><li><p>程序中断</p><ul><li><p>当外围IO设备就绪时，向CPU发出中断信号</p></li><li><p>CPU有专门的电路响应中断信号</p></li><li><p>中断的意义</p><ul><li>提供低速设备通知CPU的一种异步的方式</li><li>CPU可以高速运转同时兼顾低速设备的响应</li><li>提高工作效率(polling的问题) </li><li>故障恢复(异常处理、紧急事件等)</li><li>简化编程模型(try/cache, 计时器等)</li></ul></li></ul></li><li><p>例如通过电脑打印资料的过程</p><ul><li><p>中断相应过程</p><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801143825.jpg" alt=""></p></li><li><p>中断请求类型</p><ul><li>硬件设备发给主板(打印机、键盘、鼠标等)</li><li>硬件中断: CPU异常(除以0), 时钟信号等</li><li>软件中断:发出(异常、切换到内核态等)</li></ul></li><li><p>中断向量表</p><ul><li><p>(一般在内存中) 一块块区域，存储了中断类型和中断响应程序的对应关系。每一行叫做一个中断向量。</p><table><thead><tr><th>中断类型</th><th>ISR地址</th><th>描述</th></tr></thead><tbody><tr><td>00</td><td>0x0000</td><td>除以0</td></tr><tr><td>01</td><td>0x0004</td><td>单步</td></tr><tr><td>09</td><td>0x0024</td><td>键盘</td></tr><tr><td>18</td><td>0x0048</td><td>打印机</td></tr><tr><td>100</td><td>0x0190</td><td>自定义</td></tr></tbody></table></li></ul></li><li><p>中断QA</p><ul><li>32位机器上的中断响应路径(ISR) 只有4个字节，怎么实现复杂的程序?</li><li>按键程序中断响应路径到操作系统再到应用， 但是到底哪些键被按了怎么知道?</li><li>中断响应后，如何恢复到中断执行前的状态?</li><li>既然出错了?为什么不出错了直接跳转到错误处理位置?</li></ul></li></ul></li><li><p>DMA（direct memory access）直接存储器存取</p><ul><li>DMA直接连接主存与IO设备</li><li>DMA直接连接主存与IO设备</li><li>当主存与IO设备交换信息时，不需要中断CPU</li><li>可以提高CPU的效率</li><li>硬盘和外置显卡中都有DMA设备</li></ul></li></ul></li></ul><h3 id="2-3-计算机存储器"><a href="#2-3-计算机存储器" class="headerlink" title="2.3 计算机存储器"></a>2.3 计算机存储器</h3><ul><li><p>存储器的分类</p><ul><li>按存储介质分类<ul><li>半导体存储器 ：内存条、 U盘、 固态硬盘</li><li>磁存储器：磁带、磁盘</li></ul></li><li>按存取方式分类<ul><li>随机存储器(RAM)： 随机读取 与位置无关</li><li>串行存储器 ：与位置有关 按顺序查找</li><li>只读存储器(ROM）：只读不写</li></ul></li></ul></li><li><p>存储器指标</p><ul><li>读写速度：7200转</li><li>存储容量：2T</li><li>价格：容量+价格=&gt;位价：每比特位价格</li></ul></li><li><p>层次结构</p><ul><li>高速缓存：速度快，位格高</li><li>主存：速度适中，位格适中</li><li>辅存：速度慢，位格低</li><li>缓存-主存层次<ul><li>原理：局部性原理</li><li>实现：在CPU与主存之间增加一层速度快（容量小）的Cache</li><li>目的：解决主存速度不足的问题</li></ul></li><li>主存-辅存层次<ul><li>原理：局部性原理</li><li>实现：主存之外增加辅助存储器（磁盘、 SD卡、 U盘等）</li><li>目的：解决主存容量不足的问题</li></ul></li><li>局部性原理<ul><li>局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。</li></ul></li></ul></li></ul><h3 id="2-4-主存储器与辅助存储器"><a href="#2-4-主存储器与辅助存储器" class="headerlink" title="2.4 主存储器与辅助存储器"></a>2.4 主存储器与辅助存储器</h3><ul><li><p>计算机断电，内存数据丢失</p></li><li><p>计算机断电，磁盘数据不会丢失</p></li><li><p>主存</p><ul><li>RAM（随机存取存储器： Random Access Memory）</li><li>RAM 通过电容存储数据，必须隔一段时间刷新一次</li><li>如果掉电，那么一段时间后将丢失所有数据</li><li>内存与CPU如何交互的</li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801143858.jpg" alt=""></p><ul><li>32位系统：2^32 = 4 × 2^30 = 4𝐺𝐵 </li><li>64位系统：2^64 = 2^34 × 2^30 = 2^34𝐺𝐵=2^24T𝐵=2^14EB=2^4EB</li><li>32位的系统最大支持4GB的内存寻址范围，每一个字节都对应一个内存地址。内存地址由 0 开始编号，比如第 1 个地址是 0，第 2 个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。</li><li>工作原理<ul><li>字：是指存放在一个存储单元中的二进制代码组合</li><li>字块：存储在连续的存储单元中而被看作是一个单元的一组字</li><li>假设一个字有32位，一个字块共B个字，主存共M个字块<ul><li>B×M = 主存总字数；B×M×32 = 主存总容量(bits)</li></ul></li><li>字的地址包含两个部分，前m位指定字块的地址，后b位指定字在字块中的地址<ul><li>2^𝑚 = 𝑀 , 前m位能表示出的寻址范围是0–2^𝑚</li><li>2^𝒃 = 𝐵，后b位能表示出的寻址范围是0–2^b</li></ul></li></ul></li></ul></li><li><p>辅存：磁盘</p><ul><li><p>表面是可磁化的硬磁特性材料</p></li><li><p>移动磁头径向运动读取磁道信息</p></li><li><p>磁道、扇区、磁头位置、磁头方向</p></li><li><p>寻道调度算法</p><ul><li>先来先服务算法<ul><li>按顺序访问进程的磁道读写需求</li></ul></li><li>最短寻道时间优先<ul><li>与磁头当前位置有关</li><li>优先访问离磁头最近的磁道</li></ul></li><li>扫描算法（电梯算法）<ul><li>每次只往一个方向移动</li><li>到达一个方向需要服务的尽头再反方向移动</li></ul></li><li>循环扫描算法<ul><li>每次只往一个方向移动</li><li>一个方向到头后再从头开始从同一个方向开始移动</li></ul></li></ul></li></ul></li></ul><h3 id="2-5-高速缓存"><a href="#2-5-高速缓存" class="headerlink" title="2.5 高速缓存"></a>2.5 高速缓存</h3><ul><li><p>为了解决CPU与主存的速度不匹配的问题</p></li><li><p>缓存与主存的关系</p><ul><li>存储的逻辑结构类似</li><li>缓存的容量较小</li><li>缓存的速度更快</li></ul></li><li><p>在主存缓存层次结构中的工作原理</p><ul><li>CPU需要的数据在缓存里：直接获取</li><li>CPU需要的数据不在缓存里：需要去主存拿，替换策略<ul><li>需要性能良好的缓存替换策略</li></ul></li><li>命中率：从缓存取数据的命中率<ul><li>命中率是衡量缓存的重要性能指标</li><li>理论上CPU每次都能从高速缓存取数据的时候，命中率为1</li><li>访问主存次数： N𝑚，访问Cache次数： N𝑐</li><li>命中率ℎ =𝑁𝑐/(𝑁𝑐＋𝑁𝑚)</li></ul></li><li>访问效率： 𝑒<ul><li>访问主存时间： 𝑡𝑚 ，访问缓存时间：𝑡𝑐</li><li>访问Cache-主存系统平均时间： 𝑡𝑎 = ℎ×𝑡𝑐 + (1 − ℎ)×𝑡𝑚</li><li>𝑒 =𝑡𝑐/𝑡𝑎</li></ul></li></ul></li><li><p>高速缓存替换策略</p><ul><li>随机算法</li><li>先进先出算法(FIFO)<ul><li>把高速缓存看做是一个先进先出的队列</li><li>优先替换最先进入队列的字块</li></ul></li><li>最不经常使用算法(LFU)<ul><li>优先淘汰最不经常使用的字块</li><li>需要额外的空间记录字块的使用频率</li></ul></li><li>最近最少使用算法(LRU)<ul><li>优先淘汰一段时间内没有使用的字块</li><li>如果正在使用的字块在缓存就将其移到表头，保证链表头部节点是最近使用的</li><li>有多种实现方法，一般使用双向链表</li></ul></li></ul></li></ul><h3 id="2-6-计算机的指令系统"><a href="#2-6-计算机的指令系统" class="headerlink" title="2.6 计算机的指令系统"></a>2.6 计算机的指令系统</h3><ul><li><p>计算机指令</p><ul><li>计算机通过指令指挥计算机工作。</li><li>CPU被时钟驱动，不断的读取PC指针指向的指令，并增加PC指针，从内存中读取指令并执行。(如此周而复始)</li><li>不同的CPU架构使用不同指令。目前使用最广泛的是RISC(Reduced instruction set computer,精简指令集)</li></ul></li><li><p>机器指令的形式</p><ul><li>机器指令主要由两部分组成：操作码、地址码</li><li>操作码指明指令所要完成的操作</li><li>操作码的位数反映了机器的操作种类，如果操作码有8位就有2^8 = 256种操作</li><li>地址码直接给出操作数或者操作数的地址</li><li>分三地址指令、二地址指令和一地址指令与零地址指令<ul><li>零地址指令<ul><li>在机器指令中无地址码</li><li>空操作、停机操作、中断返回操作等</li></ul></li><li>一地址指令<ul><li>(addr1)OP→ (addr1)：自己对自己的操作</li><li>(addr1)OP(ACC) → (addr1)：自增操作</li></ul></li><li>二地址指令<ul><li>(addr1)OP(addr2) → (addr1)或(addr2)： 结果放在addr1或addr2)</li></ul></li><li>三地址指令<ul><li>一个操作码和三个地址码</li><li>(addr1)OP(addr2) → (addr3)：结果放在addr3， 例如： 1+2=3</li></ul></li></ul></li></ul></li><li><p>操作类型</p><ul><li>数据传输<ul><li>寄存器之间、寄存器与存储单元、存储单元之间传送</li><li>数据读写、交换地址数据、清零置一等操作</li></ul></li></ul></li><li><p>load/store指令用来从内存中读/写入内存。通常会有多个版本的实现，助记符是:</p><pre><code>- load类: Iw,Ib,Ih- store类: sw,sb,sh</code></pre><ul><li>算术逻辑<ul><li>操作数之间的加减乘除运算<ul><li>加减乘除等：addi, subi, divi, multi</li></ul></li><li>操作数的与或非等逻辑位运算<ul><li>位运算指令：and/or/xor</li></ul></li></ul></li></ul></li><li><p>移位操作</p><ul><li>数据左移（乘2）、数据右移（除2）</li><li>完成数据在算术逻辑单元的必要操作</li><li>控制指令<ul><li>等待指令、停机指令、空操作指令、中断指令等</li></ul></li></ul></li><li><p>寻址方式</p><ul><li><p>指令寻址</p><ul><li><p>顺序寻址</p></li><li><p>跳跃寻址</p><table><thead><tr><th align="center">地址</th><th align="center">指令</th></tr></thead><tbody><tr><td align="center">101</td><td align="center">MOV R0,R1</td></tr><tr><td align="center">102</td><td align="center">ADD R1,R2</td></tr><tr><td align="center">103</td><td align="center">JMP 102</td></tr></tbody></table></li></ul></li><li><p>数据寻址</p><ul><li>立即寻址<ul><li>指令直接获得操作数</li><li>无需访问存储器</li><li>优点：速度快</li><li>缺点：地址码位数限制操作数表示范围</li></ul></li><li>直接寻址<ul><li>直接给出操作数在主存的地址</li><li>寻找操作数简单，无需计算数据地址</li><li>优点：寻找操作数简单</li><li>缺点：地址码位数限制操作数表示范围</li></ul></li><li>间接寻址<ul><li>指令地址码给出的是操作数地址的地址</li><li>需要访问一次或多次主存来获取操作数</li><li>优点：操作数寻址范围大</li><li>缺点：速度较慢</li></ul></li></ul></li></ul></li></ul><h3 id="2-7-计算机的控制器"><a href="#2-7-计算机的控制器" class="headerlink" title="2.7 计算机的控制器"></a>2.7 计算机的控制器</h3><ul><li>控制器是协调和控制计算机运行的</li><li>程序计数器<ul><li>程序计数器用来存储下一条指令的地址</li><li>循环从程序计数器中拿出指令</li><li>当指令被拿出时，指向下一条指令</li></ul></li><li>时序发生器<ul><li>电气工程领域，用于发送时序脉冲</li><li>CPU依据不同的时序脉冲有节奏的进行工作</li></ul></li><li>指令译码器<ul><li>指令译码器是控制器的主要部件之一</li><li>计算机指令由操作码和地址码组成</li><li>翻译操作码对应的操作以及控制传输地址码对应的数据</li></ul></li><li>指令寄存器<ul><li>指令寄存器也是控制器的主要部件之一</li><li>从主存或高速缓存取计算机指令</li></ul></li><li>主存地址寄存器<ul><li>保存当前CPU正要访问的内存单元的地址</li></ul></li><li>主存数据寄存器<ul><li>保存当前CPU正要读或写的主存数据</li></ul></li><li>通用寄存器<ul><li>用于暂时存放或传送数据或指令</li><li>可保存ALU的运算中间结果</li><li>容量比一般专用寄存器要大</li></ul></li></ul><h3 id="2-8-计算机的运算器"><a href="#2-8-计算机的运算器" class="headerlink" title="2.8 计算机的运算器"></a>2.8 计算机的运算器</h3><ul><li><p>运算器是用来进行数据运算加工的</p></li><li><p>数据缓冲器</p><ul><li>分为输入缓冲和输出缓冲</li><li>输入缓冲暂时存放外设送过来的数据</li><li>输出缓冲暂时存放送往外设的数据</li></ul></li><li><p>ALU</p><ul><li>ALU：算术逻辑单元，是运算器的主要组成</li><li>常见的位运算（左右移、与或非等）</li><li>算术运算（加减乘除等）</li></ul></li><li><p>通用寄存器</p><ul><li>用于暂时存放或传送数据或指令</li><li>可保存ALU的运算中间结果</li><li>容量比一般专用寄存器要大</li></ul></li><li><p>状态字寄存器</p><ul><li>存放运算状态（条件码、进位、溢出、结果正负等）</li><li>存放运算控制信息（调试跟踪标记位、允许中断位等）</li></ul></li><li><p>总线</p></li></ul><h3 id="2-9-计算机指令的执行过程"><a href="#2-9-计算机指令的执行过程" class="headerlink" title="2.9 计算机指令的执行过程"></a>2.9 计算机指令的执行过程</h3><ul><li><p>指令执行过程</p><ul><li>取指令 <ul><li>从缓存取指令</li><li>送到指令寄存器</li></ul></li><li>分析指令<ul><li>指令译码器译码</li><li>发出控制信号</li><li>程序计数器+1</li></ul></li><li>执行指令<ul><li>装载数据到寄存器</li><li>ALU处理数据</li><li>记录运算状态</li><li>送出运算结果</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801144002.jpg" alt=""></p></li><li><p>CPU的流水线设计</p><ul><li>提高CPU的综合利用率</li><li>类似工厂的装配线</li><li>工厂的装配线使得多个产品可以同时被加工</li><li>在同一个时刻，不同产品均位于不同的加工阶段</li><li>串行执行m条指令： 𝑇1 = 3t × 𝑚</li><li>流水线执行m条指令： 𝑇2 = 𝑡 × (𝑚 + 2)</li><li>流水线执行效率:H=𝑇2/𝑇1= 𝑡 × (𝑚 + 2)/3t × 𝑚=1/3+1/3m, m很大的情况下是串行执行的3倍效率</li></ul><table><thead><tr><th>指令</th><th>时间片</th><th>时间片</th><th>时间片</th><th>时间片</th><th>时间片</th></tr></thead><tbody><tr><td>1</td><td>取指令</td><td>分析指令</td><td>执行指令</td><td></td><td></td></tr><tr><td>2</td><td></td><td>取指令</td><td>分析指令</td><td>执行指令</td><td></td></tr><tr><td>3</td><td></td><td></td><td>取指令</td><td>分析指令</td><td>执行指令</td></tr></tbody></table></li></ul><h2 id="3-计算篇"><a href="#3-计算篇" class="headerlink" title="3.计算篇"></a>3.计算篇</h2><h3 id="3-1-进制运算的基础"><a href="#3-1-进制运算的基础" class="headerlink" title="3.1 进制运算的基础"></a>3.1 进制运算的基础</h3><ul><li>什么是进制<ul><li>进位制是一种记数方式，亦称进位计数法或位值计数法</li><li>有限种数字符号来表示无限的数值</li><li>使用的数字符号的数目称为这种进位制的基数或底数</li><li>计算机喜欢二进制，但是二进制表达太长了</li><li>使用大进制位可以解决这个问题</li><li>八进制、十六进制满足2的n次方的要求</li><li>二进制<ul><li>1024=0b1000000000 </li></ul></li><li>八进制<ul><li>1024=0o2000</li></ul></li><li>十进制： [0-9] </li><li>十六进制<ul><li>MAC地址：[0-9]和A、 B、 C、 D、 E、 F</li><li>1024=0x400</li></ul></li><li>二十进制<ul><li>玛雅文明的玛雅数字</li><li>因努伊特的因努伊特数字</li></ul></li><li>六十进制<ul><li>时间、坐标、角度等量化数据</li></ul></li></ul></li><li>进制的表示法<ul><li>正整数N，基数为r，位数为n</li><li>N=𝑑𝑛−1×r𝑛−1 +𝑑𝑛−2× r𝑛−2 + ⋯ + 𝑑1×𝑟 + 𝑑0</li><li>N= 1024  = 1 ×10^3 +0×10^3+ 2 × 10^1 + 4× 10^0</li><li>𝑁 = 10000000000  = 1 × 2^10</li></ul></li><li>二进制转十进制的方法<ul><li>按权展开法</li><li>𝑁 = 01100101 = 1 × 2^6 + 1 × 2^5 + 1 ×2^2 + 1 = 101</li><li>小数的按权展开法</li><li>𝑁 = 0.11001 = 1×2^−1 + 1×2^−2 + 1× 2^−5 = 0.78125=25/32</li></ul></li><li>十进制转二进制的方法<ul><li>（整数）重复相除法</li><li>重复除以2 ，得商， 取余数，最后一个余数为最高位</li><li>（小数）重复相乘法</li><li>重复乘以2， 得积 ，取1，第一个余数为最高位</li></ul></li></ul><h3 id="3-2-原码-amp-反码-amp-补码"><a href="#3-2-原码-amp-反码-amp-补码" class="headerlink" title="3.2 原码&amp;反码&amp;补码"></a>3.2 原码&amp;反码&amp;补码</h3><ul><li><p>使用0表示正数，使用1表示负数，最高位表示符号位，其它都是数字位</p></li><li><p>+237=011101101， -237=111101101</p></li><li><p>两个字节16位表示+237 【0】 0 0 0 0 0 0 0 1 1 1 0 1 1 0 1</p></li><li><p>原码表示法</p><ul><li>使用0表示正数、 1表示负数</li><li>规定符号位位于数值第一位</li><li>表达简单明了，是人类最容易理解的表示法</li><li>0有两种表示方法： 00、 10</li><li>原码进行运算非常复杂，特别是两个操作数符号不同的时候<ul><li>判断两个操作数绝对值大小</li><li>使用绝对值大的数减去绝对值小的数</li><li>对于符号值，以绝对值大的为准</li></ul></li><li>希望找到不同符号操作数更加简单的运算方法</li><li>希望找到使用正数代替负数的方法</li><li>使用加法操作代替减法操作，从而消除减法</li></ul></li><li><p>补码表示法</p><ul><li>整数的补码<ul><li>如果 x∈[0, 2^𝑛) X=x  ，n是数字位的个数</li><li>如果 x∈[−2^𝑛, 0) X=2^(𝑛+1) + 𝑥<ul><li>例如：n=4， x=13，计算x的二进制原码和补码<ul><li>原码： x=0,1101</li><li>补码： x=0,1101</li></ul></li><li>例如：n=4，x=-13，计算x的二进制原码和补码<ul><li>原码： x=1,1101</li><li>补码： 2^(𝑛+1) + 𝑥= 2^(4+1() − 13 = 100000 − 1101 = 10011</li></ul></li></ul></li></ul></li><li>小数的补码<ul><li>如果 x∈[0, 1) X=x  </li><li>如果 x∈[−1, 0) X=2+x</li><li>规律：小数的反码等于原码除符号位外按位取反，补码等于反码+1</li></ul></li><li>在计算补码的过程中，还是使用了减法</li><li>需要寻找使用正数代替负数的方法</li></ul></li><li><p>反码表示法</p><ul><li>反码的目的是找出原码和补码之间的规律，消除转换过程中的减法</li><li>如果 x∈[0, 2^𝑛) X=x  ，n是数字位的个数</li><li>如果 x∈[−2^𝑛, 0) X=（2^(𝑛+1)-1） + 𝑥</li><li>规律：负数的反码等于原码除符号位外按位取反，负数的补码等于反码+1<ul><li>-13， 原码：1,1101 ，反码：1,0011 ，补码：1,0010</li><li>-7， 原码： 1,0111，反码： 1,1001，补码： 1,1000</li><li>-1， 原码： 1,0001 ，反码：1,1111，补码： 1,1110</li></ul></li><li>x=-13，计算x的二进制原码和反码<ul><li>原码： x=1,1101</li><li>反码： (2𝑛+1−1) + 𝑥 = (2^4+1−1) − 13 = 011111 − 1101 = 1,0010</li><li>反码： x=1,0010</li></ul></li></ul></li></ul><p>  <img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801144040.jpg" alt=""></p><h3 id="3-3-定点数与浮点数"><a href="#3-3-定点数与浮点数" class="headerlink" title="3.3 定点数与浮点数"></a>3.3 定点数与浮点数</h3><ul><li><p>定点数的表示方法</p><ul><li>小数点固定在某个位置的数称之为定点数</li><li>纯小数 ：符号位【小数点】数值位</li><li>纯整数：符号位 数值位 【小数点】</li><li>其它小数需要乘以比例因子以满足定点数保存格式，10.01 需要左移两位或者右移两位</li><li>计算机中的存储形式见下表，小数点不显示</li></ul><table><thead><tr><th align="left">数值</th><th align="center">符号位</th><th align="center">数值位</th></tr></thead><tbody><tr><td align="left">0.1011</td><td align="center">0</td><td align="center">1011</td></tr><tr><td align="left">-0.1011</td><td align="center">1</td><td align="center">1011</td></tr><tr><td align="left">1011</td><td align="center">0</td><td align="center">1011</td></tr><tr><td align="left">-1011</td><td align="center">1</td><td align="center">1011</td></tr></tbody></table></li><li><p>浮点数的表示方法</p><ul><li><p>计算机处理的很大程度上不是纯小数或纯整数</p></li><li><p>数据范围很大，定点数难以表达</p></li><li><p>浮点数的表示格式</p><ul><li>类比科学计数法：123450000000 = 1.2345 × 10^11 ， 1.2345：尾数 ，10：基数 ，11：阶码</li><li>𝑁 = 𝑆 × 𝑟^𝑗 ，S：尾数， r：基数， j：阶码</li><li>阶码符号位|阶码数值位|尾数符号位|尾数数值位</li><li>尾数规定使用纯小数</li><li>11.0101 = 0.110101 × 2^10</li><li>11.0101 = 0.0110101 × 2^11</li><li>计算机中的存储形式见下表，小数点不显示</li></ul><table><thead><tr><th>数字</th><th>阶码符号位</th><th>阶码数值位</th><th>尾数符号位</th><th>尾数数值位（8位）</th></tr></thead><tbody><tr><td>0.110101 × 2^10</td><td>0</td><td>10</td><td>0</td><td>1010100</td></tr><tr><td>0.0110101 × 2^11</td><td>0</td><td>11</td><td>0</td><td>01101010</td></tr></tbody></table></li></ul></li></ul><ul><li><p>浮点数的表示范围</p><ul><li>假设阶码数值取m位，尾数数值取n位</li><li>阶码表示范围： [−(𝟐^𝒎 − 𝟏),  𝟐^𝒎 − 𝟏]</li><li>尾数表示范围： [−(𝟏 − 𝟐^−𝒏), −(𝟐^−𝒏)] [𝟐^−𝒏,  𝟏 − 𝟐−^𝒏]</li><li>单精度浮点数：使用4字节、 32位来表达浮点数(float)</li><li>双精度浮点数：使用8字节、 64位来表达浮点数(double)</li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801144101.jpg" alt=""></p></li><li><p>浮点数的规格化</p><ul><li>尾数规定使用纯小数</li><li>尾数最高位必须是1</li><li>例如：11.0101 = 0.110101 × 2^10</li></ul></li></ul><ul><li><p>两者的对比</p><ul><li>当定点数与浮点数位数相同时， 浮点数表示的范围更大</li><li>当浮点数尾数为规格化数时， 浮点数的精度更高（尾数存8位，前面的0多了丢失的精度就更多）</li><li>浮点数运算包含阶码和尾数， 浮点数的运算更为复杂</li><li>浮点数在数的表示范围、精度、溢出处理、编程等方面均优于定点数</li><li>浮点数在数的运算规则、运算速度、硬件成本方面不如定点数</li></ul></li></ul><h3 id="3-4-定点数的加减法运算"><a href="#3-4-定点数的加减法运算" class="headerlink" title="3.4 定点数的加减法运算"></a>3.4 定点数的加减法运算</h3><ul><li><p>整数加法：A 补 + B 补 = 𝐴 + 𝐵 补 (𝑚𝑜𝑑2^(𝑛+1))</p></li><li><p>小数加法：A 补 + B 补 = 𝐴 + 𝐵 补 (𝑚𝑜𝑑2)</p></li><li><p>数值位与符号位一同运算，并将符号位产生的进位自然丢掉</p></li><li><p>整数减法：A 补 − B 补 = 𝐴 + (−𝐵) 补  (𝑚𝑜𝑑2^(𝑛+1))</p></li><li><p>小数减法：A 补 − B 补 = 𝐴 + (−𝐵) 补 (𝑚𝑜𝑑2)</p></li><li><p>-B[补]等于B[补]连同符号位按位取反，末位加一，B 补 = 1,0010101， (−B) 补 = 0,1101011</p></li><li><p>负数的反码等于原码按位取反，补码等于反码+1</p></li><li><p>例如： A=-110010， B=001101，求A+B</p><ul><li>A[补] = 1,001110</li><li>B 补 = B[原] = 0,001101</li><li>A 补 + B 补 = (A + B) 补 =1,011011</li><li>(A + B)原 = −100101</li></ul></li><li><p>例如：A=11001000， B=-00110100，求A-B</p><ul><li>A 补 = A[原] = 0,11001000</li><li>B 补 = 1,11001100</li><li>(−B) 补 = 0,00110100</li><li>A 补 − B 补 = A + (−B) 补=0,11111100</li><li>A − B（原） = 111111100</li></ul></li><li><p>双符号位判断溢出</p><ul><li>双符号位判断法<ul><li>单符号位表示变成双符号位： 0=&gt;00,1=&gt;11</li><li>双符号位产生的进位丢弃</li><li>结果的双符号位不同则表示溢出</li></ul></li></ul></li></ul><h3 id="3-5-浮点数的加减法运算"><a href="#3-5-浮点数的加减法运算" class="headerlink" title="3.5 浮点数的加减法运算"></a>3.5 浮点数的加减法运算</h3><ul><li><p>𝑥 = 𝑆𝑥 × 𝑟^𝑗𝑥，𝑥 = 0.1101 × 2^01</p></li><li><p>𝑦 = 𝑆𝑦 × 𝑟^𝑗y，𝑦 = (−0.1010) × 2^11</p></li><li><p>対阶</p><ul><li>対阶的目的是使得两个浮点数阶码一致，使得尾数可以进行运算</li><li>浮点数尾数运算简单</li><li>浮点数位数实际小数位与阶码有关</li><li>阶码按小阶看齐大阶的原则</li></ul><table><thead><tr><th>数字</th><th>阶码符号位</th><th>阶码数值位</th><th>尾数符号位</th><th>尾数数值位（8位）</th></tr></thead><tbody><tr><td>0.1101 × 2^01</td><td>00</td><td>0001</td><td>00</td><td>1101</td></tr><tr><td>(−0.1010) × 2^11</td><td>00</td><td>0011</td><td>01</td><td>1010</td></tr></tbody></table><ul><li>対阶操作：将x的数值右移两位，𝑥 = 0.001101 × 2^11</li></ul><table><thead><tr><th>数字</th><th>阶码符号位</th><th>阶码数值位</th><th>尾数符号位</th><th>尾数数值位（8位）</th></tr></thead><tbody><tr><td>0.001101 × 2^11</td><td>00</td><td><strong>0011</strong></td><td>00</td><td>0011(01)舍弃后两位</td></tr><tr><td>(−0.1010) × 2^11</td><td>00</td><td>0011</td><td>01</td><td>1010</td></tr></tbody></table></li><li><p>尾数求和</p><ul><li>使用补码进行运算</li><li>减法运算转化为加法运算： A - B = A + (-B)</li><li>𝑥[原] = 00.0011，𝑥[补] = 00.0011</li><li>𝑦[原] = 11.1010，𝑦[补] = 11.0110</li><li>S = (𝑥 + 𝑦)[补] = 11.1001</li></ul><table><thead><tr><th>数字</th><th>阶码符号位</th><th>阶码数值位</th><th>尾数符号位</th><th>尾数数值位（8位）</th></tr></thead><tbody><tr><td>11.1001</td><td>00</td><td><strong>0011</strong></td><td>11</td><td>1001</td></tr></tbody></table></li><li><p>尾数规格化</p><ul><li>◆ 对补码进行规格化需要判断两种情况： S&gt;0和S&lt;0</li><li>S[补] = 00.1xxxxxx(𝑆 &gt; 0)</li><li>S[补] = 11.0xxxxxx(𝑆 &lt; 0)</li><li>如果不满足此格式，需要进行左移， 同时阶码相应变化，以满足规格化</li><li>S = (𝑥 + 𝑦)[补] = 11.1001，不满足约定格式</li><li>S = (𝑥 + 𝑦)[补] = 11. (1)0010(左移舍弃，阶码数值位也要相应变化)</li></ul><table><thead><tr><th>数字</th><th>阶码符号位</th><th>阶码数值位</th><th>尾数符号位</th><th>尾数数值位（8位）</th></tr></thead><tbody><tr><td>11.0010</td><td>00</td><td>0010</td><td>11</td><td>0010</td></tr></tbody></table><ul><li>S = 𝑥 + 𝑦 补 = 11.0010，𝑥 + 𝑦 原 = −0.1110</li><li>𝑥 + 𝑦 = −0.1110× 2^10</li><li>一般情况下都是左移，符号位不一致下需要右移(定点运算的溢出情况)</li><li>右移的话则需要进行舍入操作</li></ul></li><li><p>舍入</p><ul><li>0舍1入” 法（二进制的四舍五入）</li><li>S 补 = 10.10110111，符号位不一致，右移舍弃尾数再+1， S 补 = 11.01011011(1)+1=11.01011100</li><li>右移阶码要+1</li></ul></li><li><p>溢出判断</p><ul><li>定点运算双符号位不一致为溢出</li><li>浮点运算尾数双符号位不一致不算溢出，因为尾数双符号位可以进行右规</li><li>浮点运算主要通过阶码的双符号位判断是否溢出</li><li>如果规格化后，阶码双符号位不一致，则认为是溢出</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210801144134.jpg" alt=""></p><h3 id="3-6-浮点数的乘除法运算"><a href="#3-6-浮点数的乘除法运算" class="headerlink" title="3.6 浮点数的乘除法运算"></a>3.6 浮点数的乘除法运算</h3><ul><li><p>乘法：阶码相加，尾数求积</p></li><li><p>𝑥 × 𝑦 = (𝑆𝑥 × 𝑆𝑦) × 𝑟^(𝑗𝑥+𝑗y)</p></li><li><p>除法：阶码相减，尾数求商</p></li><li><p>𝑥/𝑦 = (𝑆𝑥/𝑆𝑦) × 𝑟^(𝑗𝑥−𝑗y)</p></li><li><p>阶码运算</p></li><li><p>尾数运算</p></li><li><p>尾数规格化</p></li><li><p>舍入</p></li><li><p>溢出判断</p></li><li><p>例如： 𝑥 = 0.11010011 × 2^1101， 𝑦 = 0.11101110 × 2^0001，假设阶码4位，尾数8位，计算x * y</p><ul><li>𝑥 × 𝑦 = (𝑆𝑥 × 𝑆𝑦) ×^𝑟(𝑗𝑥+𝑗y)</li><li>= (0.11010011 × 0.11101110) × 𝑟^(1101+0001)</li><li>= 0.11000100(保留八位) × 𝑟^1110</li></ul></li></ul><h2 id="4-关于我"><a href="#4-关于我" class="headerlink" title="4.关于我"></a>4.关于我</h2><p>一个专注基础知识的十二线小码农，本着 <strong>基础，体系，实践，分享</strong> 的学习理念，在自我提升的同时分享自己的心得体会，不断完善，周而复始。</p><p><a href="http://basedev.cn/" target="_blank" rel="noopener">个人网站 basedev.cn</a>  </p><p><a href="https://github.com/jaydroid1024" target="_blank" rel="noopener">Github</a></p><p>BaseDev系列只整理点到为止的知识纲领，不求甚解；欲知其所以然者还得回归书本且付诸实践。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><ul><li><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?sid=20-h5Url-0&amp;courseId=478&amp;lagoufrom=noapp&amp;sharetype=wx_friend#/content" target="_blank" rel="noopener">重学操作系统 | 拉钩教育</a></p></li><li><p><a href="https://coding.imooc.com/class/package/355.html" target="_blank" rel="noopener">编程必备基础 | 慕课网</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 组成原理 </tag>
            
            <tag> CPU </tag>
            
            <tag> 存储器 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实战系列-设计模式总则篇</title>
      <link href="2021/05/31/pattern-all/"/>
      <url>2021/05/31/pattern-all/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/post_banner_jay.png" alt=""></p><h1 id="实战系列-设计模式总则篇"><a href="#实战系列-设计模式总则篇" class="headerlink" title="实战系列-设计模式总则篇"></a>实战系列-设计模式总则篇</h1><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210812012744.png" alt="image-20210812012737030"></p><h2 id="1-设计模式概述"><a href="#1-设计模式概述" class="headerlink" title="1.设计模式概述"></a>1.设计模式概述</h2><ul><li><p>设计模式是什么</p><ul><li><strong>设计模式</strong>是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题。</li></ul></li><li><p>设计模式的主要目的</p><ul><li>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。</li></ul></li><li><p>设计模式与设计原则</p><ul><li>从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行</li></ul></li><li><p>设计模式与方法或库</p><ul><li>设计模式与方法或库的使用方式不同， 你很难直接在自己的程序中套用某个设计模式。 模式并不是一段特定的代码， 而是解决特定问题的一般性概念。 你可以根据模式来实现符合自己程序实际所需的解决方案。</li></ul></li><li><p>设计模式与算法</p><ul><li>设计模式模式和算法两者在概念上都是已知特定问题的典型解决方案。 但算法总是明确定义达成特定目标所需的一系列步骤， 而模式则是对解决方案的更高层次描述。 同一模式在两个不同程序中的实现代码可能会不一样。</li><li>算法更像是菜谱： 提供达成目标的明确步骤。 而模式更像是蓝图： 你可以看到最终的结果和模式的功能， 但需要自己确定实现步骤。</li></ul></li><li><p>设计模式的历史</p><ul><li>模式的概念是由克里斯托佛·亚历山大在其著作 《<a href="https://refactoringguru.cn/pattern-language-book" target="_blank" rel="noopener">建筑模式语言</a>》 中首次提出的。此后，由埃里希·伽玛、 约翰·弗利赛德斯、 拉尔夫·约翰逊和理查德·赫尔姆这四位作者接受了模式的概念。 1994 年， 他们出版了 《<a href="https://refactoringguru.cn/gof-book" target="_blank" rel="noopener">设计模式： 可复用面向对象软件的基础</a>》 一书， 将设计模式的概念应用到程序开发领域中。 该书提供了 23 个模式来解决面向对象程序设计中的各种问题， 很快便成为了畅销书。 由于书名太长， 人们将其简称为 “四人组 （Gang of Four， GoF） 的书”， 并且很快进一步简化为 “GoF 的书”。</li></ul></li><li><p>为什么要学习设计模式</p><ul><li>设计模式是针对软件设计中常见问题的工具箱， 其中的工具就是各种<strong>经过实践验证的解决方案</strong>。 即使你从未遇到过这些问题， 了解模式仍然非常有用， 因为它能指导你如何使用面向对象的设计原则来解决各种问题。</li><li>设计模式定义了一种让你和团队成员能够更高效沟通的通用语言。 你只需说 “哦， 这里用单例就可以了”， 所有人都会理解这条建议背后的想法。 只要知晓模式及其名称， 你就无需解释什么是单例。</li></ul></li><li><p>关于模式的争议</p><ul><li>低效的解决方案：模式试图将已经广泛使用的方式系统化。 许多人会将这样的统一化认为是某种教条， 他们会 “全心全意” 地实施这样的模式， 而不会根据项目的实际情况对其进行调整。</li><li>不当使用：如果你只有一把铁锤， 那么任何东西看上去都像是钉子。这个问题常常会给初学模式的人们带来困扰： 在学习了某个模式后， 他们会在所有地方使用该模式， 即便是在较为简单的代码也能胜任的地方也是如此。</li></ul></li><li><p>设计模式分类</p><ul><li>所有模式可以根据其意图或目的来分类。</li><li><strong>创建型模式：</strong>提供创建对象的机制， 增加已有代码的灵活性和可复用性。<ul><li>常用的有：单例模式、简单工厂模式、工厂方法模式、抽象工厂模式、建造者模式。</li><li>不常用的有：原型模式。</li></ul></li><li><strong>结构型模式：</strong>介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。<ul><li>常用的有：代理模式、桥接模式、装饰者模式、门面模式、适配器模式。</li><li>不常用的有：组合模式、享元模式。</li></ul></li><li><strong>行为型模式：</strong>负责对象间的高效沟通和职责委派。<ul><li>常用的有：观察者模式、模板方法模式、策略模式、责任链模式、迭代器模式、状态模式。</li><li>不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、 中介者模式。</li></ul></li></ul></li></ul><h2 id="2-设计模式目录"><a href="#2-设计模式目录" class="headerlink" title="2.设计模式目录"></a>2.设计模式目录</h2><table><thead><tr><th>名称</th><th align="left">实现要点</th><th>实战</th></tr></thead><tbody><tr><td><strong>创建型模式</strong></td><td align="left"><strong>创建型设计模式主要解决对象的创建问题，<br>封装复杂的创建过程，解耦对象的创建和使用<br>创建型设计模式包括：单例模式、工厂模式、建造者模式、<br>原型模式。</strong></td><td></td></tr><tr><td>01. 单例|Singleton</td><td align="left">保证一个类仅有一个实例，并提供一个<br>访问它的全局访问点。单例有几种经典的实现方式，它们分别<br>是：饿汉式、懒汉式、双重检测、静态内部类、枚举。</td><td></td></tr><tr><td>02. 简单工厂|Sample Factory</td><td align="left">当每个对象的创建逻辑都比较简单的时候，<br>推荐使用简单工厂模式，将多个对象的创建逻<br>辑放到一个工厂类中</td><td></td></tr><tr><td>03. 工厂方法|Factory Method</td><td align="left">定义一个创建对象的接口，让其子类自<br>己决定实例化哪一个工厂类，<br>工厂模式使其创建过程延迟到子类进行。</td><td></td></tr><tr><td>04. 抽象工厂|Abstract Factory</td><td align="left">提供一个创建一系列列相关或相互依赖对<br>象的接口，而无需指定它们具体的类。</td><td></td></tr><tr><td>05. 建造者|Builder</td><td align="left">建造者模式用来创建复杂对象，<br>可以通过设置不同的可选参数，定制化地创建不同的对象。<br>建造者模式的原理和实现比较简单，<br>重点是掌握应用场景，避免过度使用。</td><td>Dialog</td></tr><tr><td>06. 原型|Prototype</td><td align="left">如果对象的创建成本比较大，<br>而同一个类的不同对象之间差别不大(大部分字段都相同)，<br>在这种情况下，我们可以利用对已有对象（原型）<br>进行复制（或者叫拷贝）的方式，来创建新对象，<br>以达到节省创建时间的目的。<br>原型模式有两种实现方法，深拷贝和浅拷贝。</td><td></td></tr><tr><td></td><td align="left"></td><td></td></tr><tr><td><strong>结构型模式</strong></td><td align="left"><strong>结构型模式主要总结了一些类或对象组合在一起的经典结构，<br>这些经典的结构可以解决特定应用场景的问题，<br>结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、<br>门面模式、组合模式、享元模式。</strong></td><td></td></tr><tr><td>01. 适配器|Adapter</td><td align="left">适配器模式是一种事后的补救策略，用来补救设计上的缺陷。<br>适配器提供跟原始类不同的接口。<br>它将不兼容的接口转换为可兼容的接口让原本由于接口<br>不兼容而不能一起工作的类可以一起工作。<br>适配器模式有两种实现方式：类适配器和对象适配器。<br>类适配器使用继承关系来实现，<br>对象适配器使用组合关系来实现。</td><td>RecyclerView</td></tr><tr><td>02. 桥接|Bridge</td><td align="left">桥接模式有两种理解方式。<br>第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。<br>抽象”和“实现”独立开发，<br>通过对象之间的组合关系组装在一起。<br>另一种理解方式更加简单，等同于“组合优于继承”设计原则，<br>不管是哪种理解方式，它们的代码结构都是相同的，<br>都是一种类之间的组合关系。</td><td></td></tr><tr><td>03. 组合|Composite</td><td align="left">将对象组合成树形结构以表示”部分-整体”的层次结构。<br>组合模式使得用户对<br>单个对象和组合对象的使用具有一致性。</td><td></td></tr><tr><td>04. 装饰|Decorator</td><td align="left">装饰器模式主要解决继承关系过于复杂的问题，<br>通过组合来替代继承，给原始类添加增强功能。<br>这也是判断是否该用装饰器模式的一个重要的依据。</td><td>Java IO</td></tr><tr><td>05. 门面|Facade</td><td align="left">通过封装细粒度的接口，<br>向外提供组合各个细粒度接口的高层次接口，<br>来提高接口的易用性。</td><td></td></tr><tr><td>06. 享元|Flyweight</td><td align="left">当一个系统中存在大量重复对象的时候，<br>我们就可以利用享元模式，将对象设计成享元，<br>在内存中只保留一份实例，<br>供多处代码引用，这样可以减少内存中对象的数量，<br>以起到节省内存的目的</td><td></td></tr><tr><td>07. 代理|Proxy</td><td align="left">代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，<br>主要目的是控制访问，而非加强功能，<br>这是它跟装饰器模式最大的不同。<br>一般情况下，我们让代理类和原始类实现同样的接口，<br>或者让代理类继承原始类来实现代理模式。<br>代理模式分为静态代理和动态代理。</td><td>Retrofit 动态代理</td></tr><tr><td></td><td align="left"></td><td></td></tr><tr><td><strong>行为模式</strong></td><td align="left"><strong>型设计模式主要解决的就是“类或对象之间的交互”问题。<br>行为型模式包括：观察者模式、模板模式、策略模式、职责链模式、<br>迭代器模式、状态模式、访问者模式、备忘录模式、<br>命令模式、解释器模式、中介模式。</strong></td><td></td></tr><tr><td>01. 责任链|Chain of Responsibility</td><td align="left">避免请求发送者与接收者耦合在一起，让多<br>个对象都有可能接收请求，将这些对象连接<br>成一条链，并且沿着这条链传递请求，直到<br>有对象处理理它为止。<br>职责链模式常用在框架开发中，<br>用来实现过滤器、拦截器功能，<br>让框架的使用者在不需要修改框架源码的情况下，<br>添加新的过滤、拦截功能。<br>这也体现了之前讲到的对扩展开放、<br>对修改关闭的设计原则。</td><td>OkHttp 拦截器</td></tr><tr><td>02. 命令|Command</td><td align="left">命令模式用到最核心的实现手段，<br>就是将函数封装成对象命令模式的主要作用和应用场景，<br>是用来控制命令的执行，比如，异步、延迟、排队执行命令、<br>撤销重做命令、存储命令、给命令记录日志等</td><td></td></tr><tr><td>03. 迭代器|Iterator</td><td align="left">迭代器模式提供一种方法顺序访问一个容器对象中各元素, <br>而又无须暴暴露该对象的内部表示。<br>迭代器模式主要作用是解耦容器代码和遍历代码。<br>大部分编程语言都提供了现成的迭代器可以使用<br>在通过迭代器来遍历集合元素的同时，<br>增加或者删除集合中的元素，<br>有可能会导致某个元素被重复遍历或遍历不到。<br>解决方案是增删元素之后让遍历报错(fail-fast)</td><td>List<br>Map</td></tr><tr><td>04. 中介者|Mediator</td><td align="left">中介模式的设计思想跟中间层很像，<br>通过引入中介这个中间层，将一组对象之间的交互关系<br>（或者说依赖关系）从多对多（网状关系）<br>转换为一对多（星状关系）.<br>在中介模式的应用场景中，<br>参与者之间的交互关系错综复杂，<br>既可以是消息的发送者、也可以同时是消息的接收者。</td><td></td></tr><tr><td>05. 备忘录|Memento</td><td align="left">备忘录模式也叫快照模式，具体来说，<br>就是在不违背封装原则的前提下，<br>捕获一个对象的内部状态，<br>并在该对象之外保存这个状态，<br>以便之后恢复对象为先前的状态。</td><td></td></tr><tr><td>06. 观察者|Observer</td><td align="left">定义对象间的一种一对多的依赖关系，<br>当一个对象的状态发生改变时，<br>所有依赖于它的对象都得到通知并被自动更新。<br>同步阻塞是最经典的实现方式，主要是为了代码解耦；<br>异步非阻塞除了能实现代码解耦之外，<br>还能提高代码的执行效率；<br>进程间的观察者模式解耦更加彻底，<br>一般是基于消息队列来实现，<br>用来实现不同进程间的被观察者和观察者之间的交互。</td><td>EventBus<br>RxJava</td></tr><tr><td>07. 状态|State</td><td align="left">允许对象在内部状态发生改变时改变它的行为<br>状态模式建议为对象的所有可能状态新建一个类， <br>然后将所有状态的对应行为抽取到这些类中。<br>所有状态类都必须遵循同样的接口，<br> 而且上下文必须仅通过接口与这些对象进行交互。</td><td>音乐播放器</td></tr><tr><td>08. 策略|Strategy</td><td align="left">策略模式用来解耦策略的定义、创建、使用。<br>策略类的定义比较简单，包含一个策略接口<br>和一组实现这个接口的策略类。<br>策略的创建由工厂类来完成，封装策略创建的细节。<br>策略模式包含一组策略可选，客户端代码选择使用哪个策略，<br>有两种确定方法：编译时静态确定和运行时动态确定。<br>其中，“运行时动态确定”才是策略模式最典型的应用场景。<br>最常见的应用场景是，利用它来避免冗长的<br>if-else 或 switch 分支判断。</td><td>支付方式</td></tr><tr><td>09. 模板方法|Template Method</td><td align="left">模板方法模式在一个方法中定义一个算法骨架，<br>并将某些步骤推迟到子类中实现。<br>模板方法模式可以让子类在不改变算法整体结构的情况下，<br>重新定义算法中的某些步骤。<br>模板模式有两大作用：复用和扩展。<br>回调跟模板模式具有相同的作用<br>回调基于组合关系来实现，模板模式基于继承关系来实现。<br>回调比模板模式更加灵活。</td><td>BaseActivity<br>BaseViewModel<br>BaseNetwork</td></tr><tr><td>10. 访问者|Visitor</td><td align="left">访问者模式允许一个或者多个操作应用到一组对象上，<br>设计意图是解耦操作和对象本身，<br>保持类职责单一、<br>满足开闭原则以及应对代码的复杂性</td><td>ASM</td></tr><tr><td>11. 解释器|Interpreter</td><td align="left">用来实现根据语法规则解读“句子”的解释器。<br>核心思想将语法解析的工作拆分到各个小类中，<br>以此来避免大而全的解析类。一般的做法是，<br>将语法规则拆分一些小的独立的单元，<br>然后对每个单元进行解析，最终合并为对整个语法规则的解析。</td><td></td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://time.geekbang.org/column/intro/250?code=Grxvvkczx9tydhzn0RhJfNfwaF2RgJA9qeUWd8orIYo%3D" target="_blank" rel="noopener">极客时间| 设计模式之美</a></p></li><li><p><a href="https://coding.imooc.com/class/270.html?mc_marking=6eab7b8c9bc28db4f23571353f1a9fe5&amp;mc_channel=banner" target="_blank" rel="noopener">慕课网 | java设计模式精讲 Debug 方式+内存分析</a></p></li><li><p><a href="https://refactoringguru.cn/design-patterns" target="_blank" rel="noopener">在线书籍 | 深入设计模式</a></p></li><li><p><a href="https://bugstack.cn/itstack/itstack-demo-design.html" target="_blank" rel="noopener">bugstack虫洞栈 | 实战设计模式</a></p></li><li><p><a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="noopener">菜鸟教程 | 设计模式</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetpack | ViewBinding 详解</title>
      <link href="2021/05/31/jetpack-viewbinding/"/>
      <url>2021/05/31/jetpack-viewbinding/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/post_banner_jay.png" alt=""></p><h1 id="Jetpack-ViewBinding-详解"><a href="#Jetpack-ViewBinding-详解" class="headerlink" title="Jetpack | ViewBinding 详解"></a>Jetpack | ViewBinding 详解</h1><p>通过 <strong>ViewBinding(视图绑定)</strong> 功能，我们可以更轻松地编写与布局文件交互的代码。在模块中启用视图绑定之后，AGP 会为该模块中的每个 XML 布局文件生成一个绑定类。该绑定类的实例中会直接引用那些在布局中声明了资源 id 的控件。这样一来就减少了很多像 <code>findViewById</code> 这种操作，同时也为控件的安全性保驾护航。</p><p><strong>文章核心点：</strong></p><ul><li>VB 集成与一般使用方式，包括：Activity 、Fragment、Adapter、include、merge、ViewStub</li><li>KT 属性代理与泛型实化类型参数 <code>reified</code> 的介绍</li><li>通过 KT 属性代理简化 VB 创建流程，并封装了一个库 VBHelper</li><li>LayoutInflater 原理与参数解析</li><li>XXXBinding 类的绑定过程</li><li>XXXBinding 类的生成过程</li></ul><p><strong><a href="https://github.com/jaydroid1024/VBHelper" target="_blank" rel="noopener">VBHelper</a></strong>：是我写这篇文章提取的一个库，通过属性代理简化了VB的使用，有想了解的可以提提意见</p><ol><li>在 Activity 中创建 ViewBinding 绑定类</li></ol><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//通过自定义属性代理 + 反射绑定类的 inflate 方法</span><span class="token keyword">private</span> <span class="token keyword">val</span> binding<span class="token operator">:</span> ActivityMainBinding <span class="token keyword">by</span> <span class="token function">vb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//通过自定义属性代理 + 传递 inflate 方法引用</span><span class="token keyword">private</span> <span class="token keyword">val</span> binding<span class="token operator">:</span> ActivityMainBinding <span class="token keyword">by</span> <span class="token function">vb</span><span class="token punctuation">(</span>ActivityMainBinding<span class="token operator">::</span>inflate<span class="token punctuation">)</span></code></pre><ol start="2"><li>在 Fragment 中创建 ViewBinding 绑定类</li></ol><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//通过自定义属性代理 + 反射绑定类的 inflate 方法</span><span class="token keyword">private</span> <span class="token keyword">val</span> binding<span class="token operator">:</span> FragmentMainBinding <span class="token keyword">by</span> <span class="token function">vb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//通过自定义属性代理 + 传递 inflate 方法引用</span><span class="token keyword">private</span> <span class="token keyword">val</span> binding<span class="token operator">:</span> FragmentMainBinding <span class="token keyword">by</span> <span class="token function">vb</span><span class="token punctuation">(</span>FragmentMainBinding<span class="token operator">::</span>inflate<span class="token punctuation">)</span></code></pre><ol start="3"><li>在 View 中创建 ViewBinding 绑定类</li></ol><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//通过自定义属性代理 + 反射绑定类的 inflate 三参数方法</span><span class="token keyword">private</span> <span class="token keyword">val</span> binding<span class="token operator">:</span> MyViewBinding <span class="token keyword">by</span> <span class="token function">vb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//通过自定义属性代理 + 传递 inflate 三参数方法引用</span><span class="token keyword">private</span> <span class="token keyword">val</span> binding<span class="token operator">:</span> MyViewBinding <span class="token keyword">by</span> <span class="token function">vb</span><span class="token punctuation">(</span>MyViewBinding<span class="token operator">::</span>inflate<span class="token punctuation">)</span></code></pre><ol start="4"><li>在 Adapter 中创建包含了绑定类的 BindingViewHolder</li></ol><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//通过自定义属性代理 + 反射绑定类的 inflate 三参数方法</span><span class="token keyword">val</span> holder<span class="token operator">:</span> BindingViewHolder<span class="token operator">&lt;</span>LayoutItemTextBinding<span class="token operator">></span> <span class="token keyword">by</span> <span class="token function">vh</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//通过自定义属性代理 + 传递绑定类的 inflate 三参数方法引用</span><span class="token keyword">val</span> holder<span class="token operator">:</span> BindingViewHolder<span class="token operator">&lt;</span>LayoutItemTextBinding<span class="token operator">></span> <span class="token keyword">by</span> <span class="token function">vh</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> LayoutItemTextBinding<span class="token operator">::</span>inflate<span class="token punctuation">)</span></code></pre><h2 id="1-VB-概述"><a href="#1-VB-概述" class="headerlink" title="1.VB 概述"></a>1.VB 概述</h2><ul><li><p>视图绑定在 Android Studio 3.6 Canary 11 及更高版本中可用。</p></li><li><p>开启自动生成绑定类：模块 <code>build.gradle</code> 文件中的 <code>android</code> 闭包下，两种方式</p><ul><li><code>viewBinding {enabled = true}</code> 默认值为false, Android Studio 3.6 Canary 11 及更高版本中可用。</li><li><code>buildFeatures {viewBinding = true}</code> 默认值为false,  Android Studio 4.0 及更高版本中可用</li></ul></li><li><p>忽略自动生成绑定类：请将 <code>tools:viewBindingIgnore="true"</code> 属性添加到相应布局文件的根视图中</p></li><li><p>生成绑定类的名称：将 XML 文件的名称转换为驼峰式大小写，并在末尾添加“Binding”一词。<br>LayoutInflater.Factory</p><ul><li>result_profile.xml ====&gt;ResultProfileBinding</li><li>每个绑定类还包含一个 <code>getRoot()</code> 方法，用于为相应布局文件的根视图提供直接引用。</li></ul></li><li><p>与使用 findViewById 相比</p><ul><li><strong>Null 安全</strong>：绑定类的创建是通过解析布局文件在编译时生成，布局文件添加了id的控件才会生成对应的引用，因此不会发生绑定类中存在而布局中没有对应控件的情况，如果布局引用了错误的类型也会在编译时暴露错误。</li><li><strong>类型安全</strong>：布局中声明的控件是确定类型的。这意味着不存在发生类转换异常的风险。</li></ul></li><li><p>与使用 DataBinding 对比</p><ul><li><p>视图绑定和<a href="https://developer.android.com/topic/libraries/data-binding?hl=zh-cn" target="_blank" rel="noopener">数据绑定</a>均会生成可用于直接引用视图的绑定类。但是，视图绑定旨在处理更简单的用例。</p></li><li><p><strong>更快的编译速度</strong>：视图绑定不需要处理注解信息，因此编译时间更短。</p></li><li><p><strong>易于使用</strong>：视图绑定不需要在 XML 布局文件中标记，只要在模块中启用视图绑定后，它会自动应用于该模块的所有布局。</p></li><li><p>如果项目中使用了数据绑定最好在项目中<strong>同时使用视图绑定和数据绑定</strong>。这样可以在需要高级功能的布局中使用数据绑定，而在不需要高级功能的布局中使用视图绑定。如果只是取代 <code>findViewById()</code> 调用，请考虑改用视图绑定。</p></li></ul></li></ul><h2 id="2-VB-一般使用"><a href="#2-VB-一般使用" class="headerlink" title="2. VB 一般使用"></a>2. VB 一般使用</h2><h3 id="2-1-Activity"><a href="#2-1-Activity" class="headerlink" title="2.1 Activity"></a>2.1 Activity</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">lateinit</span> <span class="token keyword">var</span> binding<span class="token operator">:</span> ActivityMainBinding<span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span>    binding <span class="token operator">=</span> ActivityMainBinding<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>layoutInflater<span class="token punctuation">)</span>    <span class="token function">setContentView</span><span class="token punctuation">(</span>binding<span class="token punctuation">.</span>root<span class="token punctuation">)</span>    <span class="token function">setSupportActionBar</span><span class="token punctuation">(</span>binding<span class="token punctuation">.</span>toolbar<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="2-2-Fragment"><a href="#2-2-Fragment" class="headerlink" title="2.2 Fragment"></a>2.2 Fragment</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">var</span> _binding<span class="token operator">:</span> FragmentFirstBinding<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token comment" spellcheck="true">// This property is only valid between onCreateView and onDestroyView.</span><span class="token keyword">private</span> <span class="token keyword">val</span> binding <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> _binding<span class="token operator">!!</span><span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreateView</span><span class="token punctuation">(</span>inflater<span class="token operator">:</span> LayoutInflater<span class="token punctuation">,</span> container<span class="token operator">:</span> ViewGroup<span class="token operator">?</span><span class="token punctuation">,</span> savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> View <span class="token punctuation">{</span>    firstViewModel <span class="token operator">=</span> <span class="token function">ViewModelProvider</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>FirstViewModel<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">)</span>    _binding <span class="token operator">=</span> FragmentFirstBinding<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>inflater<span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    binding<span class="token punctuation">.</span>rvList<span class="token punctuation">.</span>layoutManager <span class="token operator">=</span> <span class="token function">LinearLayoutManager</span><span class="token punctuation">(</span><span class="token function">requireContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> binding<span class="token punctuation">.</span>root<span class="token punctuation">}</span></code></pre><h3 id="2-3-Adapter"><a href="#2-3-Adapter" class="headerlink" title="2.3 Adapter"></a>2.3 Adapter</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreateViewHolder</span><span class="token punctuation">(</span>parent<span class="token operator">:</span> ViewGroup<span class="token punctuation">,</span> viewType<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> TextHolder <span class="token punctuation">{</span>    <span class="token keyword">val</span> itemBinding <span class="token operator">=</span> LayoutItemTextBinding<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>LayoutInflater<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>context<span class="token punctuation">)</span><span class="token punctuation">,</span> parent<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//绑定类交给Holder</span>    <span class="token keyword">return</span> <span class="token function">TextHolder</span><span class="token punctuation">(</span>itemBinding<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onBindViewHolder</span><span class="token punctuation">(</span>holder<span class="token operator">:</span> TextHolder<span class="token punctuation">,</span> position<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">val</span> item<span class="token operator">:</span> String <span class="token operator">=</span> list<span class="token punctuation">[</span>position<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">//数据交给Holder</span>    holder<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token function">TextHolder</span><span class="token punctuation">(</span><span class="token keyword">val</span> itemBinding<span class="token operator">:</span> LayoutItemTextBinding<span class="token punctuation">)</span> <span class="token operator">:</span> RecyclerView<span class="token punctuation">.</span><span class="token function">ViewHolder</span><span class="token punctuation">(</span>itemBinding<span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">fun</span> <span class="token function">bind</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>        itemBinding<span class="token punctuation">.</span>tvName<span class="token punctuation">.</span>text <span class="token operator">=</span> name    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-4-include"><a href="#2-4-include" class="headerlink" title="2.4 include"></a>2.4 include</h3><pre class=" language-kotlin"><code class="language-kotlin">binding<span class="token punctuation">.</span>includeLayout<span class="token punctuation">.</span>tvInfoInclude<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"tvInfoInclude:<span class="token interpolation variable">$item</span>"</span><span class="token comment" spellcheck="true">// todo  include 方式有时候无法识别到真实的绑定类类型只能识别它是个View类型但是编译不会报错, 这种情况清理缓存可能会好 ，或者也可以强制类型转换或者自己bind</span><span class="token keyword">val</span> tvInfoInclude<span class="token operator">:</span> LayoutInfoBinding <span class="token operator">=</span> binding<span class="token punctuation">.</span>includeLayout <span class="token keyword">as</span> LayoutInfoBinding<span class="token keyword">val</span> tvInfoInclude <span class="token operator">=</span> LayoutInfoBinding<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>binding<span class="token punctuation">.</span>root<span class="token punctuation">)</span>tvInfoInclude<span class="token punctuation">.</span>tvInfoInclude<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"tvInfoInclude:<span class="token interpolation variable">$item</span>"</span></code></pre><h3 id="2-5-merge"><a href="#2-5-merge" class="headerlink" title="2.5 merge"></a>2.5 merge</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//include+merge 只能手动调用绑定类的bind方法</span><span class="token keyword">val</span> layoutInfoMergeBinding <span class="token operator">=</span> LayoutInfoMergeBinding<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>binding<span class="token punctuation">.</span>root<span class="token punctuation">)</span><span class="token keyword">val</span> tvInfoMerge <span class="token operator">=</span> layoutInfoMergeBinding<span class="token punctuation">.</span>tvInfoMergetvInfoMerge<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"tvInfoMerge:<span class="token interpolation variable">$item</span>"</span></code></pre><h3 id="2-6-ViewStub"><a href="#2-6-ViewStub" class="headerlink" title="2.6 ViewStub"></a>2.6 ViewStub</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//ViewStub 只能手动调用绑定类的bind方法</span>binding<span class="token punctuation">.</span>layoutViewStub<span class="token punctuation">.</span><span class="token function">setOnInflateListener</span> <span class="token punctuation">{</span> _<span class="token punctuation">,</span> inflateId <span class="token operator">-></span>    <span class="token keyword">val</span> layoutInfoViewStubBinding <span class="token operator">=</span> LayoutInfoViewStubBinding<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>inflateId<span class="token punctuation">)</span>    <span class="token keyword">val</span> tvInfoViewStub <span class="token operator">=</span> layoutInfoViewStubBinding<span class="token punctuation">.</span>tvInfoViewStub    tvInfoViewStub<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"tvInfoViewStub:<span class="token interpolation variable">$item</span>"</span><span class="token punctuation">}</span>binding<span class="token punctuation">.</span>layoutViewStub<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>详细的测试代码参考：<a href="https://github.com/jaydroid1024/VBHelper" target="_blank" rel="noopener"><strong>Github | VBHelper</strong></a></p><h2 id="3-VB-与-Kotlin-by"><a href="#3-VB-与-Kotlin-by" class="headerlink" title="3. VB 与 Kotlin by"></a>3. VB 与 Kotlin by</h2><p>采用 Kotlin 属性代理简化 VB 使用的三方库</p><ul><li><strong><a href="https://github.com/androidbroadcast/ViewBindingPropertyDelegate" target="_blank" rel="noopener">ViewBindingPropertyDelegate</a></strong></li><li><strong><a href="https://github.com/DylanCaiCoding/ViewBindingKTX" target="_blank" rel="noopener">ViewBindingKTX</a></strong></li><li><strong><a href="https://github.com/jaydroid1024/VBHelper" target="_blank" rel="noopener">VBHelper</a></strong>：这个是我写这篇文章提取的一个库，借鉴了上面两个的实现，精简了一些代码</li></ul><h3 id="3-1-KT-属性代理：by-lazy"><a href="#3-1-KT-属性代理：by-lazy" class="headerlink" title="3.1 KT 属性代理：by lazy"></a>3.1 KT 属性代理：<code>by</code> <code>lazy</code></h3><ul><li><p>by关键字实际上就是一个属性代理运算符重载的符号，任何一个具备属性代理规则的类，都可以使用by关键字对属性进行代理。</p></li><li><p><code>by</code>关键字后面带有一个代理对象，这个代理类不一定要实现特定的接口，但是需要包含下面这两个方法的签名（val 只需要 getValue ），它就能作为一个代理属性来使用。</p></li><li><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//这个是扩展的实现方式，lazy就是采用的这种</span>operator <span class="token keyword">fun</span> MyDelegate<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token keyword">class</span> MyDelegate <span class="token punctuation">{</span>    <span class="token keyword">var</span> value<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string">"YYY"</span>    <span class="token comment" spellcheck="true">//todo 代理类里面必须提供 getValue 方法，或者扩展这个方法也可</span>    operator <span class="token keyword">fun</span> <span class="token function">getValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>        <span class="token keyword">return</span> value    <span class="token punctuation">}</span>    operator <span class="token keyword">fun</span> <span class="token function">setValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> s<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> s    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>lazy  是Kotlin 内部对对属性代理的一个最佳实践，lazy 返回一个实现了 Lazy 接口的代理类，默认是 <code>SynchronizedLazyImpl</code>，</p></li><li><p>Lazy<t> 有个扩展方法，符合属性代理的规则</t></p></li><li><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">inline</span> operator <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Lazy<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token operator">=</span> value</code></pre></li></ul><h3 id="3-2-KT-内联函数-inline-与泛型实化类型参数-reified"><a href="#3-2-KT-内联函数-inline-与泛型实化类型参数-reified" class="headerlink" title="3.2 KT 内联函数 inline 与泛型实化类型参数 reified"></a>3.2 KT 内联函数 <code>inline</code> 与泛型实化类型参数 <code>reified</code></h3><p><a href="https://www.kotlincn.net/docs/reference/inline-functions.html#%E5%85%B7%E4%BD%93%E5%8C%96%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">官方文档</a></p><p><a href="https://github.com/JetBrains/kotlin/blob/master/spec-docs/reified-type-parameters.md" target="_blank" rel="noopener">reified-type-parameters</a></p><p>Kotlin和Java同样存在泛型类型擦除的问题，但是 Kotlin 通过 inline 内联函数使得泛型类的类型实参在运行时能够保留，这样的操作 Kotlin 中把它称为实化，对应需要使用 reified 关键字。</p><ul><li><p>满足实化类型参数函数的必要条件</p><ul><li>必须是 inline 内联函数，使用 inline 关键字修饰</li><li>泛型类定义泛型形参时必须使用 reified 关键字修饰</li></ul></li><li><p>带实化类型参数的函数基本定义</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//类型形参T是泛型函数isInstanceOf的实化类型参数</span><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span><span class="token keyword">reified</span> T<span class="token operator">></span> <span class="token function">isInstanceOf</span><span class="token punctuation">(</span>value<span class="token operator">:</span> Any<span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token operator">=</span> value <span class="token keyword">is</span> T </code></pre></li></ul><h3 id="3-3-通过-lazy-属性代理-inflate方法引用"><a href="#3-3-通过-lazy-属性代理-inflate方法引用" class="headerlink" title="3.3 通过 lazy 属性代理 + inflate方法引用"></a>3.3 通过 lazy 属性代理 + inflate方法引用</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//通过 lazy 属性代理 + inflate方法引用</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>VB <span class="token operator">:</span> ViewBinding<span class="token operator">></span> ComponentActivity<span class="token punctuation">.</span><span class="token function">binding1</span><span class="token punctuation">(</span>inflate<span class="token operator">:</span> <span class="token punctuation">(</span>LayoutInflater<span class="token punctuation">)</span> <span class="token operator">-></span> VB<span class="token punctuation">)</span> <span class="token operator">=</span>    lazy <span class="token punctuation">{</span>        <span class="token function">inflate</span><span class="token punctuation">(</span>layoutInflater<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span>            <span class="token function">setContentView</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>root<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="3-4-通过-lazy-属性代理-反射"><a href="#3-4-通过-lazy-属性代理-反射" class="headerlink" title="3.4 通过 lazy 属性代理 + 反射"></a>3.4 通过 lazy 属性代理 + 反射</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//通过 lazy 属性代理 + 反射</span><span class="token comment" spellcheck="true">//reified 实化类型参数，作用是将泛型替换为真实的类型用于反射等</span><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span><span class="token keyword">reified</span> VB <span class="token operator">:</span> ViewBinding<span class="token operator">></span> ComponentActivity<span class="token punctuation">.</span><span class="token function">binding3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>    lazy <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//经过内联后VB是可以确切知道具体类型的，所以这里可以反射获取具体的 ViewBinding</span>        <span class="token keyword">val</span> viewBinding<span class="token operator">:</span> VB <span class="token operator">=</span> VB<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"inflate"</span><span class="token punctuation">,</span> LayoutInflater<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> layoutInflater<span class="token punctuation">)</span> <span class="token keyword">as</span> VB        viewBinding<span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span>            <span class="token function">setContentView</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>root<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="3-5-通过自定义属性代理-inflate方法引用"><a href="#3-5-通过自定义属性代理-inflate方法引用" class="headerlink" title="3.5 通过自定义属性代理 + inflate方法引用"></a>3.5 通过自定义属性代理 + inflate方法引用</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//通过自定义属性代理 + inflate方法引用</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>VB <span class="token operator">:</span> ViewBinding<span class="token operator">></span> ComponentActivity<span class="token punctuation">.</span><span class="token function">binding2</span><span class="token punctuation">(</span>inflate<span class="token operator">:</span> <span class="token punctuation">(</span>LayoutInflater<span class="token punctuation">)</span> <span class="token operator">-></span> VB<span class="token punctuation">)</span> <span class="token operator">=</span>    ReadOnlyProperty<span class="token operator">&lt;</span>ComponentActivity<span class="token punctuation">,</span> VB<span class="token operator">></span> <span class="token punctuation">{</span> thisRef<span class="token punctuation">,</span> property <span class="token operator">-></span>        <span class="token function">inflate</span><span class="token punctuation">(</span>layoutInflater<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span>            <span class="token function">setContentView</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>root<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="3-6-通过自定义属性代理-反射"><a href="#3-6-通过自定义属性代理-反射" class="headerlink" title="3.6 通过自定义属性代理+ 反射"></a>3.6 通过自定义属性代理+ 反射</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//通过自定义属性代理+ 反射</span><span class="token comment" spellcheck="true">//reified 实化类型参数，作用是将泛型替换为真实的类型用于反射等</span><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span><span class="token keyword">reified</span> VB <span class="token operator">:</span> ViewBinding<span class="token operator">></span> ComponentActivity<span class="token punctuation">.</span><span class="token function">binding4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>    ReadOnlyProperty<span class="token operator">&lt;</span>ComponentActivity<span class="token punctuation">,</span> VB<span class="token operator">></span> <span class="token punctuation">{</span> thisRef<span class="token punctuation">,</span> property <span class="token operator">-></span>        <span class="token comment" spellcheck="true">//经过内联后VB是可以确切知道具体类型的，所以这里可以反射获取具体的 ViewBinding</span>        <span class="token keyword">val</span> viewBinding<span class="token operator">:</span> VB <span class="token operator">=</span> VB<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"inflate"</span><span class="token punctuation">,</span> LayoutInflater<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> layoutInflater<span class="token punctuation">)</span> <span class="token keyword">as</span> VB        viewBinding<span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span>            <span class="token function">setContentView</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>root<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>四种方式的使用</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//通过 lazy 属性代理 + inflate方法引用</span><span class="token keyword">private</span> <span class="token keyword">val</span> binding1 <span class="token keyword">by</span> <span class="token function">binding1</span><span class="token punctuation">(</span>ActivityMainBinding<span class="token operator">::</span>inflate<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//通过自定义属性代理 + inflate方法引用</span><span class="token keyword">private</span> <span class="token keyword">val</span> binding2 <span class="token keyword">by</span> <span class="token function">binding2</span><span class="token punctuation">(</span>ActivityMainBinding<span class="token operator">::</span>inflate<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//通过 lazy 属性代理 + 反射</span><span class="token keyword">private</span> <span class="token keyword">val</span> binding3<span class="token operator">:</span> ActivityMainBinding <span class="token keyword">by</span> <span class="token function">binding3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//通过自定义属性代理+ 反射</span><span class="token keyword">private</span> <span class="token keyword">val</span> binding4<span class="token operator">:</span> ActivityMainBinding <span class="token keyword">by</span> <span class="token function">binding4</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>其它 Fragment、View、Adapter 等绑定类的生成方式可以根据上面的方式灵活调整，也可参考：<a href="https://github.com/jaydroid1024/VBHelper" target="_blank" rel="noopener"><strong>Github | VBHelper</strong></a></p><p><strong>注意的地方：</strong></p><ul><li>反射的方式我这里都是通过绑定类的 inflate 方法，也可以反射 bind 方法，就是入参不同可以根据具体情况灵活调整。</li><li>merge 标签作为根视图生成的绑定类的inflate 方法只有一个两参数的 其它情况都是一参和三参同时生成，反射时需要兼容一下，VBHelper 没有兼容这一点有需要的可以处理一下，具体做法就是 try-cache 分别处理。</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@NonNull</span><span class="token keyword">public</span> <span class="token keyword">static</span> LayoutInfoMergeBinding <span class="token function">inflate</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> LayoutInflater inflater<span class="token punctuation">,</span>    <span class="token annotation punctuation">@NonNull</span> ViewGroup parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"parent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  inflater<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>layout_info_merge<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">bind</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="4-VB-原理解析"><a href="#4-VB-原理解析" class="headerlink" title="4. VB 原理解析"></a>4. VB 原理解析</h2><h3 id="4-1-LayoutInflater-原理与参数解析"><a href="#4-1-LayoutInflater-原理与参数解析" class="headerlink" title="4.1 LayoutInflater 原理与参数解析"></a>4.1 LayoutInflater 原理与参数解析</h3><p><a href="https://juejin.cn/post/6844903919286485000" target="_blank" rel="noopener">参考：反思|Android LayoutInflater机制的设计与实现</a></p><h4 id="获取-LayoutInflater-三种方式"><a href="#获取-LayoutInflater-三种方式" class="headerlink" title="获取 LayoutInflater 三种方式"></a>获取 LayoutInflater 三种方式</h4><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//获取 LayoutInflater</span><span class="token comment" spellcheck="true">//1、通过 LayoutInflater 的静态方法 from 获取，内部调用的是第二种</span><span class="token keyword">val</span> layoutInflater1<span class="token operator">:</span> LayoutInflater <span class="token operator">=</span> LayoutInflater<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//2、通过系统服务 getSystemService 方法获取</span><span class="token keyword">val</span> layoutInflater2<span class="token operator">:</span> LayoutInflater <span class="token operator">=</span>    <span class="token function">getSystemService</span><span class="token punctuation">(</span>Context<span class="token punctuation">.</span>LAYOUT_INFLATER_SERVICE<span class="token punctuation">)</span> <span class="token keyword">as</span> LayoutInflater<span class="token comment" spellcheck="true">//3、如果是在 Activity 或 Fragment 可直接获取到实例</span><span class="token keyword">val</span> layoutInflater3<span class="token operator">:</span> LayoutInflater <span class="token operator">=</span> layoutInflater <span class="token comment" spellcheck="true">//相当于调用 getLayoutInflater()</span><span class="token comment" spellcheck="true">//三种方式在 Activity 范围内是单例</span>Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"Jay"</span><span class="token punctuation">,</span> <span class="token string">"layoutInflater1:<span class="token interpolation"><span class="token delimiter variable">${</span>layoutInflater1<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"Jay"</span><span class="token punctuation">,</span> <span class="token string">"layoutInflater2:<span class="token interpolation"><span class="token delimiter variable">${</span>layoutInflater2<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"Jay"</span><span class="token punctuation">,</span> <span class="token string">"layoutInflater3:<span class="token interpolation"><span class="token delimiter variable">${</span>layoutInflater3<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//2021-09-06 23:41:52.925 6353-6353/com.jay.vbhelper D/Jay: layoutInflater1:31503528</span><span class="token comment" spellcheck="true">//2021-09-06 23:41:52.925 6353-6353/com.jay.vbhelper D/Jay: layoutInflater2:31503528</span><span class="token comment" spellcheck="true">//2021-09-06 23:41:52.925 6353-6353/com.jay.vbhelper D/Jay: layoutInflater3:31503528</span></code></pre><p>无论哪种方式获取最终都会走到 ContextThemeWrapper 类中 getSystemService</p><h4 id="PhoneLayoutInflater-创建流程"><a href="#PhoneLayoutInflater-创建流程" class="headerlink" title="PhoneLayoutInflater 创建流程"></a>PhoneLayoutInflater 创建流程</h4><p>获取 LayoutInflater 三种方式最终会调到 ContextThemeWrapper#getSystemService</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//class ContextThemeWrapper extends ContextWrapper</span><span class="token annotation builtin">@Override</span><span class="token keyword">public</span> Object <span class="token function">getSystemService</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>LAYOUT_INFLATER_SERVICE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mInflater <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            mInflater <span class="token operator">=</span> LayoutInflater<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token function">getBaseContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cloneInContext</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> mInflater<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">getBaseContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSystemService</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>cloneInContext 是 LayoutInflater 接口的方法，LayoutInflater 唯一实现类是 PhoneLayoutInflater</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//class PhoneLayoutInflater extends LayoutInflater</span><span class="token keyword">public</span> LayoutInflater <span class="token function">cloneInContext</span><span class="token punctuation">(</span>Context newContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> new <span class="token function">PhoneLayoutInflater</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newContext<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="布局填充流程"><a href="#布局填充流程" class="headerlink" title="布局填充流程"></a>布局填充流程</h4><p>方法签名</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token number">1</span><span class="token punctuation">.</span>public View <span class="token function">inflate</span><span class="token punctuation">(</span>XmlPullParser parser<span class="token punctuation">,</span> <span class="token annotation builtin">@Nullable</span> ViewGroup root<span class="token punctuation">)</span><span class="token number">2</span><span class="token punctuation">.</span>public View <span class="token function">inflate</span><span class="token punctuation">(</span><span class="token annotation builtin">@LayoutRes</span> int resource<span class="token punctuation">,</span> <span class="token annotation builtin">@Nullable</span> ViewGroup root<span class="token punctuation">)</span><span class="token number">3</span><span class="token punctuation">.</span>public View <span class="token function">inflate</span><span class="token punctuation">(</span><span class="token annotation builtin">@LayoutRes</span> int resource<span class="token punctuation">,</span> <span class="token annotation builtin">@Nullable</span> ViewGroup root<span class="token punctuation">,</span> boolean attachToRoot<span class="token punctuation">)</span><span class="token number">4</span><span class="token punctuation">.</span>public View <span class="token function">inflate</span><span class="token punctuation">(</span>XmlPullParser parser<span class="token punctuation">,</span> <span class="token annotation builtin">@Nullable</span> ViewGroup root<span class="token punctuation">,</span> boolean attachToRoot<span class="token punctuation">)</span></code></pre><p>四个 inflate 的重载方法最终都会调用到第四个，下面是四个方法的使用</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//调用 LayoutInflater.inflate 的四个方法重载</span><span class="token comment" spellcheck="true">//如果传入的 root 为 null ，此时会将 Xml 布局生成的根 View 对象直接返回</span><span class="token keyword">val</span> view1_1 <span class="token operator">=</span> layoutInflater3<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>layout_view<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//这种方式加载的布局不需要再次addView(),否则：Caused by: java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child's parent first.</span><span class="token comment" spellcheck="true">//如果传入的 root 不为 null 且 attachToRoot 为 true，此时会将 Xml 布局生成的根 View 通过 addView 方法携带布局参数添加到 root 中</span><span class="token comment" spellcheck="true">//如果 root 参数不为空 和 view2_1 一样</span><span class="token keyword">val</span> view1_2 <span class="token operator">=</span> layoutInflater3<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>layout_view<span class="token punctuation">,</span> binding<span class="token punctuation">.</span>clContainer<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//第一个参数代表所要加载的布局，第二个参数是ViewGroup，这个参数需要与第3个参数配合使用，attachToRoot如果为true就把布局添加到ViewGroup中；若为false则只采用ViewGroup的LayoutParams作为测量的依据却不直接添加到ViewGroup中。</span><span class="token keyword">val</span> view2_1 <span class="token operator">=</span> layoutInflater3<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>layout_view<span class="token punctuation">,</span> binding<span class="token punctuation">.</span>clContainer<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果传入的 root 不为 null 且 attachToRoot 为 false，此时会给 Xml 布局生成的根 View 设置布局参数</span><span class="token keyword">val</span> view2_2 <span class="token operator">=</span> layoutInflater3<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>layout_view<span class="token punctuation">,</span> binding<span class="token punctuation">.</span>clContainer<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token keyword">val</span> parser<span class="token operator">:</span> XmlResourceParser <span class="token operator">=</span> resources<span class="token punctuation">.</span><span class="token function">getLayout</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>layout_view<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//这两个重载方法不常用</span><span class="token keyword">val</span> view3 <span class="token operator">=</span> layoutInflater3<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>parser<span class="token punctuation">,</span> binding<span class="token punctuation">.</span>clContainer<span class="token punctuation">)</span><span class="token keyword">val</span> view4 <span class="token operator">=</span> layoutInflater3<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>parser<span class="token punctuation">,</span> binding<span class="token punctuation">.</span>clContainer<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>binding<span class="token punctuation">.</span>clContainer<span class="token punctuation">.</span><span class="token function">addView</span><span class="token punctuation">(</span>view1_1<span class="token punctuation">)</span></code></pre><p>无论是 Activity 中 setContentView 加载内容还是 DecorView 加载屏幕根视图都是通过 LayoutInflater 加载。</p><p>inflate 方法，详细的加载过程会单独整理一篇文章</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> View <span class="token function">inflate</span><span class="token punctuation">(</span>XmlPullParser parser<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> ViewGroup root<span class="token punctuation">,</span> <span class="token keyword">boolean</span> attachToRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mConstructorArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Trace<span class="token punctuation">.</span><span class="token function">traceBegin</span><span class="token punctuation">(</span>Trace<span class="token punctuation">.</span>TRACE_TAG_VIEW<span class="token punctuation">,</span> <span class="token string">"inflate"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Context inflaterContext <span class="token operator">=</span> mContext<span class="token punctuation">;</span>        <span class="token keyword">final</span> AttributeSet attrs <span class="token operator">=</span> Xml<span class="token punctuation">.</span><span class="token function">asAttributeSet</span><span class="token punctuation">(</span>parser<span class="token punctuation">)</span><span class="token punctuation">;</span>        Context lastContext <span class="token operator">=</span> <span class="token punctuation">(</span>Context<span class="token punctuation">)</span> mConstructorArgs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        mConstructorArgs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> inflaterContext<span class="token punctuation">;</span>        View result <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">advanceToRootNode</span><span class="token punctuation">(</span>parser<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> String name <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>TAG_MERGE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>attachToRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InflateException</span><span class="token punctuation">(</span><span class="token string">"&lt;merge /> can be used only with a valid "</span><span class="token operator">+</span> <span class="token string">"ViewGroup root and attachToRoot=true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                                <span class="token comment" spellcheck="true">//merge 根视图单独处理</span>                <span class="token function">rInflate</span><span class="token punctuation">(</span>parser<span class="token punctuation">,</span> root<span class="token punctuation">,</span> inflaterContext<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//Temp 是在 xml 中找到的根视图</span>                <span class="token keyword">final</span> View temp <span class="token operator">=</span> <span class="token function">createViewFromTag</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> name<span class="token punctuation">,</span> inflaterContext<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span><span class="token punctuation">;</span>                ViewGroup<span class="token punctuation">.</span>LayoutParams params <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 创建与根匹配的布局参数（如果提供）</span>                    params <span class="token operator">=</span> root<span class="token punctuation">.</span><span class="token function">generateLayoutParams</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>attachToRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 如果我们不附加，请为 temp 设置根布局的布局参数</span>                        temp<span class="token punctuation">.</span><span class="token function">setLayoutParams</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 将所有处于临时状态的孩子都根据其上下文进行布局填充。</span>                <span class="token function">rInflateChildren</span><span class="token punctuation">(</span>parser<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 将所有视图添加到 root</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> attachToRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    root<span class="token punctuation">.</span><span class="token function">addView</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 返回传入的 root 还是在 xml 中找到的顶视图。</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>attachToRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result <span class="token operator">=</span> temp<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>         <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>LayoutInflater 参数说明</strong></p><p><code>layoutResID：</code>代表所要加载的布局资源id，</p><p><code>root：</code>是ViewGroup类型，这个参数需要与第3个参数配合使用，</p><p><code>attachToRoot：</code>如果为<code>true</code>就把布局添加到 <code>root</code> 中；若为<code>false</code>则只采用<code>ViewGroup</code>的<code>LayoutParams</code>作为测量的依据却不直接添加到<code>ViewGroup</code>中。</p><p><code>parser：</code>包含布局层次结构描述的 XML dom 节点。</p><p><strong>LayoutInflater.Factory 接口的扩展功能</strong></p><p><code>LayoutInflater</code>设计了一个<code>LayoutInflater.Factory</code>接口，该接口设计得非常巧妙：在<code>xml</code>解析过程中，开发者可以通过配置该接口对<code>View</code>的创建过程进行拦截：<strong>通过new的方式创建控件以避免大量地使用反射</strong>,<code>Factory</code>接口的意义是在<code>xml</code>解析过程中，开发者可以通过配置该接口对<code>View</code>的创建过程进行拦截</p><h4 id="LayoutInflater-总结"><a href="#LayoutInflater-总结" class="headerlink" title="LayoutInflater 总结"></a>LayoutInflater 总结</h4><p>获取 LayoutInflater实例最终都会走到 ContextThemeWrapper 类中 getSystemService 构建一个局部单例的 <strong>PhoneLayoutInflater</strong> 实例。</p><p>LayoutInflater 布局填充有四个重载方法，最终都会调用到同一个方法，再根据传递的参数做不同的加载处理</p><h3 id="4-2-ActivityMainBinding-类的绑定过程"><a href="#4-2-ActivityMainBinding-类的绑定过程" class="headerlink" title="4.2 ActivityMainBinding 类的绑定过程"></a>4.2 ActivityMainBinding 类的绑定过程</h3><h4 id="inflate-过程"><a href="#inflate-过程" class="headerlink" title="inflate 过程"></a>inflate 过程</h4><p>View 类中通过调用apt 自动生成的绑定类的inflate方法或者 bind 方法获取绑定类</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//CustomView</span><span class="token keyword">val</span> layoutInflater<span class="token operator">:</span> LayoutInflater <span class="token operator">=</span> LayoutInflater<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token keyword">val</span> binding <span class="token operator">=</span> LayoutViewBinding<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>layoutInflater<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//SecondFragment</span><span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreateView</span><span class="token punctuation">(</span>inflater<span class="token operator">:</span> LayoutInflater<span class="token punctuation">,</span> container<span class="token operator">:</span> ViewGroup<span class="token operator">?</span><span class="token punctuation">,</span> savedIS<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> View <span class="token punctuation">{</span>    _binding <span class="token operator">=</span> FragmentSecondBinding<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>inflater<span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> binding<span class="token punctuation">.</span>root<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//include+merge 只能手动调用绑定类的bind方法</span><span class="token keyword">val</span> layoutInfoMergeBinding <span class="token operator">=</span> LayoutInfoMergeBinding<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>binding<span class="token punctuation">.</span>root<span class="token punctuation">)</span></code></pre><p>绑定类的 inflate 方法，通过传入的 LayoutInflater 将 layout 填充为 View</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//class FragmentSecondBinding implements ViewBinding</span><span class="token annotation builtin">@NonNull</span><span class="token keyword">public</span> static FragmentSecondBinding <span class="token function">inflate</span><span class="token punctuation">(</span><span class="token annotation builtin">@NonNull</span> LayoutInflater inflater<span class="token punctuation">,</span>    <span class="token annotation builtin">@Nullable</span> ViewGroup parent<span class="token punctuation">,</span> boolean attachToParent<span class="token punctuation">)</span> <span class="token punctuation">{</span>  View root <span class="token operator">=</span> inflater<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>fragment_second<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这里的 attachToParent 参数为 true 时不知为何不传入 LayoutInflater 来 addView 而是自己单独做了判断</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>attachToParent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    parent<span class="token punctuation">.</span><span class="token function">addView</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token function">bind</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="bind-过程"><a href="#bind-过程" class="headerlink" title="bind 过程"></a>bind 过程</h4><p>从 inflate 过程填充的视图中(或者是从外部传入的 View)实例化所有控件并构建绑定类</p><pre class=" language-kotlin"><code class="language-kotlin">  <span class="token annotation builtin">@NonNull</span>  <span class="token keyword">public</span> static FragmentSecondBinding <span class="token function">bind</span><span class="token punctuation">(</span><span class="token annotation builtin">@NonNull</span> View rootView<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//此方法的主体是以您不会编写的方式生成的。这样做是为了优化已编译的字节码的大小和性能。</span>    int id<span class="token punctuation">;</span>    missingId<span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//根布局中的普通控件</span>      id <span class="token operator">=</span> R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>button_second<span class="token punctuation">;</span>      Button buttonSecond <span class="token operator">=</span> ViewBindings<span class="token punctuation">.</span><span class="token function">findChildViewById</span><span class="token punctuation">(</span>rootView<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>buttonSecond <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">break</span> missingId<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//根布局中的 include 标签</span>      id <span class="token operator">=</span> R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>include_layout<span class="token punctuation">;</span>      View includeLayout <span class="token operator">=</span> ViewBindings<span class="token punctuation">.</span><span class="token function">findChildViewById</span><span class="token punctuation">(</span>rootView<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>includeLayout <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">break</span> missingId<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      LayoutInfoBinding binding_includeLayout <span class="token operator">=</span> LayoutInfoBinding<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>includeLayout<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//ViewStub标签</span>      id <span class="token operator">=</span> R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>layout_view_stub<span class="token punctuation">;</span>      ViewStub layoutViewStub <span class="token operator">=</span> ViewBindings<span class="token punctuation">.</span><span class="token function">findChildViewById</span><span class="token punctuation">(</span>rootView<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>layoutViewStub <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">break</span> missingId<span class="token punctuation">;</span>      <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//自定义 View</span>      id <span class="token operator">=</span> R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>name<span class="token punctuation">;</span>      CustomView name <span class="token operator">=</span> ViewBindings<span class="token punctuation">.</span><span class="token function">findChildViewById</span><span class="token punctuation">(</span>rootView<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">break</span> missingId<span class="token punctuation">;</span>      <span class="token punctuation">}</span>             <span class="token comment" spellcheck="true">//include+merge 没有生成对应的类型，只能手动调用绑定类的bind方法</span>      <span class="token comment" spellcheck="true">//构建绑定类，并将所有控件赋值给类属性</span>      <span class="token keyword">return</span> new <span class="token function">FragmentSecondBinding</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ConstraintLayout<span class="token punctuation">)</span> rootView<span class="token punctuation">,</span> buttonSecond<span class="token punctuation">,</span> flSecond<span class="token punctuation">,</span>          binding_includeLayout<span class="token punctuation">,</span> layoutViewStub<span class="token punctuation">,</span> llInfo<span class="token punctuation">,</span> name<span class="token punctuation">,</span> textviewSecond<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果有任何一个控件在 findChildViewById 过程中没有被找到就会抛NPE异常</span>    String missingId <span class="token operator">=</span> rootView<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceName</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> new <span class="token function">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"Missing required view with ID: "</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>missingId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>遍历根视图匹配布局文件中的id并通过findViewById方法返回View实例</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//ViewBindings</span><span class="token comment" spellcheck="true">/** Like `findViewById` but skips the view itself. */</span><span class="token annotation builtin">@Nullable</span><span class="token keyword">public</span> static <span class="token operator">&lt;</span>T extends View<span class="token operator">></span> T <span class="token function">findChildViewById</span><span class="token punctuation">(</span>View rootView<span class="token punctuation">,</span> <span class="token annotation builtin">@IdRes</span> int id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>rootView instanceof ViewGroup<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> ViewGroup rootViewGroup <span class="token operator">=</span> <span class="token punctuation">(</span>ViewGroup<span class="token punctuation">)</span> rootView<span class="token punctuation">;</span>    <span class="token keyword">final</span> int childCount <span class="token operator">=</span> rootViewGroup<span class="token punctuation">.</span><span class="token function">getChildCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> childCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> T view <span class="token operator">=</span> rootViewGroup<span class="token punctuation">.</span><span class="token function">getChildAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findViewById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>view <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> view<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="绑定过程总结"><a href="#绑定过程总结" class="headerlink" title="绑定过程总结"></a>绑定过程总结</h4><p>DataBinding 借助 AGP 会为所有布局文件自动生成绑定类</p><p>绑定类的 inflate 方法通过传入的布局填充器 LayoutInflater 以及自动收集的根布局 id 加载出根布局 rootView 然后传给 bind 方法实例化控件</p><p>绑定类的 bind 方法通过传入的根布局以及自动收集的控件 id 实例化所有控件 并构建绑定类</p><h3 id="4-3-ActivityMainBinding-类的生成过程"><a href="#4-3-ActivityMainBinding-类的生成过程" class="headerlink" title="4.3 ActivityMainBinding 类的生成过程"></a>4.3 ActivityMainBinding 类的生成过程</h3><p><a href="https://juejin.cn/post/6844904106268557326" target="_blank" rel="noopener">参考：ViewBinding 的本质</a></p><p><a href="https://mvnrepository.com/artifact/androidx.databinding/databinding-compiler-common" target="_blank" rel="noopener">DataBinding Compiler Common</a></p><p>依赖源码方便查看</p><pre class=" language-groovy"><code class="language-groovy"><span class="token comment" spellcheck="true">//todo 依赖 databinding-compiler 方便查看 ViewBinding 类的生成过程</span><span class="token comment" spellcheck="true">// https://mvnrepository.com/artifact/androidx.databinding/databinding-compiler-common</span>implementation group<span class="token punctuation">:</span> <span class="token string">'androidx.databinding'</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'databinding-compiler-common'</span><span class="token punctuation">,</span> version<span class="token punctuation">:</span> <span class="token string">'7.0.1'</span><span class="token comment" spellcheck="true">// https://mvnrepository.com/artifact/com.android.tools.build/gradle</span>implementation group<span class="token punctuation">:</span> <span class="token string">'com.android.tools.build'</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'gradle'</span><span class="token punctuation">,</span> version<span class="token punctuation">:</span> <span class="token string">'7.0.1'</span></code></pre><p>ViewBinding 是属于 dataBinding 库里面的一个小功能,对于解析布局文件生成绑定类的逻辑是通用的，</p><h4 id="阶段一：解析xml布局文件"><a href="#阶段一：解析xml布局文件" class="headerlink" title="阶段一：解析xml布局文件"></a>阶段一：解析xml布局文件</h4><p><strong>LayoutXmlProcessor</strong>：处理布局 XML，剥离绑定属性和元素，并将信息写入带注解的类文件以供注释处理器使用</p><p><strong>processResources</strong>：假装这个方法就是布局文件改动后调用的入口方法（应该是由AGP 触发，暂时未找到）</p><pre class=" language-java"><code class="language-java">android<span class="token punctuation">.</span>databinding<span class="token punctuation">.</span>tool<span class="token punctuation">.</span>LayoutXmlProcessor<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">processResources</span><span class="token punctuation">(</span>ResourceInput input<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isViewBindingEnabled<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isDataBindingEnabled<span class="token punctuation">)</span>        <span class="token keyword">throws</span> ParserConfigurationException<span class="token punctuation">,</span> SAXException<span class="token punctuation">,</span> XPathExpressionException<span class="token punctuation">,</span>        IOException <span class="token punctuation">{</span>    ProcessFileCallback callback <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProcessFileCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//省略回调代码</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//布局文件的改动输入源支持增量构建</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">isIncremental</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">processIncrementalInputFiles</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">processAllInputFiles</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>processIncrementalInputFiles 处理增量输入（Added、Removed、Changed）</p><p>processAllInputFiles 处理全部输入</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//遍历文件</span><span class="token keyword">for</span> <span class="token punctuation">(</span>File firstLevel <span class="token operator">:</span> input<span class="token punctuation">.</span><span class="token function">getRootInputFolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//处理 layout_xx 目录下面的 xxx.xml 文件</span><span class="token keyword">if</span> <span class="token punctuation">(</span>LAYOUT_FOLDER_FILTER<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>firstLevel<span class="token punctuation">,</span> firstLevel<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    callback<span class="token punctuation">.</span><span class="token function">processLayoutFolder</span><span class="token punctuation">(</span>firstLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//noinspection ConstantConditions</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>File xmlFile <span class="token operator">:</span> firstLevel<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span>XML_FILE_FILTER<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        callback<span class="token punctuation">.</span><span class="token function">processLayoutFile</span><span class="token punctuation">(</span>xmlFile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>ProcessFileCallback 扫描文件后的回调</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">processLayoutFile</span><span class="token punctuation">(</span>File file<span class="token punctuation">)</span>        <span class="token keyword">throws</span> ParserConfigurationException<span class="token punctuation">,</span> SAXException<span class="token punctuation">,</span> XPathExpressionException<span class="token punctuation">,</span>        IOException <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//处理单个文件，</span>    <span class="token function">processSingleFile</span><span class="token punctuation">(</span>RelativizableFile<span class="token punctuation">.</span><span class="token function">fromAbsoluteFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token function">convertToOutFile</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">,</span> isViewBindingEnabled<span class="token punctuation">,</span> isDataBindingEnabled<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>processSingleFile </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">processSingleFile</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> RelativizableFile input<span class="token punctuation">,</span> <span class="token annotation punctuation">@NonNull</span> File output<span class="token punctuation">,</span>        <span class="token keyword">boolean</span> isViewBindingEnabled<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isDataBindingEnabled<span class="token punctuation">)</span>        <span class="token keyword">throws</span> ParserConfigurationException<span class="token punctuation">,</span> SAXException<span class="token punctuation">,</span> XPathExpressionException<span class="token punctuation">,</span>        IOException <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//解析xml文件 封账布局文件扫描类</span>    <span class="token keyword">final</span> ResourceBundle<span class="token punctuation">.</span>LayoutFileBundle bindingLayout <span class="token operator">=</span> LayoutFileParser            <span class="token punctuation">.</span><span class="token function">parseXml</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> output<span class="token punctuation">,</span> mResourceBundle<span class="token punctuation">.</span><span class="token function">getAppPackage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mOriginalFileLookup<span class="token punctuation">,</span>                    isViewBindingEnabled<span class="token punctuation">,</span> isDataBindingEnabled<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bindingLayout <span class="token operator">==</span> null            <span class="token operator">||</span> <span class="token punctuation">(</span>bindingLayout<span class="token punctuation">.</span><span class="token function">isBindingData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> bindingLayout<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//添加到map缓存起来</span>    mResourceBundle<span class="token punctuation">.</span><span class="token function">addLayoutBundle</span><span class="token punctuation">(</span>bindingLayout<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>LayoutFileParser</strong>：获取 XML 文件列表并创建可以持久化或转换为 LayoutBinder 的ResourceBundle列表</p><p>android.databinding.tool.store public final class LayoutFileParser</p><p>parseXml:路径、编码、校验等</p><p>parseOriginalXml :将布局文件解析为描述类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> ResourceBundle<span class="token punctuation">.</span>LayoutFileBundle <span class="token function">parseOriginalXml</span><span class="token punctuation">(</span>        <span class="token annotation punctuation">@NonNull</span> <span class="token keyword">final</span> RelativizableFile originalFile<span class="token punctuation">,</span> <span class="token annotation punctuation">@NonNull</span> <span class="token keyword">final</span> String pkg<span class="token punctuation">,</span>        <span class="token annotation punctuation">@NonNull</span> <span class="token keyword">final</span> String encoding<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isViewBindingEnabled<span class="token punctuation">,</span>        <span class="token keyword">boolean</span> isDataBindingEnabled<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//layout 标签判断databinding</span>XMLParser<span class="token punctuation">.</span>ElementContext root <span class="token operator">=</span> expr<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> isBindingData <span class="token operator">=</span> <span class="token string">"layout"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>elmName<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//dataBinding</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isBindingData<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isDataBindingEnabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>        L<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span>ErrorMessages<span class="token punctuation">.</span>FOUND_LAYOUT_BUT_NOT_ENABLED<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    data <span class="token operator">=</span> <span class="token function">getDataNode</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    rootView <span class="token operator">=</span> <span class="token function">getViewNode</span><span class="token punctuation">(</span>original<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isViewBindingEnabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//viewBindingIgnore 根布局添加这个属性为true可以跳过生成绑定类的过程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"true"</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token function">attributeMap</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"tools:viewBindingIgnore"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        L<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"Ignoring %s for view binding"</span><span class="token punctuation">,</span> originalFile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    data <span class="token operator">=</span> null<span class="token punctuation">;</span>    rootView <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//dataBinding &lt;include> 元素不支持作为 &lt;merge> 元素的直接子元素</span><span class="token keyword">boolean</span> isMerge <span class="token operator">=</span> <span class="token string">"merge"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>rootView<span class="token punctuation">.</span>elmName<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isBindingData <span class="token operator">&amp;&amp;</span> isMerge <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">filter</span><span class="token punctuation">(</span>rootView<span class="token punctuation">,</span> <span class="token string">"include"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//public static final String INCLUDE_INSIDE_MERGE = "&lt;include> elements are not supported as direct children of &lt;merge> elements";</span>    L<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span>ErrorMessages<span class="token punctuation">.</span>INCLUDE_INSIDE_MERGE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span>String rootViewType <span class="token operator">=</span> <span class="token function">getViewName</span><span class="token punctuation">(</span>rootView<span class="token punctuation">)</span><span class="token punctuation">;</span>String rootViewId <span class="token operator">=</span> <span class="token function">attributeMap</span><span class="token punctuation">(</span>rootView<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"android:id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//构建布局描述的封装类</span>ResourceBundle<span class="token punctuation">.</span>LayoutFileBundle bundle <span class="token operator">=</span>    <span class="token keyword">new</span> <span class="token class-name">ResourceBundle<span class="token punctuation">.</span>LayoutFileBundle</span><span class="token punctuation">(</span>        originalFile<span class="token punctuation">,</span> xmlNoExtension<span class="token punctuation">,</span> original<span class="token punctuation">.</span><span class="token function">getParentFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pkg<span class="token punctuation">,</span>        isMerge<span class="token punctuation">,</span> isBindingData<span class="token punctuation">,</span> rootViewType<span class="token punctuation">,</span> rootViewId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">final</span> String newTag <span class="token operator">=</span> original<span class="token punctuation">.</span><span class="token function">getParentFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'/'</span> <span class="token operator">+</span> xmlNoExtension<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//data 数据只有 databinding 才会有的元素，viewBinding 是不会去解析的</span><span class="token function">parseData</span><span class="token punctuation">(</span>original<span class="token punctuation">,</span> data<span class="token punctuation">,</span> bundle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//解析表达式，这里面会循环遍历元素，解析 view 的 id、tag、include、fragment 等等 xml 相关的元素，并且还有 databinding 相关的 @={ 的表达式，最后将结果缓存起来</span><span class="token function">parseExpressions</span><span class="token punctuation">(</span>newTag<span class="token punctuation">,</span> rootView<span class="token punctuation">,</span> isMerge<span class="token punctuation">,</span> bundle<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="阶段二：输出描述文件"><a href="#阶段二：输出描述文件" class="headerlink" title="阶段二：输出描述文件"></a>阶段二：输出描述文件</h4><p><strong>LayoutXmlProcessor</strong></p><p><strong>writeLayoutInfoFiles</strong>：这个方法的执行点可以在AGP里面找到，task 为：<strong>com.android.build.gradle.tasks.MergeResources</strong></p><p><strong>MergeResources</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doTaskAction</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> InputChanges changedInputs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    SingleFileProcessor dataBindingLayoutProcessor <span class="token operator">=</span> <span class="token function">maybeCreateLayoutProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dataBindingLayoutProcessor <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        dataBindingLayoutProcessor<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//maybeCreateLayoutProcessor</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SingleFileProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> LayoutXmlProcessor <span class="token function">getProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> processor<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">processSingleFile</span><span class="token punctuation">(</span>            <span class="token annotation punctuation">@NonNull</span> File inputFile<span class="token punctuation">,</span>            <span class="token annotation punctuation">@NonNull</span> File outputFile<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Nullable</span> Boolean inputFileIsFromDependency<span class="token punctuation">)</span>            <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">processSingleFile</span><span class="token punctuation">(</span>                        normalizedInputFile<span class="token punctuation">,</span>                        outputFile<span class="token punctuation">,</span>                        <span class="token function">getViewBindingEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token function">getDataBindingEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> JAXBException <span class="token punctuation">{</span>        <span class="token function">getProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">writeLayoutInfoFiles</span><span class="token punctuation">(</span><span class="token function">getDataBindingLayoutInfoOutFolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAsFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出路径可以从这里查看</span>artifacts<span class="token punctuation">.</span><span class="token function">setInitialProvider</span><span class="token punctuation">(</span>taskProvider<span class="token punctuation">,</span> MergeResources<span class="token operator">:</span><span class="token operator">:</span>getDataBindingLayoutInfoOutFolder<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">withName</span><span class="token punctuation">(</span><span class="token string">"out"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span> mergeType <span class="token operator">==</span> MERGE<span class="token operator">?</span> DATA_BINDING_LAYOUT_INFO_TYPE_MERGE<span class="token punctuation">.</span>INSTANCE                        <span class="token operator">:</span> DATA_BINDING_LAYOUT_INFO_TYPE_PACKAGE<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>writeLayoutInfoFiles</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeLayoutInfoFiles</span><span class="token punctuation">(</span>File xmlOutDir<span class="token punctuation">,</span> JavaFileWriter writer<span class="token punctuation">)</span> <span class="token keyword">throws</span> JAXBException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//遍历之前收集到的所有 LayoutFileBundle，写入 xmlOutDir 路径</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ResourceBundle<span class="token punctuation">.</span>LayoutFileBundle layout <span class="token operator">:</span> mResourceBundle            <span class="token punctuation">.</span><span class="token function">getAllLayoutFileBundlesInSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">writeXmlFile</span><span class="token punctuation">(</span>writer<span class="token punctuation">,</span> xmlOutDir<span class="token punctuation">,</span> layout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>writeXmlFile</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> void <span class="token function">writeXmlFile</span><span class="token punctuation">(</span>JavaFileWriter writer<span class="token punctuation">,</span> File xmlOutDir<span class="token punctuation">,</span>        ResourceBundle<span class="token punctuation">.</span>LayoutFileBundle layout<span class="token punctuation">)</span>        throws JAXBException <span class="token punctuation">{</span>    String filename <span class="token operator">=</span> <span class="token function">generateExportFileName</span><span class="token punctuation">(</span>layout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  fileName + '-' + dirName + ".xml";</span>          <span class="token comment" spellcheck="true">//遍历之前收集到的所有 LayoutFileBundle，写入 xmlOutDir 路径</span>    writer<span class="token punctuation">.</span><span class="token function">writeToFile</span><span class="token punctuation">(</span>new <span class="token function">File</span><span class="token punctuation">(</span>xmlOutDir<span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">,</span> layout<span class="token punctuation">.</span><span class="token function">toXML</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>描述文件的生成路径为：app/build/intermediates/data_binding_layout_info_type_merge/debug/out</p><pre class=" language-xml"><code class="language-xml">//fragment_second-layout.xml<span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" standalone="yes"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Layout</span> <span class="token attr-name">directory</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>layout<span class="token punctuation">"</span></span> <span class="token attr-name">filePath</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app/src/main/res/layout/fragment_second.xml<span class="token punctuation">"</span></span>    <span class="token attr-name">isBindingData</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">isMerge</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">layout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fragment_second<span class="token punctuation">"</span></span>    <span class="token attr-name">modulePackage</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.jay.vbhelper<span class="token punctuation">"</span></span> <span class="token attr-name">rootNodeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>androidx.constraintlayout.widget.ConstraintLayout<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Targets</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Target</span> <span class="token attr-name">tag</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>layout/fragment_second_0<span class="token punctuation">"</span></span>            <span class="token attr-name">view</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>androidx.constraintlayout.widget.ConstraintLayout<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Expressions</span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span> <span class="token attr-name">endLine</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>78<span class="token punctuation">"</span></span> <span class="token attr-name">endOffset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>51<span class="token punctuation">"</span></span> <span class="token attr-name">startLine</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">startOffset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Target</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Target</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/ll_info<span class="token punctuation">"</span></span> <span class="token attr-name">tag</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>binding_1<span class="token punctuation">"</span></span>            <span class="token attr-name">view</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>androidx.appcompat.widget.LinearLayoutCompat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Expressions</span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span> <span class="token attr-name">endLine</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>51<span class="token punctuation">"</span></span> <span class="token attr-name">endOffset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span> <span class="token attr-name">startLine</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>9<span class="token punctuation">"</span></span> <span class="token attr-name">startOffset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Target</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Target</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/include_layout<span class="token punctuation">"</span></span> <span class="token attr-name">include</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>layout_info<span class="token punctuation">"</span></span> <span class="token attr-name">tag</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>binding_1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Expressions</span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span> <span class="token attr-name">endLine</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>31<span class="token punctuation">"</span></span> <span class="token attr-name">endOffset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>42<span class="token punctuation">"</span></span> <span class="token attr-name">startLine</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>29<span class="token punctuation">"</span></span> <span class="token attr-name">startOffset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Target</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Target</span> <span class="token attr-name">include</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>layout_info_merge<span class="token punctuation">"</span></span> <span class="token attr-name">tag</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>binding_1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Expressions</span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span> <span class="token attr-name">endLine</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>35<span class="token punctuation">"</span></span> <span class="token attr-name">endOffset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>53<span class="token punctuation">"</span></span> <span class="token attr-name">startLine</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>35<span class="token punctuation">"</span></span> <span class="token attr-name">startOffset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Target</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Targets</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Layout</span><span class="token punctuation">></span></span></code></pre><h4 id="阶段三：输出绑定类"><a href="#阶段三：输出绑定类" class="headerlink" title="阶段三：输出绑定类"></a>阶段三：输出绑定类</h4><p>AGP Task DataBindingGenBaseClassesTask 触发</p><p>com.android.build.gradle.internal.tasks.databinding.DataBindingGenBaseClassesTask</p><p>DataBindingGenBaseClassesTask</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@TaskAction</span><span class="token keyword">fun</span> <span class="token function">writeBaseClasses</span><span class="token punctuation">(</span>inputs<span class="token operator">:</span> IncrementalTaskInputs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// TODO extend NewIncrementalTask when moved to new API so that we can remove the manual call to recordTaskAction</span>    <span class="token function">recordTaskAction</span><span class="token punctuation">(</span>analyticsService<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO figure out why worker execution makes the task flake.</span>        <span class="token comment" spellcheck="true">// Some files cannot be accessed even though they show up when directory listing is</span>        <span class="token comment" spellcheck="true">// invoked.</span>        <span class="token comment" spellcheck="true">// b/69652332</span>        <span class="token keyword">val</span> args <span class="token operator">=</span> <span class="token function">buildInputArgs</span><span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>        <span class="token function">CodeGenerator</span><span class="token punctuation">(</span>            args<span class="token punctuation">,</span>            sourceOutFolder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>asFile<span class="token punctuation">,</span>            Logger<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>DataBindingGenBaseClassesTask<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">)</span><span class="token punctuation">,</span>            encodeErrors<span class="token punctuation">,</span>            <span class="token function">collectResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//触发生成流程</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//绑定类生成器</span><span class="token keyword">class</span> CodeGenerator <span class="token annotation builtin">@Inject</span> <span class="token keyword">constructor</span><span class="token punctuation">(</span>    <span class="token keyword">val</span> args<span class="token operator">:</span> LayoutInfoInput<span class="token punctuation">.</span>Args<span class="token punctuation">,</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> sourceOutFolder<span class="token operator">:</span> File<span class="token punctuation">,</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> logger<span class="token operator">:</span> Logger<span class="token punctuation">,</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> encodeErrors<span class="token operator">:</span> Boolean<span class="token punctuation">,</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> symbolTables<span class="token operator">:</span> List<span class="token operator">&lt;</span>SymbolTable<span class="token operator">></span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">:</span> Runnable<span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">initLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token function">BaseDataBinder</span><span class="token punctuation">(</span><span class="token function">LayoutInfoInput</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>symbolTables <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token operator">::</span>getRPackage <span class="token keyword">else</span> <span class="token keyword">null</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//生成逻辑</span>                <span class="token punctuation">.</span><span class="token function">generateAll</span><span class="token punctuation">(</span>DataBindingBuilder<span class="token punctuation">.</span><span class="token function">GradleFileWriter</span><span class="token punctuation">(</span>sourceOutFolder<span class="token punctuation">.</span>absolutePath<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token function">clearLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">..</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//sourceOutFolder路径信息</span>creationConfig<span class="token punctuation">.</span>artifacts<span class="token punctuation">.</span><span class="token function">setInitialProvider</span><span class="token punctuation">(</span>    taskProvider<span class="token punctuation">,</span>    DataBindingGenBaseClassesTask<span class="token operator">::</span>sourceOutFolder<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withName</span><span class="token punctuation">(</span><span class="token string">"out"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span>InternalArtifactType<span class="token punctuation">.</span>DATA_BINDING_BASE_CLASS_SOURCE_OUT<span class="token punctuation">)</span></code></pre><p>BaseDataBinder</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Suppress</span><span class="token punctuation">(</span><span class="token string">"unused"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// used by tools</span><span class="token keyword">class</span> <span class="token class-name">BaseDataBinder</span><span class="token punctuation">(</span>val input <span class="token operator">:</span> LayoutInfoInput<span class="token punctuation">,</span> val getRPackage<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">,</span> String<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> val resourceBundle <span class="token operator">:</span> ResourceBundle <span class="token operator">=</span> <span class="token function">ResourceBundle</span><span class="token punctuation">(</span>            input<span class="token punctuation">.</span>packageName<span class="token punctuation">,</span> input<span class="token punctuation">.</span>args<span class="token punctuation">.</span>useAndroidX<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//</span>    init <span class="token punctuation">{</span>        input<span class="token punctuation">.</span>filesToConsider <span class="token punctuation">.</span>forEach <span class="token punctuation">{</span>                    it<span class="token punctuation">.</span><span class="token function">inputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>use <span class="token punctuation">{</span>                     <span class="token comment" spellcheck="true">// 又将上面收集的 layout，将 xml 转成 LayoutFileBundle</span>                        val bundle <span class="token operator">=</span> LayoutFileBundle<span class="token punctuation">.</span><span class="token function">fromXML</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>                        resourceBundle<span class="token punctuation">.</span><span class="token function">addLayoutBundle</span><span class="token punctuation">(</span>bundle<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>        resourceBundle<span class="token punctuation">.</span><span class="token function">addDependencyLayouts</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>existingBindingClasses<span class="token punctuation">)</span>        resourceBundle<span class="token punctuation">.</span><span class="token function">validateAndRegisterErrors</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Suppress</span><span class="token punctuation">(</span><span class="token string">"unused"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// used by android gradle plugin</span>    fun <span class="token function">generateAll</span><span class="token punctuation">(</span>writer <span class="token operator">:</span> JavaFileWriter<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 拿到所有的 LayoutFileBundle，并根据文件名进行分组排序</span>        val layoutBindings <span class="token operator">=</span> resourceBundle<span class="token punctuation">.</span>allLayoutFileBundlesInSource            <span class="token punctuation">.</span><span class="token function">groupBy</span><span class="token punctuation">(</span>LayoutFileBundle<span class="token operator">:</span><span class="token operator">:</span>getFileName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toSortedMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        layoutBindings<span class="token punctuation">.</span>forEach <span class="token punctuation">{</span> layoutName<span class="token punctuation">,</span> variations <span class="token operator">-</span><span class="token operator">></span>            <span class="token comment" spellcheck="true">// 将 LayoutFileBundle 信息包装成 BaseLayoutModel</span>            val layoutModel <span class="token operator">=</span> <span class="token function">BaseLayoutModel</span><span class="token punctuation">(</span>variations<span class="token punctuation">,</span> getRPackage<span class="token punctuation">)</span>            val javaFile<span class="token operator">:</span> JavaFile            val classInfo<span class="token operator">:</span> GenClassInfoLog<span class="token punctuation">.</span>GenClass            <span class="token keyword">if</span> <span class="token punctuation">(</span>variations<span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isBindingData<span class="token punctuation">)</span> <span class="token punctuation">{</span>                val binderWriter <span class="token operator">=</span> <span class="token function">BaseLayoutBinderWriter</span><span class="token punctuation">(</span>layoutModel<span class="token punctuation">,</span> libTypes<span class="token punctuation">)</span>                javaFile <span class="token operator">=</span> binderWriter<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                classInfo <span class="token operator">=</span> binderWriter<span class="token punctuation">.</span><span class="token function">generateClassInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//不是DataBinding，按照 ViewBinding 处理</span>              <span class="token comment" spellcheck="true">//toViewBinder 是 BaseLayoutModel 的拓展函数，他会将 LayoutFileBundle 包装成 ViewBinder 类返回 </span>                val viewBinder <span class="token operator">=</span> layoutModel<span class="token punctuation">.</span><span class="token function">toViewBinder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              <span class="token comment" spellcheck="true">//toJavaFile 是 ViewBinder 的拓展函数，通过Javapoet生成Java文件</span>                javaFile <span class="token operator">=</span> viewBinder<span class="token punctuation">.</span><span class="token function">toJavaFile</span><span class="token punctuation">(</span>useLegacyAnnotations <span class="token operator">=</span> <span class="token operator">!</span>useAndroidX<span class="token punctuation">)</span>                classInfo <span class="token operator">=</span> viewBinder<span class="token punctuation">.</span><span class="token function">generatedClassInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            writer<span class="token punctuation">.</span><span class="token function">writeToFile</span><span class="token punctuation">(</span>javaFile<span class="token punctuation">)</span>            myLog<span class="token punctuation">.</span>classInfoLog<span class="token punctuation">.</span><span class="token function">addMapping</span><span class="token punctuation">(</span>layoutName<span class="token punctuation">,</span> classInfo<span class="token punctuation">)</span>            variations<span class="token punctuation">.</span>forEach <span class="token punctuation">{</span>                it<span class="token punctuation">.</span>bindingTargetBundles<span class="token punctuation">.</span>forEach <span class="token punctuation">{</span> bundle <span class="token operator">-</span><span class="token operator">></span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>bundle<span class="token punctuation">.</span>isBinder<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        myLog<span class="token punctuation">.</span><span class="token function">addDependency</span><span class="token punctuation">(</span>layoutName<span class="token punctuation">,</span> bundle<span class="token punctuation">.</span>includedLayout<span class="token punctuation">)</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        input<span class="token punctuation">.</span><span class="token function">saveLog</span><span class="token punctuation">(</span>myLog<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// data binding will eat some errors to be able to report them later on. This is a good</span>        <span class="token comment" spellcheck="true">// time to report them after the processing is done.</span>        Scope<span class="token punctuation">.</span><span class="token function">assertNoError</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过Javapoet 生成绑定类</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> ViewBinder<span class="token punctuation">.</span><span class="token function">toJavaFile</span><span class="token punctuation">(</span>useLegacyAnnotations<span class="token operator">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token operator">=</span>    <span class="token function">JavaFileGenerator</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> useLegacyAnnotations<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">javaFile</span><span class="token punctuation">(</span>binder<span class="token punctuation">.</span>generatedTypeName<span class="token punctuation">.</span><span class="token function">packageName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">typeSpec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">addFileComment</span><span class="token punctuation">(</span><span class="token string">"Generated by view binder compiler. Do not edit!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">typeSpec</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">classSpec</span><span class="token punctuation">(</span>binder<span class="token punctuation">.</span>generatedTypeName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">addModifiers</span><span class="token punctuation">(</span>PUBLIC<span class="token punctuation">,</span> FINAL<span class="token punctuation">)</span>    <span class="token function">addSuperinterface</span><span class="token punctuation">(</span>ClassName<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>viewBindingPackage<span class="token punctuation">,</span> <span class="token string">"ViewBinding"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// TODO elide the separate root field if the root tag has an ID (and isn't a binder)</span>    <span class="token function">addField</span><span class="token punctuation">(</span><span class="token function">rootViewField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">addFields</span><span class="token punctuation">(</span><span class="token function">bindingFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">addMethod</span><span class="token punctuation">(</span><span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">addMethod</span><span class="token punctuation">(</span><span class="token function">rootViewGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//如果跟标签是 merge  是生成的两参数的infate 参数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>binder<span class="token punctuation">.</span>rootNode <span class="token keyword">is</span> RootNode<span class="token punctuation">.</span>Merge<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">addMethod</span><span class="token punctuation">(</span><span class="token function">mergeInflate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//其它情况都是同时生成一参数和三参数的inflate方法</span>        <span class="token function">addMethod</span><span class="token punctuation">(</span><span class="token function">oneParamInflate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">addMethod</span><span class="token punctuation">(</span><span class="token function">threeParamInflate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">addMethod</span><span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="生成过程总结"><a href="#生成过程总结" class="headerlink" title="生成过程总结"></a>生成过程总结</h4><p>实时更新生成：布局文件改动(新加/更新/删除)后AS或AGP或立即更新绑定类，这个过程还没找到对应的源码</p><p>编译更新生成：AGP 不同的任务触发</p><ul><li>解析xml布局文件：LayoutXmlProcessor#processResources 方法应该是改动布局文件的输入口，暂时没找到对应的Task，收集过程支持增量更新。处理 layout_xx 目录下面的 xxx.xml 文件，解析xml文件的过程区分 DataBinding 和 ViewBinding ，最后的产物是 ResourceBundle.LayoutFileBundle 以及 HashMap&lt;String, List<layoutfilebundle>&gt; mLayoutBundles</layoutfilebundle></li><li>输出描述文件：有AGP中的 <strong>MergeResources</strong>Task 触发 , 遍历之前收集到的所有 LayoutFileBundle，写入 xmlOutDir 路径, 这个xml文件中描述了布局的 文件路径、包名、布局名、控件id、控件行号等信息</li><li>输出绑定类：AGP <strong>DataBindingGenBaseClassesTask</strong>触发，将上个过程生成的布局描述xml文件再解析成 LayoutFileBundle 类信息，然后再次包装这些信息，最后通过Javapoet 生成绑定类</li></ul><h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><ul><li><p>布局文件更新后触发扫描和处理布局文件的操作也就是调用 processResources 方法的地方</p><ul><li>猜测AGP 和 AS 都有参与</li></ul></li><li><p>为什么点击 ActivityMainBinding 会跳转到对应的布局文件</p><ul><li>这个猜测应该和编译相关，生成词法分析器和解析器代码</li></ul></li><li><p>为什么添加了新的布局文件还没有编译就获取到绑定类，但是在data_binding_base_class_source_out路径下没有这个绑定类只有编译才会看到</p><ul><li><p>应该也有AS的份</p></li><li><p><a href="https://android.googlesource.com/platform/tools/adt/idea/+/refs/heads/mirror-goog-studio-master-dev/android-lang-databinding/" target="_blank" rel="noopener">AS 中关于 DataBind 的一个库：Generate lexer and parser code</a></p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
            <tag> ViewBinding </tag>
            
            <tag> VBHelper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetpack | Lifecycle 组件系详解第一篇：Lifecycle</title>
      <link href="2021/05/21/jetpack-lifecycle/"/>
      <url>2021/05/21/jetpack-lifecycle/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/post_banner_jay.png" alt=""></p><h1 id="Jetpack-Lifecycle-组件系详解第一篇：Lifecycle"><a href="#Jetpack-Lifecycle-组件系详解第一篇：Lifecycle" class="headerlink" title="Jetpack | Lifecycle 组件系详解第一篇：Lifecycle"></a>Jetpack | Lifecycle 组件系详解第一篇：Lifecycle</h1><p>Lifecycle细组件主要包括：Lifecycle、LiveData、ViewModle、其它扩展组件(process 、service)等。</p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20211122005956.png" alt="image-20211122005853174" style="zoom:50%;"><h2 id="1-Lifecycle问题汇总"><a href="#1-Lifecycle问题汇总" class="headerlink" title="1. Lifecycle问题汇总"></a>1. Lifecycle问题汇总</h2><ul><li>什么是 Lifecycle</li><li>如何使用 Lifecycle 观察宿主状态</li><li>Lifecycle 是如何分发宿状态的</li><li>Fragment 是如何实现 Lifecycle 的</li><li>Activity 是如何实现 Lifecycle 的</li><li>Application 是如何实现 Lifecycle 的</li><li>Service 是如何实现 Lifecycle 的</li><li>View 是如何实现观察宿主 Lifecycle 的</li><li>Lifecycle 涉及的依赖库是如何划分的</li><li>Lifecycle 实现观察宿主状态有几种方式</li><li>注解+反射/生成代码的方式为什么又被废弃了</li><li>Activity 的生命周期分发为何通过 ReportFragment 实现</li><li>Lifecycle Event 和 State 的关系</li><li>在 onResume 方法中注册观察者，是否能观察到其它生命周期的回调</li><li>分发宿状态过程中是如何同步 Event 和 State 的</li></ul><h2 id="2-Lifecycle是什么"><a href="#2-Lifecycle是什么" class="headerlink" title="2. Lifecycle是什么"></a>2. Lifecycle是什么</h2><p>Lifecycle 是一个对宿主生命周期的变化具有感知能力的组件 (Lifecycle-Aware Components) ，在 Android 中目前提供的可观察的宿主组件有 Activity / Fragment / Service / Application 等，除了jetpack 组件中内置的可观察的宿主我们也可以借助 LifeCycle 的能力自己实现可观察的宿主，例如 SDK 中的 Activity 是没有实现Lifecycle 的，此时我们就可以根据业务需求自定时实现了。</p><p>Lifecycle 的核心实现思想是观察者模式，Jetpack 组件中的 Activity / Fragment 组件中都已经接入了 Lifecycle 中的被观察者者部分的代码，我们只需要实现自己的观察者然后在 Activity / Fragment 组件中注册我们的观察者就可以监听到生命周期事件的变化了。</p><blockquote><p>支持库 26.1.0 及更高版本中的 Fragment 和 Activity 已实现 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener"><code>LifecycleOwner</code></a> 接口。</p></blockquote><p>一种常见的应用场景是有些逻辑需要依赖在 Activity 和 Fragment 的生命周期方法中实现，通过 Lifecycle  组件就可以将这部分代码从生命周期方法中提取到单独的类中，达到解耦被观察者和观察者的目的，从而帮助开发者写出简洁易维护代码。</p><blockquote><p>观察者模式（Observer Design Pattern）也被称为发布订阅模式（Publish-Subscribe Design Pattern）</p><p><strong>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。</strong></p><p>观察者模式属于行为型设计模式，行为型设计模式的目的是将不同的行为代码解耦，具体到观察者模式就是是将观察者和被观察者代码解耦。</p><p>观察者模式的实现一般分为两个角色：Observable、Observer，两个角色一般都提供抽象层。</p><p>被观察者部分的抽象层一般是抽象类，除了提供必要的抽象方法还提供添加、删除等复用的逻辑。</p><p>观察者部分的抽象层一般是一个SAM（Single Abstract Method）接口，观察者可以实现该方法做出更新操作。</p></blockquote><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20211120233721.png" alt="image-20211120233538055"></p><p>Lifecycle 是如何结合观察者模式实现 Activity 和 Fragment 组件的生命周期感知能力的</p><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20211121181816.png" alt=""></p><p>Lifecycle 在实现被观察者时并没有采用传统的直接继承抽象类的方式，而是通过类似委托模式将被观察者的逻辑代码封装到了 LifecycleRegistry 类中，LifecycleRegistry 是真正的被观察者负责统一管理所有观察者的添加、删除、存储、分发等操作。当委托者（ Activity / Fragment）有生命周期事件产生时会通过受托者 LifecycleRegistry 执行具体的分发操作，从而实现委托者类的生命周期可感知能力。</p><p>这样做的优势是符合单一原则，有利于被观察者侧的代码复用，也不用破坏 Activity/Fragment 组件的继承结构。</p><h2 id="3-Lifecycle-有什么"><a href="#3-Lifecycle-有什么" class="headerlink" title="3. Lifecycle 有什么"></a>3. Lifecycle 有什么</h2><p>androidx.lifecycle 组下的组件,了解 lifecycle  有什么才能更好的运用。lifecycle 模块中除了自己实现观察者模式相关的代码</p><table><thead><tr><th>lifecycle-common <br>lifecycle-common-java8 <br>lifecycle-compiler<br>lifecycle-runtime <br>lifecycle-runtime-ktx <br>lifecycle-runtime-ktx- lint <br>lifecycle-runtime-testing</th><th>lifecycle-livedata <br>lifecycle-livedata-core <br>lifecycle-livedata-core-ktx<br>lifecycle-livedata-core-ktx-lint <br>lifecycle-livedata-core-truth  <br>lifecycle-livedata-ktx<br>lifecycle-reactivestreams <br>lifecycle-reactivestreams-ktx</th><th>lifecycle-viewmodel <br>lifecycle-viewmodel-compose <br>lifecycle-viewmodel-ktx <br>lifecycle-viewmodel-savedstate</th><th>lifecycle-process <br>lifecycle-service <br>lifecycle-extensions</th></tr></thead><tbody><tr><td>lifecycle相关</td><td>livedata 相关</td><td>viewmodel相关</td><td>其它扩展组件相关</td></tr><tr><td>common-java8 已经废弃</td><td>-</td><td>-</td><td>extensions 耦合重已经废弃</td></tr></tbody></table><p>再来看一下其中的几个核心组件之间的依赖关系</p><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20211122011323.jpeg" alt="WechatIMG77"></p><p>开发时按需添加 Lifecycle 的依赖项</p><pre class=" language-groovy"><code class="language-groovy"><span class="token keyword">def</span> lifecycle_version <span class="token operator">=</span> <span class="token string">"2.4.0"</span><span class="token comment" spellcheck="true">// ViewModel</span>implementation <span class="token string">"androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version"</span><span class="token comment" spellcheck="true">// ViewModel utilities for Compose</span>implementation <span class="token string">"androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycle_version"</span><span class="token comment" spellcheck="true">// LiveData</span>implementation <span class="token string">"androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version"</span><span class="token comment" spellcheck="true">// Lifecycles only (without ViewModel or LiveData)</span>implementation <span class="token string">"androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version"</span><span class="token comment" spellcheck="true">// Saved state module for ViewModel</span>implementation <span class="token string">"androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version"</span><span class="token comment" spellcheck="true">// Annotation processor</span>kapt <span class="token string">"androidx.lifecycle:lifecycle-compiler:$lifecycle_version"</span><span class="token comment" spellcheck="true">// alternately - if using Java8, use the following instead of lifecycle-compiler</span>implementation <span class="token string">"androidx.lifecycle:lifecycle-common-java8:$lifecycle_version"</span><span class="token comment" spellcheck="true">// optional - helpers for implementing LifecycleOwner in a Service</span>implementation <span class="token string">"androidx.lifecycle:lifecycle-service:$lifecycle_version"</span><span class="token comment" spellcheck="true">// optional - ProcessLifecycleOwner provides a lifecycle for the whole application process</span>implementation <span class="token string">"androidx.lifecycle:lifecycle-process:$lifecycle_version"</span><span class="token comment" spellcheck="true">// optional - ReactiveStreams support for LiveData</span>implementation <span class="token string">"androidx.lifecycle:lifecycle-reactivestreams-ktx:$lifecycle_version"</span></code></pre><p>其它组件对lifecycle的依赖情况</p><pre class=" language-groovy"><code class="language-groovy">implementation <span class="token string">'androidx.core:core-ktx:1.7.0'</span></code></pre><p>core-ktx api 了 core </p><p>core api 了lifecycle-runtime</p><p>lifecycle-runtime api 了 lifecycle-common</p><pre class=" language-groovy"><code class="language-groovy">implementation <span class="token string">'androidx.appcompat:appcompat:1.3.0'</span></code></pre><p>appcompat api 了core、activity、fragment</p><p>activity api 了 core、lifecycle-runtime、lifecycle-viewmodel、lifecycle-viewmodel-savedstate</p><p>fragment api 了core、activity、lifecycle-livedata-core、lifecycle-viewmodel、lifecycle-viewmodel-savedstate</p><p>lifecycle-runtime api 了 lifecycle-common</p><p>lifecycle-livedata-core api 了  lifecycle-livedata</p><p>所以一般情况下我们新建的Android 项目默认都会提供core-ktx、appcompat 这两个组件而他们又间接依赖了 lifecycle 系的组件</p><p>依赖 appcompat 间接依赖的 lifecycle 系组件</p><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20211121134326.png" alt="image-20211121131315450"></p><p>依赖 core-ktx 间接依赖的 lifecycle 系组件</p><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20211121134339.png" alt="image-20211121131403284"></p><h2 id="4-Lifecycle-应用"><a href="#4-Lifecycle-应用" class="headerlink" title="4. Lifecycle 应用"></a>4. Lifecycle 应用</h2><p>生命周期感知型组件可以实现在各种情况下更轻松地管理生命周期。下面列举几个例子：</p><ul><li>在粗粒度和细粒度位置更新之间切换。使用生命周期感知型组件可在位置应用可见时启用细粒度位置更新，并在应用位于后台时切换到粗粒度更新。</li><li>停止和开始视频缓冲。使用生命周期感知型组件可尽快开始视频缓冲，但会推迟播放，直到应用完全启动。此外，应用销毁后，还可以使用生命周期感知型组件终止缓冲。</li><li>开始和停止网络连接。借助生命周期感知型组件，可在应用位于前台时启用网络数据的实时更新（流式传输），并在应用进入后台时自动暂停。</li><li>暂停和恢复动画可绘制资源。借助生命周期感知型组件，可在应用位于后台时暂停动画可绘制资源，并在应用位于前台后恢复可绘制资源。</li><li>Handler 的消息移除。</li><li>Presenter 的 attach&amp;detach View 。</li><li>为其他三方库加持生命周期感知的能力，例如：RxJava 、EventBus等。</li></ul><h2 id="5-Lifecycle-怎么用"><a href="#5-Lifecycle-怎么用" class="headerlink" title="5. Lifecycle 怎么用"></a>5. Lifecycle 怎么用</h2><h3 id="5-1-观察者使用方式汇总"><a href="#5-1-观察者使用方式汇总" class="headerlink" title="5.1 观察者使用方式汇总"></a>5.1 观察者使用方式汇总</h3><p>Lifecycle 的以下使用方式是以  Activity 或者 Fragment 为宿主举例。</p><ul><li>方式一：运行时注解+反射<ul><li>自定义 LifecycleObserver 观察者，用 OnLifecycleEvent 注解配合 Lifecycle.Event 枚举标注生命周期方法；</li><li>在宿主 Activity 或者 Fragment 中通过 getLifecycle().addObserver() 方法注册定义的观察者；</li></ul></li><li>方式二：编译时注解+生成辅助类(XXX_LifecycleAdapter)<ul><li>添加注解处理器组件：lifecycle-compiler</li><li>自定义 LifecycleObserver 观察者，用 OnLifecycleEvent 注解配合 Lifecycle.Event 枚举 标注生命周期方法；</li><li>在宿主 Activity 或者 Fragment 中通过 getLifecycle().addObserver() 方法注册定义的观察者；</li></ul></li><li>方式三：实现 FullLifecycleObserver (非公共方法，自己可以实现一个)<ul><li>自定义 FullLifecycleObserver 观察者，FullLifecycleObserver 是普通接口需要实现其中定义的所有生命周期方法；</li><li>在宿主 Activity 或者 Fragment 中通过 getLifecycle().addObserver() 方法注册定义的观察者；</li></ul></li><li>方式四：实现 LifecycleEventObserver(推荐方式)<ul><li>自定义 LifecycleEventObserver 观察者，通过实现 onStateChanged(LifecycleOwner ,Lifecycle.Event) 方法自行判断生命周期方法的回调；</li><li>在宿主 Activity 或者 Fragment 中通过 getLifecycle().addObserver() 方法注册定义的观察者；</li></ul></li><li><strong>方式五：实现 DefaultLifecycleObserver (推荐方式)</strong><ul><li>自定义 DefaultLifecycleObserver 观察者，DefaultLifecycleObserver 中通过java default 关键字都实现了方法体，所以只需实现需要的声明后期方法即可；</li><li>在宿主 Activity 或者 Fragment 中通过 getLifecycle().addObserver() 方法注册定义的观察者；</li></ul></li></ul><blockquote><p>DefaultLifecycleObserver 接口中的 default 关键字</p><p>default 关键字修饰的方法能够向接口添加新功能方法，必须提供方法体，并确保兼容实现这个接口的之前的类不用在接口的子类中进行逐个实现该方法。可以按需实现</p><p>default是在需要给接口新增方法时，但是子类数量过多，或者子类没必要实现的场景下使用。 比如java8中的List接口，新增了sort()方法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//@since 1.8</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>   Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token punctuation">(</span>Comparator<span class="token punctuation">)</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>   ListIterator<span class="token operator">&lt;</span>E<span class="token operator">></span> i <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span>Object e <span class="token operator">:</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>       i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       i<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></blockquote><h3 id="5-2-观察-Activity-Lifecycle"><a href="#5-2-观察-Activity-Lifecycle" class="headerlink" title="5.2 观察 Activity Lifecycle"></a>5.2 观察 Activity Lifecycle</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> MyLifecycleActivityObserver <span class="token operator">:</span> DefaultLifecycleObserver <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onStart</span><span class="token punctuation">(</span>owner<span class="token operator">:</span> LifecycleOwner<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStart</span><span class="token punctuation">(</span>owner<span class="token punctuation">)</span>        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"MyLifecycleActivity"</span><span class="token punctuation">,</span> <span class="token string">"onStart"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onStop</span><span class="token punctuation">(</span>owner<span class="token operator">:</span> LifecycleOwner<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStop</span><span class="token punctuation">(</span>owner<span class="token punctuation">)</span>        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"MyLifecycleActivity"</span><span class="token punctuation">,</span> <span class="token string">"onStop"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> MyLifecycleActivity <span class="token operator">:</span> <span class="token function">AppCompatActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">addLifecycleObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">addLifecycleObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lifecycle<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token function">MyLifecycleActivityObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-3-观察-SDK-Activity-Lifecycle"><a href="#5-3-观察-SDK-Activity-Lifecycle" class="headerlink" title="5.3 观察 SDK Activity Lifecycle"></a>5.3 观察 SDK Activity Lifecycle</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> MySdkActivity <span class="token operator">:</span> <span class="token function">Activity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> LifecycleOwner <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">lateinit</span> <span class="token keyword">var</span> lifecycleRegistry<span class="token operator">:</span> LifecycleRegistry    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span>        lifecycleRegistry <span class="token operator">=</span> <span class="token function">LifecycleRegistry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>        <span class="token function">addLifecycleObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        MySDKFragment<span class="token punctuation">.</span><span class="token function">inject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">addLifecycleObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lifecycle<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token function">MySDKActivityObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Lifecycle <span class="token punctuation">{</span>        <span class="token keyword">return</span> lifecycleRegistry    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> MySDKActivityObserver <span class="token operator">:</span> DefaultLifecycleObserver <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onPause</span><span class="token punctuation">(</span>owner<span class="token operator">:</span> LifecycleOwner<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onPause</span><span class="token punctuation">(</span>owner<span class="token punctuation">)</span>        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">"SDKActivity"</span><span class="token punctuation">,</span> <span class="token string">"Observer onPause"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onResume</span><span class="token punctuation">(</span>owner<span class="token operator">:</span> LifecycleOwner<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onResume</span><span class="token punctuation">(</span>owner<span class="token punctuation">)</span>        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">"SDKActivity"</span><span class="token punctuation">,</span> <span class="token string">"Observer onResume"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-4-观察-Fragment-Lifecycle"><a href="#5-4-观察-Fragment-Lifecycle" class="headerlink" title="5.4 观察 Fragment Lifecycle"></a>5.4 观察 Fragment Lifecycle</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> MyLifecycleFragmentObserver <span class="token operator">:</span> LifecycleObserver <span class="token punctuation">{</span>    <span class="token annotation builtin">@OnLifecycleEvent</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_RESUME<span class="token punctuation">)</span>    <span class="token keyword">fun</span> <span class="token function">connectListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">"MyLifecycleFragment"</span><span class="token punctuation">,</span> <span class="token string">"onResume"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token annotation builtin">@OnLifecycleEvent</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_PAUSE<span class="token punctuation">)</span>    <span class="token keyword">fun</span> <span class="token function">disconnectListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">"MyLifecycleFragment"</span><span class="token punctuation">,</span> <span class="token string">"onPause"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> MyLifecycleFragment <span class="token operator">:</span> <span class="token function">Fragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span>        <span class="token function">addLifecycleObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">addLifecycleObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lifecycle<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token function">MyLifecycleFragmentObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-5-观察-SDK-Fragment-Lifecycle"><a href="#5-5-观察-SDK-Fragment-Lifecycle" class="headerlink" title="5.5 观察 SDK Fragment Lifecycle"></a>5.5 观察 SDK Fragment Lifecycle</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> MySDKFragment <span class="token operator">:</span> <span class="token function">Fragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> LifecycleOwner <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">lateinit</span> <span class="token keyword">var</span> lifecycleRegistry<span class="token operator">:</span> LifecycleRegistry    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span>        lifecycleRegistry <span class="token operator">=</span> <span class="token function">LifecycleRegistry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>        lifecycleRegistry<span class="token punctuation">.</span><span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_CREATE<span class="token punctuation">)</span>        <span class="token function">addLifecycleObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">addLifecycleObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lifecycle<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token function">MySDKFragmentObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{</span>        <span class="token keyword">fun</span> <span class="token function">inject</span><span class="token punctuation">(</span>activity<span class="token operator">:</span> Activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">val</span> manager <span class="token operator">=</span> activity<span class="token punctuation">.</span>fragmentManager            <span class="token keyword">if</span> <span class="token punctuation">(</span>manager<span class="token punctuation">.</span><span class="token function">findFragmentByTag</span><span class="token punctuation">(</span><span class="token string">"MyLifecycleFragment"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                manager<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">MySDKFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"MyLifecycleFragment"</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                manager<span class="token punctuation">.</span><span class="token function">executePendingTransactions</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onResume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onResume</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">"SDKFragment"</span><span class="token punctuation">,</span> <span class="token string">" onResume"</span><span class="token punctuation">)</span>        lifecycleRegistry<span class="token punctuation">.</span><span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_RESUME<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onPause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onPause</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">"SDKFragment"</span><span class="token punctuation">,</span> <span class="token string">" onPause"</span><span class="token punctuation">)</span>        lifecycleRegistry<span class="token punctuation">.</span><span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_PAUSE<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Lifecycle <span class="token punctuation">{</span>        <span class="token keyword">return</span> lifecycleRegistry    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> MySDKFragmentObserver <span class="token operator">:</span> DefaultLifecycleObserver <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onPause</span><span class="token punctuation">(</span>owner<span class="token operator">:</span> LifecycleOwner<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onPause</span><span class="token punctuation">(</span>owner<span class="token punctuation">)</span>        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">"SDKFragment"</span><span class="token punctuation">,</span> <span class="token string">"Observer onPause"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onResume</span><span class="token punctuation">(</span>owner<span class="token operator">:</span> LifecycleOwner<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onResume</span><span class="token punctuation">(</span>owner<span class="token punctuation">)</span>        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">"SDKFragment"</span><span class="token punctuation">,</span> <span class="token string">"Observer onResume"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-6-观察-Service-Lifecycle"><a href="#5-6-观察-Service-Lifecycle" class="headerlink" title="5.6 观察 Service Lifecycle"></a>5.6 观察 Service Lifecycle</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">class</span> MyLifecycleServiceObserver implements LifecycleEventObserver <span class="token punctuation">{</span>    <span class="token annotation builtin">@Override</span>    <span class="token keyword">public</span> void <span class="token function">onStateChanged</span><span class="token punctuation">(</span><span class="token annotation builtin">@NonNull</span> LifecycleOwner source<span class="token punctuation">,</span> <span class="token annotation builtin">@NonNull</span> Lifecycle<span class="token punctuation">.</span>Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>event <span class="token operator">==</span> Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_START<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"MyLifecycleService"</span><span class="token punctuation">,</span> <span class="token string">"onStart()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>event <span class="token operator">==</span> Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_DESTROY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"MyLifecycleService"</span><span class="token punctuation">,</span> <span class="token string">"onDestroy()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">class</span> MyLifecycleService extends LifecycleService <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">MyLifecycleService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>new <span class="token function">MyLifecycleServiceObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-7-观察-Application-Lifecycle"><a href="#5-7-观察-Application-Lifecycle" class="headerlink" title="5.7 观察 Application Lifecycle"></a>5.7 观察 Application Lifecycle</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> <span class="token function">MyLifecycleApplicationObserver</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> application<span class="token operator">:</span> Application<span class="token punctuation">)</span> <span class="token operator">:</span>    LifecycleObserver <span class="token punctuation">{</span>    <span class="token annotation builtin">@OnLifecycleEvent</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_RESUME<span class="token punctuation">)</span>    <span class="token keyword">fun</span> <span class="token function">appInResumeState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>application<span class="token punctuation">,</span> <span class="token string">"In Foreground"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_LONG<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token annotation builtin">@OnLifecycleEvent</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_PAUSE<span class="token punctuation">)</span>    <span class="token keyword">fun</span> <span class="token function">appInPauseState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>application<span class="token punctuation">,</span> <span class="token string">"In Background"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_LONG<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">class</span> MyLifecycleApplication extends MultiDexApplication <span class="token punctuation">{</span>    <span class="token annotation builtin">@Override</span>    <span class="token keyword">public</span> void <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//饿汉式单例获取 ProcessLifecycleOwner</span>        ProcessLifecycleOwner<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>new <span class="token function">MyLifecycleApplicationObserver</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-8-View-观察-Lifecycle"><a href="#5-8-View-观察-Lifecycle" class="headerlink" title="5.8 View 观察 Lifecycle"></a>5.8 View 观察 Lifecycle</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> MyLifecycleView <span class="token annotation builtin">@JvmOverloads</span> <span class="token keyword">constructor</span><span class="token punctuation">(</span>    context<span class="token operator">:</span> Context<span class="token punctuation">,</span>    attrs<span class="token operator">:</span> AttributeSet<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span>    defStyle<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">View</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> defStyle<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">init</span> <span class="token punctuation">{</span>        <span class="token function">addOnAttachStateChangeListener</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> OnAttachStateChangeListener <span class="token punctuation">{</span>            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onViewAttachedToWindow</span><span class="token punctuation">(</span>v<span class="token operator">:</span> View<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"MyLifecycleView"</span><span class="token punctuation">,</span> <span class="token string">"onViewAttachedToWindow"</span><span class="token punctuation">)</span>                <span class="token function">findViewTreeLifecycleOwner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span>lifecycle                    <span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> LifecycleEventObserver <span class="token punctuation">{</span>                        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onStateChanged</span><span class="token punctuation">(</span>                            source<span class="token operator">:</span> LifecycleOwner<span class="token punctuation">,</span>                            event<span class="token operator">:</span> Lifecycle<span class="token punctuation">.</span>Event                        <span class="token punctuation">)</span> <span class="token punctuation">{</span>                            Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"MyLifecycleView"</span><span class="token punctuation">,</span> <span class="token string">"onStateChanged：source:<span class="token interpolation variable">$source</span>, event: <span class="token interpolation variable">$event</span>"</span><span class="token punctuation">)</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onViewDetachedFromWindow</span><span class="token punctuation">(</span>v<span class="token operator">:</span> View<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"MyLifecycleView"</span><span class="token punctuation">,</span> <span class="token string">"onViewDetachedFromWindow"</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-9-各种方式的观察者的执行顺序"><a href="#5-9-各种方式的观察者的执行顺序" class="headerlink" title="5.9 各种方式的观察者的执行顺序"></a>5.9 各种方式的观察者的执行顺序</h3><ul><li>DefaultLifecycleObserver 所有方法将在 [LifecycleOwner] 的生命周期回调方法被调用之前被调用，这里需要注意Fragment 生命周期的回调时机。</li></ul><ul><li>LifecycleEventObserver onStateChanged 方法在当状态转换事件发生时调用。</li><li>如果一个类同时实现了DefaultLifecycleObserver 和LifecycleEventObserver ，则首先调用DefaultLifecycleObserver方法，然后调用LifecycleEventObserver.onStateChanged(LifecycleOwner, Lifecycle.Event) 方法。</li><li>如果一个类实现了这个接口并且同时使用了OnLifecycleEvent 注解，那么注解将被忽略。</li></ul><pre class=" language-kotlin"><code class="language-kotlin">D<span class="token operator">/</span>Life_Owner<span class="token operator">:</span> onCreateD<span class="token operator">/</span>Life_Observer<span class="token operator">:</span> onCreateD<span class="token operator">/</span>Life_Observer<span class="token operator">:</span> onStateChanged<span class="token punctuation">,</span>event<span class="token operator">:</span>ON_CREATED<span class="token operator">/</span>Life_Owner<span class="token operator">:</span> onStartD<span class="token operator">/</span>Life_Observer<span class="token operator">:</span> onStartD<span class="token operator">/</span>Life_Observer<span class="token operator">:</span> onStateChanged<span class="token punctuation">,</span>event<span class="token operator">:</span>ON_STARTD<span class="token operator">/</span>Life_Owner<span class="token operator">:</span> onResumeD<span class="token operator">/</span>Life_Observer<span class="token operator">:</span> onResumeD<span class="token operator">/</span>Life_Observer<span class="token operator">:</span> onStateChanged<span class="token punctuation">,</span>event<span class="token operator">:</span>ON_RESUMED<span class="token operator">/</span>Life_Observer<span class="token operator">:</span> onPauseD<span class="token operator">/</span>Life_Observer<span class="token operator">:</span> onStateChanged<span class="token punctuation">,</span>event<span class="token operator">:</span>ON_PAUSED<span class="token operator">/</span>Life_Owner<span class="token operator">:</span> onPauseD<span class="token operator">/</span>Life_Observer<span class="token operator">:</span> onStopD<span class="token operator">/</span>Life_Observer<span class="token operator">:</span> onStateChanged<span class="token punctuation">,</span>event<span class="token operator">:</span>ON_STOPD<span class="token operator">/</span>Life_Owner<span class="token operator">:</span> onStopD<span class="token operator">/</span>Life_Observer<span class="token operator">:</span> onDestroyD<span class="token operator">/</span>Life_Observer<span class="token operator">:</span> onStateChanged<span class="token punctuation">,</span>event<span class="token operator">:</span>ON_DESTROYD<span class="token operator">/</span>Life_Owner<span class="token operator">:</span> onDestroy</code></pre><p>在Activity 的onPause 方法注册观察者，当宿主执行onPause时 观察者也是会从 onCreate 开始直到对齐当前状态，Lifecycle 内部做了同步和对齐的处理。</p><pre><code>D/Life_Owner: onCreateD/Life_Owner: onStartD/Life_Owner: onResumeD/Life_Observer: onCreateD/Life_Observer: onStateChanged,event:ON_CREATED/Life_Observer: onStartD/Life_Observer: onStateChanged,event:ON_STARTD/Life_Owner: onPauseD/Life_Observer: onStopD/Life_Observer: onStateChanged,event:ON_STOPD/Life_Owner: onStopD/Life_Observer: onDestroyD/Life_Observer: onStateChanged,event:ON_DESTROYD/Life_Owner: onDestroy</code></pre><h2 id="6-Lifecycle-最小原型设计"><a href="#6-Lifecycle-最小原型设计" class="headerlink" title="6. Lifecycle 最小原型设计"></a>6. Lifecycle 最小原型设计</h2><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20211121181816.png" alt="观察者模式"></p><h4 id="6-1-代码实现最小原型"><a href="#6-1-代码实现最小原型" class="headerlink" title="6.1 代码实现最小原型"></a>6.1 代码实现最小原型</h4><p>被观察者部分</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//抽象接口层</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> Lifecycle <span class="token punctuation">{</span>    <span class="token keyword">abstract</span> <span class="token keyword">fun</span> <span class="token function">addObserver</span><span class="token punctuation">(</span>observer<span class="token operator">:</span> LifecycleObserver<span class="token punctuation">)</span>    <span class="token keyword">abstract</span> <span class="token keyword">fun</span> <span class="token function">removeObserver</span><span class="token punctuation">(</span>observer<span class="token operator">:</span> LifecycleObserver<span class="token punctuation">)</span>    <span class="token keyword">enum</span> <span class="token keyword">class</span> State <span class="token punctuation">{</span>        DESTROYED<span class="token punctuation">,</span>        INITIALIZED<span class="token punctuation">,</span>        CREATED<span class="token punctuation">,</span>        STARTED<span class="token punctuation">,</span>        RESUMED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">enum</span> <span class="token keyword">class</span> Event <span class="token punctuation">{</span>        ON_CREATE<span class="token punctuation">,</span>        ON_START<span class="token punctuation">,</span>        ON_RESUME<span class="token punctuation">,</span>        ON_PAUSE<span class="token punctuation">,</span>        ON_STOP<span class="token punctuation">,</span>        ON_DESTROY<span class="token punctuation">,</span>        ON_ANY<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//受托方</span><span class="token keyword">class</span> <span class="token function">LifecycleRegistry</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> lifecycleOwner<span class="token operator">:</span> LifecycleOwner<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Lifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> lifecycleObserver<span class="token operator">:</span> LifecycleObserver<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> lifecycleObservers <span class="token operator">=</span> arrayListOf<span class="token operator">&lt;</span>LifecycleObserver<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">addObserver</span><span class="token punctuation">(</span>observer<span class="token operator">:</span> LifecycleObserver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        lifecycleObservers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span>        lifecycleObserver <span class="token operator">=</span> observer    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">removeObserver</span><span class="token punctuation">(</span>observer<span class="token operator">:</span> LifecycleObserver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        lifecycleObservers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">fun</span> <span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>event<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        lifecycleObservers<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token keyword">is</span> LifecycleEventObserver<span class="token punctuation">)</span> <span class="token punctuation">{</span>                it<span class="token punctuation">.</span><span class="token function">onStateChanged</span><span class="token punctuation">(</span>lifecycleOwner<span class="token punctuation">,</span> event<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>观察者部分</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> LifecycleObserver <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">interface</span> LifecycleEventObserver <span class="token operator">:</span> LifecycleObserver <span class="token punctuation">{</span>    <span class="token keyword">fun</span> <span class="token function">onStateChanged</span><span class="token punctuation">(</span>source<span class="token operator">:</span> LifecycleOwner<span class="token punctuation">,</span> event<span class="token operator">:</span> Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">interface</span> DefaultLifecycleObserver <span class="token operator">:</span> FullLifecycleObserver <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>owner<span class="token operator">:</span> LifecycleOwner<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onStart</span><span class="token punctuation">(</span>owner<span class="token operator">:</span> LifecycleOwner<span class="token punctuation">)</span> <span class="token operator">=</span> Unit    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onResume</span><span class="token punctuation">(</span>owner<span class="token operator">:</span> LifecycleOwner<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onPause</span><span class="token punctuation">(</span>owner<span class="token operator">:</span> LifecycleOwner<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onStop</span><span class="token punctuation">(</span>owner<span class="token operator">:</span> LifecycleOwner<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onDestroy</span><span class="token punctuation">(</span>owner<span class="token operator">:</span> LifecycleOwner<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>测试被观察者部分</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Activity <span class="token operator">:</span> LifecycleOwner <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> lifecycleRegistry<span class="token operator">:</span> LifecycleRegistry <span class="token operator">=</span> <span class="token function">LifecycleRegistry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>    <span class="token keyword">init</span> <span class="token punctuation">{</span>        lifecycleRegistry<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token function">ActivityObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Lifecycle <span class="token operator">=</span> lifecycleRegistry    <span class="token keyword">fun</span> <span class="token function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lifecycleRegistry<span class="token punctuation">.</span><span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_START<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">fun</span> <span class="token function">onStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lifecycleRegistry<span class="token punctuation">.</span><span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_STOP<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>测试观察者部分</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> ActivityObserver <span class="token operator">:</span> LifecycleEventObserver <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onStateChanged</span><span class="token punctuation">(</span>source<span class="token operator">:</span> LifecycleOwner<span class="token punctuation">,</span> event<span class="token operator">:</span> Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"source: <span class="token interpolation variable">$source</span>, event: <span class="token interpolation variable">$event</span> "</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行测试</span><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">val</span> app <span class="token operator">=</span> <span class="token function">Activity</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    app<span class="token punctuation">.</span><span class="token function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    app<span class="token punctuation">.</span><span class="token function">onStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="7-Lifecycle-实现原理"><a href="#7-Lifecycle-实现原理" class="headerlink" title="7. Lifecycle 实现原理"></a>7. Lifecycle 实现原理</h2><h3 id="7-1-Fragment-的实现"><a href="#7-1-Fragment-的实现" class="headerlink" title="7.1 Fragment 的实现"></a>7.1 Fragment 的实现</h3><p>jetpack 中的 Fragment 组件已经被观察部分的接口 LifecycleOwner</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//androidx.fragment.app.Fragment 中已经实现 LifecycleOwner </span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Fragment</span> <span class="token keyword">implements</span>               <span class="token class-name">ComponentCallbacks</span><span class="token punctuation">,</span>                 OnCreateContextMenuListener<span class="token punctuation">,</span>                 LifecycleOwner<span class="token punctuation">,</span>        ViewModelStoreOwner<span class="token punctuation">,</span>                 HasDefaultViewModelProviderFactory<span class="token punctuation">,</span>                 SavedStateRegistryOwner<span class="token punctuation">,</span>        ActivityResultCaller <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//通过覆写 LifecycleOwner 的 getLifecycle 方法向外暴露宿主的生命周期管理类</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@NonNull</span>    <span class="token keyword">public</span> Lifecycle <span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mLifecycleRegistry<span class="token punctuation">;</span>    <span class="token punctuation">}</span>   LifecycleRegistry mLifecycleRegistry<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构造函数中进行了受托者 LifecycleRegistry 的初始化</span>   <span class="token keyword">public</span> <span class="token function">Fragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">initLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>   <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">initLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mLifecycleRegistry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LifecycleRegistry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//当发生生命周期事件时执通过委托类分发该事件到所有观察者中</span> <span class="token keyword">void</span> <span class="token function">performCreate</span><span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mLifecycleRegistry<span class="token punctuation">.</span><span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_CREATE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>Fragment 的生命周期感知实现很简单，就是委托给 mLifecycleRegistry 全权负责</p><h3 id="7-2-Activity-实现"><a href="#7-2-Activity-实现" class="headerlink" title="7.2 Activity 实现"></a>7.2 Activity 实现</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//androidx.core.app.ComponentActivity，@hide标注，不对外使用，只做了 Lifecycle 和 KeyEvent 的封装</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ComponentActivity</span> <span class="token keyword">extends</span> <span class="token class-name">Activity</span> <span class="token keyword">implements</span>        <span class="token class-name">LifecycleOwner</span><span class="token punctuation">,</span>        KeyEventDispatcher<span class="token punctuation">.</span>Component <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//androidx.activity.ComponentActivity，以上特性 + 集成了 Jitpack 的其它组件，例如：Lifecycle，ViewModel等</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ComponentActivity</span> <span class="token keyword">extends</span> <span class="token class-name">androidx<span class="token punctuation">.</span>core<span class="token punctuation">.</span>app<span class="token punctuation">.</span>ComponentActivity</span> <span class="token keyword">implements</span>        <span class="token class-name">ContextAware</span><span class="token punctuation">,</span>        LifecycleOwner<span class="token punctuation">,</span>        ViewModelStoreOwner<span class="token punctuation">,</span>        HasDefaultViewModelProviderFactory<span class="token punctuation">,</span>        SavedStateRegistryOwner<span class="token punctuation">,</span>        OnBackPressedDispatcherOwner<span class="token punctuation">,</span>        ActivityResultRegistryOwner<span class="token punctuation">,</span>        ActivityResultCaller <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//通过覆写 LifecycleOwner 的 getLifecycle 方法向外暴露宿主的生命周期管理类</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> LifecycleRegistry mLifecycleRegistry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LifecycleRegistry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">public</span> Lifecycle <span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> mLifecycleRegistry<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// ReportFragment 是继承自 sdk 中的 Fragment, 所以这里可以兼容 SDK 中的 Activity 也能实现声明周期感知</span>            ReportFragment<span class="token punctuation">.</span><span class="token function">injectIfNeededIn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mContentLayoutId <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setContentView</span><span class="token punctuation">(</span>mContentLayoutId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//androidx.fragment.app.FragmentActivity，以上特性 + 简化Fragment 的使用，例如：FragmentManager</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FragmentActivity</span> <span class="token keyword">extends</span> <span class="token class-name">ComponentActivity</span> <span class="token keyword">implements</span>        <span class="token class-name">ActivityCompat<span class="token punctuation">.</span>OnRequestPermissionsResultCallback</span><span class="token punctuation">,</span>        ActivityCompat<span class="token punctuation">.</span>RequestPermissionsRequestCodeValidator <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//androidx.appcompat.app.AppCompatActivity 以上特性 + 简化 Material 设计，例如主题、暗黑、导航条等</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppCompatActivity</span> <span class="token keyword">extends</span> <span class="token class-name">FragmentActivity</span> <span class="token keyword">implements</span>               <span class="token class-name">AppCompatCallback</span><span class="token punctuation">,</span>        TaskStackBuilder<span class="token punctuation">.</span>SupportParentable<span class="token punctuation">,</span>                 ActionBarDrawerToggle<span class="token punctuation">.</span>DelegateProvider <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>androidx.activity 组件下的 <strong>ComponentActivity</strong> 可以说是 androidx 系或者说是 Jetpack 开发套件中的最顶层 Activity 基类了，可以看到 ComponentActivity 类中已经实现了 LifecycleOwner，所以和 Fragment 一样将被观察者的逻辑委托给了LifecycleRegistry。</p><p>但是我们在ComponentActivity 生命周期的回调方法中并没有看到 LifecycleRegistry 执行的分发操作。在 onCreate 方法中我们看到ReportFragment.injectIfNeededIn(this); 这句代码，这里就是 Activity 声明周期可感知做的的兼容处理，ReportFragment 是继承自 sdk 中的 Fragment, 所以这里可以兼容 SDK 中的 Activity 也能实现声明周期感知。</p><h4 id="ReportFragment"><a href="#ReportFragment" class="headerlink" title="ReportFragment"></a>ReportFragment</h4><pre class=" language-java"><code class="language-java">        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">injectIfNeededIn</span><span class="token punctuation">(</span>Activity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Build<span class="token punctuation">.</span>VERSION<span class="token punctuation">.</span>SDK_INT <span class="token operator">>=</span> <span class="token number">29</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在 API 29+ 上，可以直接注册 Activity 中的 registerActivityLifecycleCallbacks 回调方法获取Activity 的生命周期                回调。</span>            LifecycleCallbacks<span class="token punctuation">.</span><span class="token function">registerIn</span><span class="token punctuation">(</span>activity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//在 API 29 之前和进程的宿主 ProcessLifecycleOwner 都是通过内嵌一个空的 Fragment 获间接取 Activity 的生命周期回调。</span>        android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>FragmentManager manager <span class="token operator">=</span> activity<span class="token punctuation">.</span><span class="token function">getFragmentManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>manager<span class="token punctuation">.</span><span class="token function">findFragmentByTag</span><span class="token punctuation">(</span>REPORT_FRAGMENT_TAG<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            manager<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ReportFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> REPORT_FRAGMENT_TAG<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            manager<span class="token punctuation">.</span><span class="token function">executePendingTransactions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//29以上分发的方式</span>        <span class="token annotation punctuation">@RequiresApi</span><span class="token punctuation">(</span><span class="token number">29</span><span class="token punctuation">)</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LifecycleCallbacks</span> <span class="token keyword">implements</span> <span class="token class-name">Application<span class="token punctuation">.</span>ActivityLifecycleCallbacks</span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">registerIn</span><span class="token punctuation">(</span>Activity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            activity<span class="token punctuation">.</span><span class="token function">registerActivityLifecycleCallbacks</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LifecycleCallbacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onActivityPostCreated</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Activity activity<span class="token punctuation">,</span>                <span class="token annotation punctuation">@Nullable</span> Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">dispatch</span><span class="token punctuation">(</span>activity<span class="token punctuation">,</span> Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_CREATE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onActivityPostStarted</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Activity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">dispatch</span><span class="token punctuation">(</span>activity<span class="token punctuation">,</span> Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_START<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onActivityPreDestroyed</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Activity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">dispatch</span><span class="token punctuation">(</span>activity<span class="token punctuation">,</span> Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_DESTROY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onActivityDestroyed</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Activity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//Fragment 声明周期方法触发是</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dispatchStart</span><span class="token punctuation">(</span>mProcessListener<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 进程29以下需要需要的</span>        <span class="token function">dispatch</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_START<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 分发29以下 Avtivity </span>    <span class="token punctuation">}</span>   <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Lifecycle<span class="token punctuation">.</span>Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Build<span class="token punctuation">.</span>VERSION<span class="token punctuation">.</span>SDK_INT <span class="token operator">&lt;</span> <span class="token number">29</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">getActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Activity activity<span class="token punctuation">,</span> <span class="token annotation punctuation">@NonNull</span> Lifecycle<span class="token punctuation">.</span>Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>activity <span class="token keyword">instanceof</span> <span class="token class-name">LifecycleRegistryOwner</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>LifecycleRegistryOwner<span class="token punctuation">)</span> activity<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>activity <span class="token keyword">instanceof</span> <span class="token class-name">LifecycleOwner</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Lifecycle lifecycle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>LifecycleOwner<span class="token punctuation">)</span> activity<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lifecycle <span class="token keyword">instanceof</span> <span class="token class-name">LifecycleRegistry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>LifecycleRegistry<span class="token punctuation">)</span> lifecycle<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 29以下最终的分发方法</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>总的来说 Activity 将生命周期方法通知给订阅者的方式有别于 Fragment 的直接在生命周期回调中委托给 mLifecycleRegistry 全权负责。Activity 的方式显现复杂，搞复杂的主要原因也是为了兼容低版本和方便移植不得不做的。</p><p>根据SDK版本可分为两种方式，大于等于29(Androi 10) 以上是通过  activity.registerActivityLifecycleCallbacks(new Application.ActivityLifecycleCallbacks) 方式注册生命周期回调方法的方式获取 Activity 的生命周期回调，然后再回调中在通过mLifecycleRegistry 通知订阅者。</p><p>29(Androi 10) 以下是通过内嵌一个空的 Fragment 获间接获取 Activity 的生命周期回调，然后再回调中在通过mLifecycleRegistry 通知订阅者。</p><h3 id="7-3-LifecycleRegistry-真正的被观察者"><a href="#7-3-LifecycleRegistry-真正的被观察者" class="headerlink" title="7.3 LifecycleRegistry-真正的被观察者"></a>7.3 LifecycleRegistry-真正的被观察者</h3><p>LifecycleRegistry 通常被 Fragments 和 Activity 组件使用。 如果有自定义 LifecycleOwner的需求也可以直接使用它。</p><p>LifecycleRegistry  可以看做是Fragment 和 Activity 实现生命周期可感知的受托方。所有的被观察的逻辑都在这里实现。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token function">LifecycleRegistry</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> LifecycleOwner provider<span class="token punctuation">,</span> <span class="token keyword">boolean</span> enforceMainThread<span class="token punctuation">)</span> <span class="token punctuation">{</span>    mLifecycleOwner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>provider<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 宿主类通过弱引用包裹</span>    mState <span class="token operator">=</span> INITIALIZED<span class="token punctuation">;</span>    mEnforceMainThread <span class="token operator">=</span> enforceMainThread<span class="token punctuation">;</span><span class="token punctuation">}</span>LifecycleOwner lifecycleOwner <span class="token operator">=</span> mLifecycleOwner<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>lifecycleOwner <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"LifecycleOwner of this LifecycleRegistry is already"</span>            <span class="token operator">+</span> <span class="token string">"garbage collected. It is too late to change lifecycle state."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>宿主类通过弱引用包裹，当方式GC时会回收宿主类避免内存泄漏的产生，每次获取宿主时都会先判空，如果被GC了是不会继续执行的。</p><h4 id="添加观察者"><a href="#添加观察者" class="headerlink" title="添加观察者"></a>添加观察者</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//宿主中向LifecycleRegistry 中添加观察者</span>lifecycle<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token function">MyLifecycleActivityObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//缓存观察者的数据容器</span><span class="token keyword">private</span> FastSafeIterableMap<span class="token operator">&lt;</span>LifecycleObserver<span class="token punctuation">,</span> ObserverWithState<span class="token operator">></span> mObserverMap <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">FastSafeIterableMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对分发事件的封装</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ObserverWithState</span> <span class="token punctuation">{</span>    State mState<span class="token punctuation">;</span>    LifecycleEventObserver mLifecycleObserver<span class="token punctuation">;</span>    <span class="token function">ObserverWithState</span><span class="token punctuation">(</span>LifecycleObserver observer<span class="token punctuation">,</span> State initialState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mLifecycleObserver <span class="token operator">=</span> Lifecycling<span class="token punctuation">.</span><span class="token function">lifecycleEventObserver</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>        mState <span class="token operator">=</span> initialState<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">dispatchEvent</span><span class="token punctuation">(</span>LifecycleOwner owner<span class="token punctuation">,</span> Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//根据事件获取状态</span>        State newState <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getTargetState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mState <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>mState<span class="token punctuation">,</span> newState<span class="token punctuation">)</span><span class="token punctuation">;</span>        mLifecycleObserver<span class="token punctuation">.</span><span class="token function">onStateChanged</span><span class="token punctuation">(</span>owner<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//分发</span>        mState <span class="token operator">=</span> newState<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//前进一个状态</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> LifecycleObserver observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//初始值状态为：mState = INITIALIZED;</span>    State initialState <span class="token operator">=</span> mState <span class="token operator">==</span> DESTROYED <span class="token operator">?</span> DESTROYED <span class="token operator">:</span> INITIALIZED<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//包装观察者</span>    ObserverWithState statefulObserver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObserverWithState</span><span class="token punctuation">(</span>observer<span class="token punctuation">,</span> initialState<span class="token punctuation">)</span><span class="token punctuation">;</span>    ObserverWithState previous <span class="token operator">=</span> mObserverMap<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>observer<span class="token punctuation">,</span> statefulObserver<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//之前缓存过了，直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>previous <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//宿主被GC了</span>    LifecycleOwner lifecycleOwner <span class="token operator">=</span> mLifecycleOwner<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lifecycleOwner <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// it is null we should be destroyed. Fallback quickly</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//</span>    <span class="token keyword">boolean</span> isReentrance <span class="token operator">=</span> mAddingObserverCounter <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> mHandlingEvent<span class="token punctuation">;</span>    State targetState <span class="token operator">=</span> <span class="token function">calculateTargetState</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//计算出宿主当前的状态</span>    mAddingObserverCounter<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//同步到宿主当前的状态，例如在 onResume 方法注册的观察者，之前的生命周期方法也会回调</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>statefulObserver<span class="token punctuation">.</span>mState<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>targetState<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">//比较状态，是否小于宿主的状态,枚举类根据 ordinal 序号进行比较，越靠后的序号越大</span>            <span class="token operator">&amp;&amp;</span> mObserverMap<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">pushParentState</span><span class="token punctuation">(</span>statefulObserver<span class="token punctuation">.</span>mState<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//向前移动一个生命周期方法，ON_CREATE-ON_START-ON_RESUME 知道对齐宿主</span>        <span class="token keyword">final</span> Event event <span class="token operator">=</span> Event<span class="token punctuation">.</span><span class="token function">upFrom</span><span class="token punctuation">(</span>statefulObserver<span class="token punctuation">.</span>mState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>event <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"no event up from "</span> <span class="token operator">+</span> statefulObserver<span class="token punctuation">.</span>mState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//每次向前移动一个生命周期方法就分发落后的生命周期方法</span>        statefulObserver<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>lifecycleOwner<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">popParentState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// mState / subling may have been changed recalculate</span>        targetState <span class="token operator">=</span> <span class="token function">calculateTargetState</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isReentrance<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// we do sync only on the top level.</span>        <span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    mAddingObserverCounter<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">public</span> <span class="token keyword">static</span> Event <span class="token function">upFrom</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> State state<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> INITIALIZED<span class="token operator">:</span>            <span class="token keyword">return</span> ON_CREATE<span class="token punctuation">;</span>        <span class="token keyword">case</span> CREATED<span class="token operator">:</span>            <span class="token keyword">return</span> ON_START<span class="token punctuation">;</span>        <span class="token keyword">case</span> STARTED<span class="token operator">:</span>            <span class="token keyword">return</span> ON_RESUME<span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>向前同步时：先根据状态推倒事件，分发是根据事件推导出状态，再更新状态。</p><p>假设宿主中是在onResume 方法中注册的观察者，那么他的同步流程应该是怎样的呢？</p><p>观察者最终会受到onCreate-onStart-onRsume 三个回到方法。</p><h4 id="State-和-Event"><a href="#State-和-Event" class="headerlink" title="State 和 Event"></a>State 和 Event</h4><p>针对Lifecycle 中 State 和 Event 的对应关系我们通过官方提供的流转图分析一下。</p><p>Lifecycle 接口中提供两个枚举：State表示宿主状态，Event表示宿主生命周期事件。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    DESTROYED<span class="token punctuation">,</span>    INITIALIZED<span class="token punctuation">,</span>    CREATED<span class="token punctuation">,</span>    STARTED<span class="token punctuation">,</span>    RESUMED<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span>    ON_CREATE<span class="token punctuation">,</span>    ON_START<span class="token punctuation">,</span>    ON_RESUME<span class="token punctuation">,</span>    ON_PAUSE<span class="token punctuation">,</span>    ON_STOP<span class="token punctuation">,</span>    ON_DESTROY<span class="token punctuation">,</span>    ON_ANY<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>两个过程：前进和后腿</p><p>前进：INITIALIZED-ON_CREATE-CREATED-ON_START-STARTED-ON_RESUME-RESUMED</p><p>倒退：RESUMED-ON_PAUSE-STARTED-ON_STOP-CREATED-ON_DESTROY-DESTROYED</p><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20211121224101.svg" alt="生命周期状态示意图"></p><p>状态是图中的节点，事件可以看作这些节点之间的边。</p><p>通过事件获取状态</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> State <span class="token function">getTargetState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> ON_CREATE<span class="token operator">:</span>        <span class="token keyword">case</span> ON_STOP<span class="token operator">:</span>            <span class="token keyword">return</span> State<span class="token punctuation">.</span>CREATED<span class="token punctuation">;</span>        <span class="token keyword">case</span> ON_START<span class="token operator">:</span>        <span class="token keyword">case</span> ON_PAUSE<span class="token operator">:</span>            <span class="token keyword">return</span> State<span class="token punctuation">.</span>STARTED<span class="token punctuation">;</span>        <span class="token keyword">case</span> ON_RESUME<span class="token operator">:</span>            <span class="token keyword">return</span> State<span class="token punctuation">.</span>RESUMED<span class="token punctuation">;</span>        <span class="token keyword">case</span> ON_DESTROY<span class="token operator">:</span>            <span class="token keyword">return</span> State<span class="token punctuation">.</span>DESTROYED<span class="token punctuation">;</span>        <span class="token keyword">case</span> ON_ANY<span class="token operator">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">+</span> <span class="token string">" has no target state"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果上面的图看不太明白，看看下面这个就清除它们的对应关系了。</p><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20211027015118.jpeg" alt="img"></p><h4 id="通知观察者"><a href="#通知观察者" class="headerlink" title="通知观察者"></a>通知观察者</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Lifecycle<span class="token punctuation">.</span>Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">enforceMainThreadIfNeeded</span><span class="token punctuation">(</span><span class="token string">"handleLifecycleEvent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//根据事件推导状态，再执行移动</span>    <span class="token function">moveToState</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getTargetState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//条件的判断</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">moveToState</span><span class="token punctuation">(</span>State next<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mState <span class="token operator">==</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    mState <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mHandlingEvent <span class="token operator">||</span> mAddingObserverCounter <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mNewEventOccurred <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// we will figure out what to do on upper level.</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    mHandlingEvent <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mHandlingEvent <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LifecycleOwner lifecycleOwner <span class="token operator">=</span> mLifecycleOwner<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lifecycleOwner <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"LifecycleOwner of this LifecycleRegistry is already"</span>                <span class="token operator">+</span> <span class="token string">"garbage collected. It is too late to change lifecycle state."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isSynced</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mNewEventOccurred <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// mState 表示宿主的状态，比观察者的小说明是后腿流程 onPause-onStop</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mState<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>mObserverMap<span class="token punctuation">.</span><span class="token function">eldest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mState<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">backwardPass</span><span class="token punctuation">(</span>lifecycleOwner<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>LifecycleObserver<span class="token punctuation">,</span> ObserverWithState<span class="token operator">></span> newest <span class="token operator">=</span> mObserverMap<span class="token punctuation">.</span><span class="token function">newest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 前进流程</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mNewEventOccurred <span class="token operator">&amp;&amp;</span> newest <span class="token operator">!=</span> null                <span class="token operator">&amp;&amp;</span> mState<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>newest<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mState<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">forwardPass</span><span class="token punctuation">(</span>lifecycleOwner<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    mNewEventOccurred <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//while 循环的条件，是否都同步完了</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isSynced</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mObserverMap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    State eldestObserverState <span class="token operator">=</span> mObserverMap<span class="token punctuation">.</span><span class="token function">eldest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mState<span class="token punctuation">;</span>    State newestObserverState <span class="token operator">=</span> mObserverMap<span class="token punctuation">.</span><span class="token function">newest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mState<span class="token punctuation">;</span>    <span class="token keyword">return</span> eldestObserverState <span class="token operator">==</span> newestObserverState <span class="token operator">&amp;&amp;</span> mState <span class="token operator">==</span> newestObserverState<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>前进和后腿</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backwardPass</span><span class="token punctuation">(</span>LifecycleOwner lifecycleOwner<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Iterator<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>LifecycleObserver<span class="token punctuation">,</span> ObserverWithState<span class="token operator">>></span> descendingIterator <span class="token operator">=</span>            mObserverMap<span class="token punctuation">.</span><span class="token function">descendingIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>descendingIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mNewEventOccurred<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>LifecycleObserver<span class="token punctuation">,</span> ObserverWithState<span class="token operator">></span> entry <span class="token operator">=</span> descendingIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObserverWithState observer <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>observer<span class="token punctuation">.</span>mState<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>mState<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mNewEventOccurred                <span class="token operator">&amp;&amp;</span> mObserverMap<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Event event <span class="token operator">=</span> Event<span class="token punctuation">.</span><span class="token function">downFrom</span><span class="token punctuation">(</span>observer<span class="token punctuation">.</span>mState<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//循环倒退</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>event <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"no event down from "</span> <span class="token operator">+</span> observer<span class="token punctuation">.</span>mState<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">pushParentState</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getTargetState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//分发生命周期方法</span>            observer<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>lifecycleOwner<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">popParentState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> Event <span class="token function">downFrom</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> State state<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> CREATED<span class="token operator">:</span>            <span class="token keyword">return</span> ON_DESTROY<span class="token punctuation">;</span>        <span class="token keyword">case</span> STARTED<span class="token operator">:</span>            <span class="token keyword">return</span> ON_STOP<span class="token punctuation">;</span>        <span class="token keyword">case</span> RESUMED<span class="token operator">:</span>            <span class="token keyword">return</span> ON_PAUSE<span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">forwardPass</span><span class="token punctuation">(</span>LifecycleOwner lifecycleOwner<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Iterator<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>LifecycleObserver<span class="token punctuation">,</span> ObserverWithState<span class="token operator">>></span> ascendingIterator <span class="token operator">=</span>            mObserverMap<span class="token punctuation">.</span><span class="token function">iteratorWithAdditions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>ascendingIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mNewEventOccurred<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>LifecycleObserver<span class="token punctuation">,</span> ObserverWithState<span class="token operator">></span> entry <span class="token operator">=</span> ascendingIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObserverWithState observer <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>observer<span class="token punctuation">.</span>mState<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>mState<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mNewEventOccurred                <span class="token operator">&amp;&amp;</span> mObserverMap<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">pushParentState</span><span class="token punctuation">(</span>observer<span class="token punctuation">.</span>mState<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> Event event <span class="token operator">=</span> Event<span class="token punctuation">.</span><span class="token function">upFrom</span><span class="token punctuation">(</span>observer<span class="token punctuation">.</span>mState<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>event <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"no event up from "</span> <span class="token operator">+</span> observer<span class="token punctuation">.</span>mState<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>              <span class="token comment" spellcheck="true">//分发生命周期方法</span>            observer<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>lifecycleOwner<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">popParentState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> Event <span class="token function">upFrom</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> State state<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> INITIALIZED<span class="token operator">:</span>            <span class="token keyword">return</span> ON_CREATE<span class="token punctuation">;</span>        <span class="token keyword">case</span> CREATED<span class="token operator">:</span>            <span class="token keyword">return</span> ON_START<span class="token punctuation">;</span>        <span class="token keyword">case</span> STARTED<span class="token operator">:</span>            <span class="token keyword">return</span> ON_RESUME<span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="区分观察者类型-Lifecycling"><a href="#区分观察者类型-Lifecycling" class="headerlink" title="区分观察者类型-Lifecycling"></a>区分观察者类型-Lifecycling</h4><p>结论是无论哪种方式的观察者都通过适配器模式转换为LifecycleEventObserver类型，当分发事件时，只要执行  mLifecycleObserver.onStateChanged(owner, event); Lifecycling适配的多种类型都会得到相应的分发执行。</p><pre class=" language-java"><code class="language-java"><span class="token function">ObserverWithState</span><span class="token punctuation">(</span>LifecycleObserver observer<span class="token punctuation">,</span> State initialState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    mLifecycleObserver <span class="token operator">=</span> Lifecycling<span class="token punctuation">.</span><span class="token function">lifecycleEventObserver</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    mState <span class="token operator">=</span> initialState<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">dispatchEvent</span><span class="token punctuation">(</span>LifecycleOwner owner<span class="token punctuation">,</span> Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    State newState <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getTargetState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mState <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>mState<span class="token punctuation">,</span> newState<span class="token punctuation">)</span><span class="token punctuation">;</span>    mLifecycleObserver<span class="token punctuation">.</span><span class="token function">onStateChanged</span><span class="token punctuation">(</span>owner<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    mState <span class="token operator">=</span> newState<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>适配器模式转换观察者包装成 LifecycleEventObserver</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> LifecycleEventObserver <span class="token function">lifecycleEventObserver</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> isLifecycleEventObserver <span class="token operator">=</span> object <span class="token keyword">instanceof</span> <span class="token class-name">LifecycleEventObserver</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> isFullLifecycleObserver <span class="token operator">=</span> object <span class="token keyword">instanceof</span> <span class="token class-name">FullLifecycleObserver</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//实现了这个连个接口</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isLifecycleEventObserver <span class="token operator">&amp;&amp;</span> isFullLifecycleObserver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FullLifecycleObserverAdapter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>FullLifecycleObserver<span class="token punctuation">)</span> object<span class="token punctuation">,</span>                <span class="token punctuation">(</span>LifecycleEventObserver<span class="token punctuation">)</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isFullLifecycleObserver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FullLifecycleObserverAdapter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>FullLifecycleObserver<span class="token punctuation">)</span> object<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isLifecycleEventObserver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>LifecycleEventObserver<span class="token punctuation">)</span> object<span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//实现的LifecycleObserver + 注解的方式，最新版本已经废弃，存在拖慢编译速度，反射效率低的问题</span>    <span class="token keyword">final</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> klass <span class="token operator">=</span> object<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> type <span class="token operator">=</span> <span class="token function">getObserverConstructorType</span><span class="token punctuation">(</span>klass<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过反射apt 生成的 adapter 类是否发生ClassNotFoundException异常来判断是否采用了apt</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> GENERATED_CALLBACK<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 采用的 apt 的方式</span>      <span class="token comment" spellcheck="true">//GeneratedAdapter 是生成类的接口</span>        List<span class="token operator">&lt;</span>Constructor<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">GeneratedAdapter</span><span class="token operator">>></span> constructors <span class="token operator">=</span>                sClassToAdapters<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>klass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>constructors<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            GeneratedAdapter generatedAdapter <span class="token operator">=</span> <span class="token function">createGeneratedAdapter</span><span class="token punctuation">(</span>                    constructors<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SingleGeneratedAdapterObserver</span><span class="token punctuation">(</span>generatedAdapter<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        GeneratedAdapter<span class="token punctuation">[</span><span class="token punctuation">]</span> adapters <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GeneratedAdapter</span><span class="token punctuation">[</span>constructors<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> constructors<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            adapters<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">createGeneratedAdapter</span><span class="token punctuation">(</span>constructors<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CompositeGeneratedAdaptersObserver</span><span class="token punctuation">(</span>adapters<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ReflectiveGenericLifecycleObserver</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 运行时反射的方式</span><span class="token punctuation">}</span></code></pre><p>适配器转换为 LifecycleEventObserver 类型</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">FullLifecycleObserverAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">LifecycleEventObserver</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> FullLifecycleObserver mFullLifecycleObserver<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> LifecycleEventObserver mLifecycleEventObserver<span class="token punctuation">;</span>    <span class="token function">FullLifecycleObserverAdapter</span><span class="token punctuation">(</span>FullLifecycleObserver fullLifecycleObserver<span class="token punctuation">,</span>            LifecycleEventObserver lifecycleEventObserver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mFullLifecycleObserver <span class="token operator">=</span> fullLifecycleObserver<span class="token punctuation">;</span>        mLifecycleEventObserver <span class="token operator">=</span> lifecycleEventObserver<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStateChanged</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> LifecycleOwner source<span class="token punctuation">,</span> <span class="token annotation punctuation">@NonNull</span> Lifecycle<span class="token punctuation">.</span>Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> ON_CREATE<span class="token operator">:</span>                mFullLifecycleObserver<span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> ON_START<span class="token operator">:</span>                mFullLifecycleObserver<span class="token punctuation">.</span><span class="token function">onStart</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> ON_RESUME<span class="token operator">:</span>                mFullLifecycleObserver<span class="token punctuation">.</span><span class="token function">onResume</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> ON_PAUSE<span class="token operator">:</span>                mFullLifecycleObserver<span class="token punctuation">.</span><span class="token function">onPause</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> ON_STOP<span class="token operator">:</span>                mFullLifecycleObserver<span class="token punctuation">.</span><span class="token function">onStop</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> ON_DESTROY<span class="token operator">:</span>                mFullLifecycleObserver<span class="token punctuation">.</span><span class="token function">onDestroy</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> ON_ANY<span class="token operator">:</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"ON_ANY must not been send by anybody"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mLifecycleEventObserver <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mLifecycleEventObserver<span class="token punctuation">.</span><span class="token function">onStateChanged</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>apt 生成的方式转换为 LifecycleEventObserver类型</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SingleGeneratedAdapterObserver</span> <span class="token keyword">implements</span> <span class="token class-name">LifecycleEventObserver</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> GeneratedAdapter mGeneratedAdapter<span class="token punctuation">;</span>    <span class="token function">SingleGeneratedAdapterObserver</span><span class="token punctuation">(</span>GeneratedAdapter generatedAdapter<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mGeneratedAdapter <span class="token operator">=</span> generatedAdapter<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStateChanged</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> LifecycleOwner source<span class="token punctuation">,</span> <span class="token annotation punctuation">@NonNull</span> Lifecycle<span class="token punctuation">.</span>Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mGeneratedAdapter<span class="token punctuation">.</span><span class="token function">callMethods</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> event<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        mGeneratedAdapter<span class="token punctuation">.</span><span class="token function">callMethods</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> event<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">CompositeGeneratedAdaptersObserver</span> <span class="token keyword">implements</span> <span class="token class-name">LifecycleEventObserver</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> GeneratedAdapter<span class="token punctuation">[</span><span class="token punctuation">]</span> mGeneratedAdapters<span class="token punctuation">;</span>    <span class="token function">CompositeGeneratedAdaptersObserver</span><span class="token punctuation">(</span>GeneratedAdapter<span class="token punctuation">[</span><span class="token punctuation">]</span> generatedAdapters<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mGeneratedAdapters <span class="token operator">=</span> generatedAdapters<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStateChanged</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> LifecycleOwner source<span class="token punctuation">,</span> <span class="token annotation punctuation">@NonNull</span> Lifecycle<span class="token punctuation">.</span>Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MethodCallsLogger logger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MethodCallsLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>GeneratedAdapter mGenerated<span class="token operator">:</span> mGeneratedAdapters<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mGenerated<span class="token punctuation">.</span><span class="token function">callMethods</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> event<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> logger<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>GeneratedAdapter mGenerated<span class="token operator">:</span> mGeneratedAdapters<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mGenerated<span class="token punctuation">.</span><span class="token function">callMethods</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> event<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> logger<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="7-4-Application-实现"><a href="#7-4-Application-实现" class="headerlink" title="7.4 Application 实现"></a>7.4 Application 实现</h3><p>注册</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyLifecycleApplication</span> <span class="token operator">:</span> <span class="token function">MultiDexApplication</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    override fun <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//饿汉式单例获取 ProcessLifecycleOwner</span>        ProcessLifecycleOwner<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>lifecycle<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token function">MyLifecycleApplicationObserver</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过 startup 初始化ProcessLifecycleInitializer</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>provider</span>    <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>androidx.startup.InitializationProvider<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>authorities</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${applicationId}.androidx-startup<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>exported</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">tools:</span>node</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>merge<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta-data</span>        <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>androidx.lifecycle.ProcessLifecycleInitializer<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>androidx.startup<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>provider</span><span class="token punctuation">></span></span></code></pre><p>ProcessLifecycleInitializer</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ProcessLifecycleInitializer</span> <span class="token keyword">implements</span> <span class="token class-name">Initializer</span><span class="token operator">&lt;</span>LifecycleOwner<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@NonNull</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> LifecycleOwner <span class="token function">create</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LifecycleDispatcher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        ProcessLifecycleOwner<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ProcessLifecycleOwner<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@NonNull</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Initializer</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>>></span> <span class="token function">dependencies</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>ProcessLifecycleOwner 用于今天Application 的生命周期的变化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProcessLifecycleOwner</span> <span class="token keyword">implements</span> <span class="token class-name">LifecycleOwner</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@VisibleForTesting</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> TIMEOUT_MS <span class="token operator">=</span> <span class="token number">700</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//mls</span>    <span class="token comment" spellcheck="true">// ground truth counters</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> mStartedCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> mResumedCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> mPauseSent <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> mStopSent <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Handler mHandler<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> LifecycleRegistry mRegistry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LifecycleRegistry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Runnable mDelayedPauseRunnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">dispatchPauseIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">dispatchStopIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    ActivityInitializationListener mInitializationListener <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">ActivityInitializationListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">}</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">activityStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onResume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">activityResumed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ProcessLifecycleOwner sInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProcessLifecycleOwner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * The LifecycleOwner for the whole application process. Note that if your application     * has multiple processes, this provider does not know about other processes.     *     * @return {@link LifecycleOwner} for the whole application.     */</span>    <span class="token annotation punctuation">@NonNull</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> LifecycleOwner <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> sInstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sInstance<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">activityStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mStartedCounter<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mStartedCounter <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> mStopSent<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mRegistry<span class="token punctuation">.</span><span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_START<span class="token punctuation">)</span><span class="token punctuation">;</span>            mStopSent <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">activityResumed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mResumedCounter<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mResumedCounter <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mPauseSent<span class="token punctuation">)</span> <span class="token punctuation">{</span>                mRegistry<span class="token punctuation">.</span><span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_RESUME<span class="token punctuation">)</span><span class="token punctuation">;</span>                mPauseSent <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                mHandler<span class="token punctuation">.</span><span class="token function">removeCallbacks</span><span class="token punctuation">(</span>mDelayedPauseRunnable<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">activityPaused</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mResumedCounter<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mResumedCounter <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            mHandler<span class="token punctuation">.</span><span class="token function">postDelayed</span><span class="token punctuation">(</span>mDelayedPauseRunnable<span class="token punctuation">,</span> TIMEOUT_MS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">activityStopped</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mStartedCounter<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token function">dispatchStopIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">dispatchPauseIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mResumedCounter <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            mPauseSent <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            mRegistry<span class="token punctuation">.</span><span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_PAUSE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">dispatchStopIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mStartedCounter <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> mPauseSent<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mRegistry<span class="token punctuation">.</span><span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_STOP<span class="token punctuation">)</span><span class="token punctuation">;</span>            mStopSent <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">ProcessLifecycleOwner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"deprecation"</span><span class="token punctuation">)</span>    <span class="token keyword">void</span> <span class="token function">attach</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mRegistry<span class="token punctuation">.</span><span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_CREATE<span class="token punctuation">)</span><span class="token punctuation">;</span>        Application app <span class="token operator">=</span> <span class="token punctuation">(</span>Application<span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        app<span class="token punctuation">.</span><span class="token function">registerActivityLifecycleCallbacks</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EmptyActivityLifecycleCallbacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@RequiresApi</span><span class="token punctuation">(</span><span class="token number">29</span><span class="token punctuation">)</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onActivityPreCreated</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Activity activity<span class="token punctuation">,</span>                    <span class="token annotation punctuation">@Nullable</span> Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// We need the ProcessLifecycleOwner to get ON_START and ON_RESUME precisely</span>                <span class="token comment" spellcheck="true">// before the first activity gets its LifecycleOwner started/resumed.</span>                <span class="token comment" spellcheck="true">// The activity's LifecycleOwner gets started/resumed via an activity registered</span>                <span class="token comment" spellcheck="true">// callback added in onCreate(). By adding our own activity registered callback in</span>                <span class="token comment" spellcheck="true">// onActivityPreCreated(), we get our callbacks first while still having the</span>                <span class="token comment" spellcheck="true">// right relative order compared to the Activity's onStart()/onResume() callbacks.</span>                activity<span class="token punctuation">.</span><span class="token function">registerActivityLifecycleCallbacks</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EmptyActivityLifecycleCallbacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onActivityPostStarted</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Activity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">activityStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onActivityPostResumed</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Activity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">activityResumed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onActivityCreated</span><span class="token punctuation">(</span>Activity activity<span class="token punctuation">,</span> Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Only use ReportFragment pre API 29 - after that, we can use the</span>                <span class="token comment" spellcheck="true">// onActivityPostStarted and onActivityPostResumed callbacks registered in</span>                <span class="token comment" spellcheck="true">// onActivityPreCreated()</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Build<span class="token punctuation">.</span>VERSION<span class="token punctuation">.</span>SDK_INT <span class="token operator">&lt;</span> <span class="token number">29</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    ReportFragment<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>activity<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setProcessListener</span><span class="token punctuation">(</span>mInitializationListener<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onActivityPaused</span><span class="token punctuation">(</span>Activity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">activityPaused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onActivityStopped</span><span class="token punctuation">(</span>Activity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">activityStopped</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@NonNull</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Lifecycle <span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mRegistry<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>LifecycleDispatcher 用于为所有 Activity 注入ReportFragment，这样之后对于SDK 中的 Activity 只要实现 LifecycleOwner 就能实现生命周期可观察的能力。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LifecycleDispatcher</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> AtomicBoolean sInitialized <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicBoolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sInitialized<span class="token punctuation">.</span><span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>Application<span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">registerActivityLifecycleCallbacks</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DispatcherActivityCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"WeakerAccess"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@VisibleForTesting</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DispatcherActivityCallback</span> <span class="token keyword">extends</span> <span class="token class-name">EmptyActivityLifecycleCallbacks</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onActivityCreated</span><span class="token punctuation">(</span>Activity activity<span class="token punctuation">,</span> Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ReportFragment<span class="token punctuation">.</span><span class="token function">injectIfNeededIn</span><span class="token punctuation">(</span>activity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onActivityStopped</span><span class="token punctuation">(</span>Activity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onActivitySaveInstanceState</span><span class="token punctuation">(</span>Activity activity<span class="token punctuation">,</span> Bundle outState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">LifecycleDispatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="7-5-Service-实现"><a href="#7-5-Service-实现" class="headerlink" title="7.5 Service 实现"></a>7.5 Service 实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyLifecycleService</span> <span class="token operator">:</span> <span class="token function">LifecycleService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    init <span class="token punctuation">{</span>        lifecycle<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token function">MyLifecycleServiceObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>LifecycleService </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LifecycleService</span> <span class="token keyword">extends</span> <span class="token class-name">Service</span> <span class="token keyword">implements</span> <span class="token class-name">LifecycleOwner</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ServiceLifecycleDispatcher mDispatcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceLifecycleDispatcher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@CallSuper</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mDispatcher<span class="token punctuation">.</span><span class="token function">onServicePreSuperOnCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@CallSuper</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> IBinder <span class="token function">onBind</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Intent intent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mDispatcher<span class="token punctuation">.</span><span class="token function">onServicePreSuperOnBind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"deprecation"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@CallSuper</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStart</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Intent intent<span class="token punctuation">,</span> <span class="token keyword">int</span> startId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mDispatcher<span class="token punctuation">.</span><span class="token function">onServicePreSuperOnStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStart</span><span class="token punctuation">(</span>intent<span class="token punctuation">,</span> startId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// this method is added only to annotate it with @CallSuper.</span>    <span class="token comment" spellcheck="true">// In usual service super.onStartCommand is no-op, but in LifecycleService</span>    <span class="token comment" spellcheck="true">// it results in mDispatcher.onServicePreSuperOnStart() call, because</span>    <span class="token comment" spellcheck="true">// super.onStartCommand calls onStart().</span>    <span class="token annotation punctuation">@CallSuper</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">onStartCommand</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Intent intent<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> startId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStartCommand</span><span class="token punctuation">(</span>intent<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> startId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@CallSuper</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mDispatcher<span class="token punctuation">.</span><span class="token function">onServicePreSuperOnDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@NonNull</span>    <span class="token keyword">public</span> Lifecycle <span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mDispatcher<span class="token punctuation">.</span><span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>ServiceLifecycleDispatcher</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceLifecycleDispatcher</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> LifecycleRegistry mRegistry<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Handler mHandler<span class="token punctuation">;</span>    <span class="token keyword">private</span> DispatchRunnable mLastDispatchRunnable<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * @param provider {@link LifecycleOwner} for a service, usually it is a service itself     */</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"deprecation"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token function">ServiceLifecycleDispatcher</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> LifecycleOwner provider<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mRegistry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LifecycleRegistry</span><span class="token punctuation">(</span>provider<span class="token punctuation">)</span><span class="token punctuation">;</span>        mHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">postDispatchRunnable</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mLastDispatchRunnable <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mLastDispatchRunnable<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        mLastDispatchRunnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DispatchRunnable</span><span class="token punctuation">(</span>mRegistry<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>        mHandler<span class="token punctuation">.</span><span class="token function">postAtFrontOfQueue</span><span class="token punctuation">(</span>mLastDispatchRunnable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Must be a first call in {@link Service#onCreate()} method, even before super.onCreate call.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onServicePreSuperOnCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">postDispatchRunnable</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_CREATE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Must be a first call in {@link Service#onBind(Intent)} method, even before super.onBind     * call.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onServicePreSuperOnBind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">postDispatchRunnable</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_START<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Must be a first call in {@link Service#onStart(Intent, int)} or     * {@link Service#onStartCommand(Intent, int, int)} methods, even before     * a corresponding super call.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onServicePreSuperOnStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">postDispatchRunnable</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_START<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Must be a first call in {@link Service#onDestroy()} method, even before super.OnDestroy     * call.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onServicePreSuperOnDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">postDispatchRunnable</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_STOP<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">postDispatchRunnable</span><span class="token punctuation">(</span>Lifecycle<span class="token punctuation">.</span>Event<span class="token punctuation">.</span>ON_DESTROY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * @return {@link Lifecycle} for the given {@link LifecycleOwner}     */</span>    <span class="token annotation punctuation">@NonNull</span>    <span class="token keyword">public</span> Lifecycle <span class="token function">getLifecycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mRegistry<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DispatchRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> LifecycleRegistry mRegistry<span class="token punctuation">;</span>        <span class="token keyword">final</span> Lifecycle<span class="token punctuation">.</span>Event mEvent<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">boolean</span> mWasExecuted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token function">DispatchRunnable</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> LifecycleRegistry registry<span class="token punctuation">,</span> Lifecycle<span class="token punctuation">.</span>Event event<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mRegistry <span class="token operator">=</span> registry<span class="token punctuation">;</span>            mEvent <span class="token operator">=</span> event<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mWasExecuted<span class="token punctuation">)</span> <span class="token punctuation">{</span>                mRegistry<span class="token punctuation">.</span><span class="token function">handleLifecycleEvent</span><span class="token punctuation">(</span>mEvent<span class="token punctuation">)</span><span class="token punctuation">;</span>                mWasExecuted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="8-链接"><a href="#8-链接" class="headerlink" title="8. 链接"></a>8. 链接</h2><ul><li><p><a href="https://github.com/androidx/androidx/tree/androidx-main/lifecycle" target="_blank" rel="noopener">Github | Lifecycle</a></p></li><li><p><a href="https://developer.android.com/jetpack/androidx/releases/lifecycle" target="_blank" rel="noopener">Android 开发者 | Lifecycle</a></p></li><li><p><a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">用户指南</a> </p></li><li><p><a href="https://github.com/android/architecture-components-samples" target="_blank" rel="noopener">代码示例</a> </p></li><li><p><a href="https://codelabs.developers.google.com/codelabs/android-lifecycles/index.html?index=#0" target="_blank" rel="noopener">Codelab</a></p></li><li><p><a href="https://developer.android.com/jetpack/androidx/releases/lifecycle#declaring_dependencies" target="_blank" rel="noopener">Lifecycle 版本说明</a></p></li><li><p><a href="https://github.com/googlecodelabs/android-lifecycles" target="_blank" rel="noopener">googlecodelabs | android-lifecycles</a></p></li><li><p><a href="https://stackoverflow.com/questions/52369540/what-is-lifecycle-observer-and-how-to-use-it-correctly" target="_blank" rel="noopener">What is lifecycle observer and how to use it correctly?</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
            <tag> Lifecycle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventBus 事件总线框架深入分析</title>
      <link href="2021/01/31/lib-eventbus/"/>
      <url>2021/01/31/lib-eventbus/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/post_banner_jay.png" alt=""></p><h1 id="EventBus-事件总线框架深入分析"><a href="#EventBus-事件总线框架深入分析" class="headerlink" title="EventBus 事件总线框架深入分析"></a>EventBus 事件总线框架深入分析</h1><h2 id="1-EventBus-关键词云"><a href="#1-EventBus-关键词云" class="headerlink" title="1. EventBus 关键词云"></a>1. EventBus 关键词云</h2><p>设计模式、数据结构、内存占用、查找效率、线程安全、对象池、事件继承问题、事件发布器、线程模式、同步、异步</p><h2 id="2-EventBus-快问快答"><a href="#2-EventBus-快问快答" class="headerlink" title="2. EventBus 快问快答"></a>2. EventBus 快问快答</h2><p>EventBus 中运用了那些设计模式</p><ul><li>观察者、单例、构建者、门面、策略</li></ul><p>EventBus 中运用了那些数据结构</p><ul><li>ThreadLocal、CopyOnWriteArrayList、ConcurrentHashMap、HashMap、PendingPostQueue</li></ul><p>EventBus 中的对象池</p><ul><li>FindState/FIND_STATE_POOL、PendingPost/pendingPostPool</li></ul><p>EventBus 中的锁与线程安全问题</p><ul><li>并发容器、同步锁、ThreadLocal</li></ul><p>如何设计一个最小原型 EventBus 框架需要考虑哪些问题</p><ul><li>内存占用、查找效率、线程安全</li></ul><p>EventBus 中的事件发布时如何实现同步、异步的</p><ul><li>同步：主线程、Handler；异步：子线程</li></ul><h2 id="3-EventBus-总结"><a href="#3-EventBus-总结" class="headerlink" title="3. EventBus 总结"></a>3. EventBus 总结</h2><h4 id="3-1-编译时APT流程总结"><a href="#3-1-编译时APT流程总结" class="headerlink" title="3.1 编译时APT流程总结"></a>3.1 编译时APT流程总结</h4><p>EventBus 中订阅者的收集是通过两种方式，一种是运行时反射收集，另一种是通过注解处理器收集。通过apt收集相比通过运行时反射的方式可以减少因为反射带来的性能开销，但是会影响编译时的时间。综合考量必然还是推荐通过APT方式。</p><p>通过APT方式收集订阅者的大体流程如下：</p><ul><li>在编码阶段添加订阅者方法时我们需要通过 <strong>@Subscribe</strong> 注解类标注订阅者，该注解类提供三个参数用来个性化配置订阅者，三个参数分别是：<strong>enum ThreadMode、boolean sticky，int priority</strong> 。注解处理器所做的工作就是收集订阅者方法以及这些方法所在的类信息。</li><li>EventBus 规定生成的索引类的全类名是由开发者自行定义传入的，所以在编译之前还模块的 build.gradle 中需要配置索引类，否则会编译错误。</li><li>注解处理器注解处理流程主要分为：<strong>收集订阅者、校验订阅者、生成索引类</strong>三个过程。<ul><li><strong>收集订阅者</strong>：遍历所有可执行元素 ExecutableElement，校验订阅者方法签名，订阅者方法签名需要满足 <strong>正好只有一个参数的非静态的公开的方法</strong> 的规则。然后将找到的订阅者方法和订阅者类存入 *<em>ListMap&lt;TypeElement, ExecutableElement&gt; methodsByClass *</em>  容器中。该容器的数据结构是：<code>HashMap&lt;K, List&lt;V&gt;&gt;()</code> key 存入的是订阅者类，value 是该类中所有订阅者方法的集合。</li><li><strong>校验订阅者</strong>（包括订阅者类/订阅者类的父类和订阅者方法）：<ul><li>校验订阅者类：遍历所有上一步收集到的订阅者类，校验订阅者类，订阅者类需要满足<strong>public/default+索引类和订阅者类的包名一样</strong> 的规则，不满足的订阅者类需要添加到 <strong>Set<typeelement> classesToSkip</typeelement></strong> 容器中标记。</li><li>校验订阅者类中的方法：满足上一步的订阅者类中任何一个订阅者方法满足以下情况的直接将对应的订阅者类需要添加到 <strong>Set<typeelement> classesToSkip</typeelement></strong> 容器中标记。<ul><li>订阅者方法的参数类型(也就是Event 类型)不是 DeclaredType 或者是 DeclaredType 但不是 TypeElement。</li><li>订阅者方法的参数类型是类类型但是对索引类不可见。</li></ul></li></ul></li><li><strong>生成索引类</strong>：遍历最终收集到的 <strong>methodsByClass</strong> 订阅者信息通过字符串拼接的方式生成索引类。这里换成Javapoet的方式更容易维护，EventBus 可能是为了节省框架包的体积没有采用Javapoet的方式生成java文件。</li></ul></li></ul><h4 id="3-2-初始化EventBus-总结"><a href="#3-2-初始化EventBus-总结" class="headerlink" title="3.2 初始化EventBus 总结"></a>3.2 初始化EventBus 总结</h4><p>总的来说 EventBus 的初始化流程不是很复杂， EventBus 对象的创建结合了单例模式和构建者模式。</p><p>单例模式常用于构建全局唯一类并提供全局唯一访问点。</p><p>构建者模式常用于构建可以通过设置不同的可选参数，定制化地创建一个复杂对象。</p><p>EventBus 恰好需要全局唯一且配置复杂，此时就可以结合两个设计模式应对不同的构建场景。</p><p>需要全局唯一默认配置的实例直接通过单例获取，需要为前面的单例个性化定制也可以通过构建者模式配置参数。</p><p>你自己维护全局唯一或者需要局部唯一的场景也可以通过构建者模式个性化定制。</p><p>可能是因为 EventBus  的应用场景多样，他的DCL单例模式并没有显示私有构造方法和静态实例变量，也就是说直接 new EventBus 也是可以的。</p><h4 id="3-3-注册订阅者流程总结"><a href="#3-3-注册订阅者流程总结" class="headerlink" title="3.3 注册订阅者流程总结"></a>3.3 注册订阅者流程总结</h4><p>注册订阅者分为查找和订阅两个过程</p><p>查找过程具体是通过当前订阅者类找出该类中声明的所有订阅者方法。查找逻辑封装在 SubscriberMethodFinder 类中，查找方式有两中，如果使用了注解处理器模块就可以通过生成的索引类查找，这种方式不需要通过反射就能收集到所有订阅者方法，效率较高。</p><p>还有一种就是运行时通过反射订阅者类的getMethods 或者getDeclaredMethods这两个方法收集订阅者方法，这种方式效率低，不推荐使用。</p><p>订阅过程具体是针对当前订阅者的每一个订阅者方法（查找流程得到）以事件类为范围进行全局排序，收集当前订阅者类的所有事件以及对粘性事件的分发。</p><h4 id="3-4-事件发布流程总结"><a href="#3-4-事件发布流程总结" class="headerlink" title="3.4 事件发布流程总结"></a>3.4 事件发布流程总结</h4><p>发布事件通过ThreadLocal保证发送时的同步问题，粘性事件就是发布前存到一个map中，当订阅者注册时会遍历该map执行粘性事件的发布，事件发布时默认会考虑事件的继承关系即订阅事件的父类的订阅者也会收到事件。</p><p>具体发布过程为：通过单事件，找到所有观察者，遍历所有观察该事件的观察者，执行发布操作，发布时会根据订阅者的线程模型做出不同处理，通过三个发布器 mainThreadPoster,backgroundPoster,asyncPoster  完成四种线程模型的切换，最后通过反射调用观察者。</p><h4 id="3-5-注销订阅者流程总结"><a href="#3-5-注销订阅者流程总结" class="headerlink" title="3.5 注销订阅者流程总结"></a>3.5 注销订阅者流程总结</h4><p>注销流程就是先通过订阅者类找所有事件，遍历每一个事件找所有订阅者，判断订阅者中的订阅者类是否和当前类一致，一致就将订阅者中的 active 标记为false 用来阻止继续发布事件，并从内存map中移除。</p><h2 id="4-概述"><a href="#4-概述" class="headerlink" title="4. 概述"></a>4. 概述</h2><blockquote><p>框架的作用有：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。</p></blockquote><p>EventBus 翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架，非常容易地在自己的业务场景中实现<strong>观察者模式</strong>，从而减少样板代码。其中，<a href="https://github.com/google/guava/wiki/EventBusExplained" target="_blank" rel="noopener">Google Guava EventBus</a>  就是一个比较著名的 EventBus 框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式。</p><p>而我们今天要分析的 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener"><strong>GreenRobot EventBus</strong></a> 是同时适用于 Android 和 Java 平台的事件总线框架，它可简化Activities, Fragments, Threads, Services之间的通信且轻量，它的核心设计理念是对观察者模式（Observer Design Pattern）也被称为发布订阅模式（Publish-Subscribe Design Pattern）的封装。传统的事件传递方式包括：Handler、BroadcastReceiver、Interface回调等，相比之下EventBus的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。</p><blockquote><p>*<em>观察者模式 *</em></p><p>定义：定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。</p><p>作用：解耦观察者和被观察者。</p><p>实现：</p><ul><li><p><strong>同步阻塞</strong>是最经典的实现方式，主要是为了代码解耦；观察者和被观察者代码在同一个线程内执行，被观察者发送更新通知后就一直阻塞着，直到所有的观察者代码都执行完成之后，才会执行后续的代码。</p></li><li><p><strong>异步非阻塞</strong>除了能实现代码解耦之外，还能提高代码的执行效率；实现方式是被观察者发送更新通知后启动一个新的线程来执行观察者的回调函数。</p></li></ul></blockquote><p><strong>EventBus 观察者模式框架 VS 自己实现观察模式</strong></p><p>利用 EventBus 框架实现的观察者模式，跟从零开始编写的观察者模式相比，从大的流程上来说，实现思路大致一样，都需要定义观察者（Observer），并且通过 register() 函数注册Observer，也都需要通过调用某个函数（比如，EventBus 中的 post() 函数）来给 Observer 发送消息（在 EventBus 中消息被称作事件 event）。</p><p>但在实现细节方面，它们又有些区别。基于 EventBus，我们不需要定义 Observer 接口，任意类型的对象都可以注册到 EventBus 中，通过 @Subscribe 注解来标明类中哪个函数可以接收被观察者发送的消息。</p><p>跟经典的观察者模式的不同之处在于，当我们调用 post() 函数发送消息的时候，并非把消息发送给所有的观察者，而是发送给可匹配的观察者。所谓可匹配指的是，能接收的消息类型是发送消息（post 函数定义中的 event）类型或是其父类。</p><h2 id="5-工作机制"><a href="#5-工作机制" class="headerlink" title="5. 工作机制"></a>5. 工作机制</h2><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20211107112804.png" alt="EventBus-Android-Publish-Subscribe"></p><p><strong>发布者(Publisher)</strong>：发布者主动生成事件发布事件给指定订阅者。</p><pre class=" language-java"><code class="language-java">EventBus<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>事件总线(EventBus)</strong>：统筹所有事件的调度工作，如：收集、注册、切换、分发、解注册等操作。</p><pre class=" language-java"><code class="language-java">EventBus<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>EventBus<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unregister</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>订阅者(Subscriber)</strong>：声明订阅方法并通过注释标记，可指定线程模式。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Subscribe</span><span class="token punctuation">(</span>threadMode <span class="token operator">=</span> ThreadMode<span class="token punctuation">.</span>MAIN<span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onMessageEvent</span><span class="token punctuation">(</span>MessageEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* Do something */</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="6-EventBus-优势"><a href="#6-EventBus-优势" class="headerlink" title="6. EventBus 优势"></a>6. EventBus 优势</h2><ul><li>简化组件之间的通信，同进程内随便发，组件化中需要考虑 Event Object 的存放位置。</li><li>解耦事件的发送者和接收者，仅通过 Event Object 进行链接发送者和接受者。</li><li>在 UI 组件和后台线程切换中表现良好的性能</li><li>避免复杂且容易出错的依赖关系和生命周期问题，提供解注册订阅者。</li><li>很快；专为高性能而优化，很小（~60k jar）</li><li><a href="http://www.appbrain.com/stats/libraries/details/eventbus/greenrobot-eventbus" target="_blank" rel="noopener">在实践中被证明通过应用与1,000,000,000+安装</a></li><li>具有分发指定线程、设置订阅者优先级等功能。</li></ul><h2 id="7-EventBus-功能"><a href="#7-EventBus-功能" class="headerlink" title="7. EventBus 功能"></a>7. EventBus 功能</h2><ul><li><strong>简单而强大：</strong> EventBus 是一个小型库，其 API 非常容易学习。然而，通过解耦组件，您的软件架构可能会受益匪浅：订阅者在使用事件时并不了解发送者。</li><li>实战<strong>测试：</strong> EventBus 是最常用的 Android 库之一：数以千计的应用程序使用 EventBus，包括非常流行的应用程序。超过 10 亿次应用安装不言而喻。</li><li><strong>高性能：</strong>尤其是在 Android 上，性能很重要。EventBus 进行了大量分析和优化；可能使其成为同类中最快的解决方案。</li><li><strong>方便的基于注释的 API</strong> （不牺牲性能）<strong>：</strong>只需将 @Subscribe 注释放在您的订阅者方法中。由于注释的构建时索引，EventBus 不需要在您的应用程序运行时进行注释反射，这在 Android 上非常慢。</li><li><strong>Android 主线程传递：</strong>在与 UI 交互时，EventBus 可以在主线程中传递事件，而不管事件是如何发布的。</li><li><strong>后台线程传递：</strong>如果您的订阅者执行长时间运行的任务，EventBus 还可以使用后台线程来避免 UI 阻塞。</li><li><strong>事件和订阅者继承：</strong>在 EventBus 中，面向对象的范式适用于事件和订阅者类。假设事件类 A 是 B 的超类。发布的 B 类事件也将发布给对 A 感兴趣的订阅者。类似地考虑订阅者类的继承。</li><li><strong>零配置：</strong> 您可以立即开始使用代码中任何位置可用的默认 EventBus 实例。</li><li><strong>可配置：</strong> 要根据您的要求调整 EventBus，您可以使用构建器模式调整其行为。</li></ul><h2 id="8-EventBus-应用"><a href="#8-EventBus-应用" class="headerlink" title="8. EventBus 应用"></a>8. EventBus 应用</h2><ul><li>如果使用 EventBus 的页面比较多，可以在 Acitivity/Fragment  基类里面绑定和解绑，并添加一个默认接收事件。</li><li>跨界面修改值<ul><li>你有一个主界面，里面有一些信息可能会修改，但触发源不在该界面，是在其他的界面触发了一些事件后，首页的内容需要做修改。</li><li>如果没有EventBus，也有很多的方式可以实现，譬如定义全局静态变量、或者onResume时获取触发源的值修改界面值、或者定义个CallBack接口传出去等。</li><li>譬如微信首页你有未读消息3个时，界面会有3个小红点点，当你点开一个未读消息后，进入了下个界面，那么此时未读消息就是2了，但你并不在首页了，你需要在你打开消息并阅读完毕后通知首页改成2.这就是一种跨界面修改值。</li></ul></li><li>Activity/Fragment 与 Fragment 之间通信</li><li>注册页面回退逻辑<ul><li>在注册页面填写了手机号、个人信息，传头像操作后，注册成功了，进入了主界面。此时我们需要在主界面关闭之前的注册的所有页面，此时就可以使用eventbus来通知前几个注册用的activity来关闭自己。这样的目的就是当注册失败时，用户按返回键还是能回到填写信息页。当注册成功后，按返回键就直接退出程序，不再保留注册填信息页了。</li></ul></li><li>推送/消息功能<ul><li>收到推送后需要不同的页面来做处理的。例如：微信PC登录时，手机端的确认登录页面是可以随时随地弹出的，</li></ul></li><li>组件化通讯<ul><li>组件之间的交互，例如：测试环境中环境切换组件，切换后需要重新登录并重置环境信息等。</li></ul></li><li>EventBus最好的使用方式就是替代某些 BroadcastReceiver 和 Interface；如fragment之间进行通信，用广播和接口都比较麻烦，而用EventBus则比较简单。</li><li>以下场景可以考虑不用<ul><li>Event 会根据传递的参数给所有接收者都传递消息，这就导致如果你想给指定一个类里发布消息就得自己写一个接口类，要不然就会好多执行者都会执行该方法，所以一般能用Intent组件传值时还是用Intent。</li><li>EventBus相对于BroadcastReceiver，广播是相对消耗时间、空间最多的一种方式，但是大家都知道，广播是四大组件之一，许多系统级的事件都是通过广播来通知的，比如说网络的变化、电量的变化，短信发送和接收的状态，所以，如果与android系统进行相关的通知，还是要选择本地广播；在BroadcastReceiver的 onReceive方法中，可以获得Context 、intent参数，这两个参数可以调用许多的sdk中的方法，而eventbus获得这两个参数相对比较困难。</li><li>EventBus相对于handler，可以实现handler的方式，但是也会面对有许多接收者的问题，所以如果是线程回调的话，我觉得还是用handler比较好。</li></ul></li></ul><h2 id="9-EventBus-使用"><a href="#9-EventBus-使用" class="headerlink" title="9. EventBus 使用"></a>9. EventBus 使用</h2><h3 id="9-1-订阅者索引"><a href="#9-1-订阅者索引" class="headerlink" title="9.1 订阅者索引"></a>9.1 订阅者索引</h3><p>使用订阅者索引可以避免在运行时使用反射对订阅者方法进行昂贵的查找。EventBus 注释处理器在编译时查找它们。</p><h4 id="符合注解收集的要求"><a href="#符合注解收集的要求" class="headerlink" title="符合注解收集的要求"></a>符合注解收集的要求</h4><ul><li>@Subscribe 方法及其类<strong>必须是 public</strong>。</li><li>事件类<strong>必须是 public</strong>。</li><li>@Subscribe可以<strong>不</strong>被使用<strong>匿名类的内部</strong>。</li><li>当 EventBus 不能使用索引时，例如不满足上述要求，它会在运行时降级为通过反射查找订阅者。这确保@Subscribe 方法接收事件，即使它们不是索引的一部分。</li></ul><h4 id="配置注解处理器"><a href="#配置注解处理器" class="headerlink" title="配置注解处理器"></a>配置注解处理器</h4><pre class=" language-groovy"><code class="language-groovy"><span class="token comment" spellcheck="true">//java</span>android <span class="token punctuation">{</span>    defaultConfig <span class="token punctuation">{</span>        javaCompileOptions <span class="token punctuation">{</span>            annotationProcessorOptions <span class="token punctuation">{</span>                arguments <span class="token operator">=</span> <span class="token punctuation">[</span> eventBusIndex <span class="token punctuation">:</span> <span class="token string">'com.example.myapp.MyEventBusIndex'</span> <span class="token punctuation">]</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>dependencies <span class="token punctuation">{</span>    <span class="token keyword">def</span> eventbus_version <span class="token operator">=</span> <span class="token string">'3.2.0'</span>    implementation <span class="token string">"org.greenrobot:eventbus:$eventbus_version"</span>    annotationProcessor <span class="token string">"org.greenrobot:eventbus-annotation-processor:$eventbus_version"</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//kotlin </span>apply plugin<span class="token punctuation">:</span> <span class="token string">'kotlin-kapt'</span> <span class="token comment" spellcheck="true">// ensure kapt plugin is applied</span>dependencies <span class="token punctuation">{</span>    <span class="token keyword">def</span> eventbus_version <span class="token operator">=</span> <span class="token string">'3.2.0'</span>    implementation <span class="token string">"org.greenrobot:eventbus:$eventbus_version"</span>    kapt <span class="token string">"org.greenrobot:eventbus-annotation-processor:$eventbus_version"</span><span class="token punctuation">}</span>kapt <span class="token punctuation">{</span>    arguments <span class="token punctuation">{</span>        <span class="token function">arg</span><span class="token punctuation">(</span><span class="token string">'eventBusIndex'</span><span class="token punctuation">,</span> <span class="token string">'com.example.myapp.MyEventBusIndex'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="使用订阅者索引类"><a href="#使用订阅者索引类" class="headerlink" title="使用订阅者索引类"></a>使用订阅者索引类</h4><p>在您的<em>Application</em>类中，使用<em>EventBus.builder().addIndex(indexInstance)</em>将索引类的实例传递给 EventBus。组件中的索引类也可以通过addIndex方法添加到 EventBus 实例中。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//创建一个新实例并配置索引类</span><span class="token keyword">val</span> eventBus <span class="token operator">=</span> EventBus<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addIndex</span><span class="token punctuation">(</span><span class="token function">MyEventBusIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//使用单例模式并配置索引类</span>EventBus<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addIndex</span><span class="token punctuation">(</span><span class="token function">MyEventBusIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">installDefaultEventBus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Now the default instance uses the given index. Use it like this:</span><span class="token keyword">val</span> eventBus <span class="token operator">=</span> EventBus<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="防止混淆订阅者"><a href="#防止混淆订阅者" class="headerlink" title="防止混淆订阅者"></a>防止混淆订阅者</h4><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>keepattributes <span class="token operator">*</span>Annotation<span class="token operator">*</span><span class="token operator">-</span>keepclassmembers <span class="token keyword">class</span> <span class="token operator">*</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@org</span><span class="token punctuation">.</span>greenrobot<span class="token punctuation">.</span>eventbus<span class="token punctuation">.</span>Subscribe <span class="token operator">&lt;</span>methods<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">-</span>keep <span class="token keyword">enum</span> org<span class="token punctuation">.</span>greenrobot<span class="token punctuation">.</span>eventbus<span class="token punctuation">.</span>ThreadMode <span class="token punctuation">{</span> <span class="token operator">*</span><span class="token punctuation">;</span> <span class="token punctuation">}</span># And <span class="token keyword">if</span> you use AsyncExecutor<span class="token operator">:</span><span class="token operator">-</span>keepclassmembers <span class="token keyword">class</span> <span class="token operator">*</span> <span class="token keyword">extends</span> <span class="token class-name">org<span class="token punctuation">.</span>greenrobot<span class="token punctuation">.</span>eventbus<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ThrowableFailureEvent</span> <span class="token punctuation">{</span>    <span class="token operator">&lt;</span>init<span class="token operator">></span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Throwable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="9-2-配置EventBus"><a href="#9-2-配置EventBus" class="headerlink" title="9.2 配置EventBus"></a>9.2 配置EventBus</h3><p>EventBusBuilder 类可以配置 EventBus 的各个方面。例如</p><p>使用 EventBus.getDefault() 是一种从应用程序中的任何位置获取共享 EventBus 实例的简单方法。EventBusBuilder 还允许使用installDefaultEventBus ( )方法配置此默认实例。可以在 Application 类中在使用 EventBus 之前配置默认 EventBus 实例。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> App <span class="token operator">:</span> <span class="token function">Application</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        EventBus<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//将此与 BuildConfig.DEBUG 一起使用可让应用程序尽在在 DEBUG 模式下崩溃。默认为false</span>            <span class="token comment" spellcheck="true">// 这样就不会在开发过程中错过异常（Invoking subscriber failed）</span>            <span class="token punctuation">.</span><span class="token function">throwSubscriberException</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//如果发送了没有订阅者的event,是否需要打印提示哪一个 event bean 的log,默认为true</span>            <span class="token comment" spellcheck="true">//提示信息： No subscribers registered for event class org.greenrobot.eventbusperf.jay.bus.SubEvent</span>            <span class="token punctuation">.</span><span class="token function">logNoSubscriberMessages</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">installDefaultEventBus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="9-3-ThreadMode"><a href="#9-3-ThreadMode" class="headerlink" title="9.3 ThreadMode"></a>9.3 ThreadMode</h3><p>在 EventBus 中，您可以使用四种 ThreadMode 来指定订阅者方法所在的线程。</p><ul><li><a href="https://greenrobot.org/eventbus/documentation/delivery-threads-threadmode/#ThreadMode_POSTING" target="_blank" rel="noopener">1 ThreadMode: POSTING</a> ：发布者和订阅者在同一个线程。<ul><li>这是默认设置。事件传递是同步完成的，需要注意避免阻塞主线程。</li><li>避免了线程切换意味着开销较小。</li></ul></li><li><a href="https://greenrobot.org/eventbus/documentation/delivery-threads-threadmode/#ThreadMode_MAIN" target="_blank" rel="noopener">2 ThreadMode: MAIN</a> ：订阅者将在 Android 的主线程（UI 线程）中调用。<ul><li>事件传递是同步完成的，需要注意避免阻塞主线程。</li></ul></li><li><a href="https://greenrobot.org/eventbus/documentation/delivery-threads-threadmode/#ThreadMode_MAIN_ORDERED" target="_blank" rel="noopener">3 ThreadMode: MAIN_ORDERED</a> ：订阅者将在 Android 的主线程中被调用，该事件总是通过Handler排队等待稍后传递给订阅者。<ul><li>为事件处理提供了更严格和更一致的顺序。</li><li>如果前一个也是main_ordered 需要等前一个执行完成后才执行。</li><li>事件传递是异步完成的。</li></ul></li><li><a href="https://greenrobot.org/eventbus/documentation/delivery-threads-threadmode/#ThreadMode_BACKGROUND" target="_blank" rel="noopener">4 ThreadMode: BACKGROUND</a> ：如果发帖线程非主线程则订阅者的处理会在工作线程中执行否则和发布者同一个线程处理。<ul><li>事件传递是异步完成的。</li></ul></li><li><a href="https://greenrobot.org/eventbus/documentation/delivery-threads-threadmode/#ThreadMode_ASYNC" target="_blank" rel="noopener">5 ThreadMode: ASYNC</a> ：无论事件在哪个线程发布，订阅者都会在新建的工作线程中执行。<ul><li>EventBus 使用线程池来有效地重用线程。</li><li>事件传递是异步完成的。</li><li>如果事件处理程序方法的执行可能需要一些时间，则应使用此模式，例如用于网络访问</li></ul></li></ul><pre class=" language-kotlin"><code class="language-kotlin"> <span class="token comment" spellcheck="true">//在主线程发消息</span> 发布者所在线程<span class="token operator">:</span>Thread<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> 订阅者所在线程<span class="token operator">:</span> Thread<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> 订阅者线程模式<span class="token operator">:</span> BACKGROUND  发布者所在线程<span class="token operator">:</span>Thread<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> 订阅者所在线程<span class="token operator">:</span> pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> 订阅者线程模式<span class="token operator">:</span> ASYNC  发布者所在线程<span class="token operator">:</span>Thread<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> 订阅者所在线程<span class="token operator">:</span> Thread<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> 订阅者线程模式<span class="token operator">:</span> POSTING  发布者所在线程<span class="token operator">:</span>Thread<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> 订阅者所在线程<span class="token operator">:</span> main<span class="token punctuation">,</span> 订阅者线程模式<span class="token operator">:</span> MAIN  发布者所在线程<span class="token operator">:</span>Thread<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> 订阅者所在线程<span class="token operator">:</span> main<span class="token punctuation">,</span> 订阅者线程模式<span class="token operator">:</span> MAIN_ORDERED  <span class="token comment" spellcheck="true">//在子线程发消息</span> 发布者所在线程<span class="token operator">:</span>main<span class="token punctuation">,</span> 订阅者所在线程<span class="token operator">:</span> main<span class="token punctuation">,</span> 订阅者线程模式<span class="token operator">:</span> MAIN  发布者所在线程<span class="token operator">:</span>main<span class="token punctuation">,</span> 订阅者所在线程<span class="token operator">:</span> pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> 订阅者线程模式<span class="token operator">:</span> BACKGROUND  发布者所在线程<span class="token operator">:</span>main<span class="token punctuation">,</span> 订阅者所在线程<span class="token operator">:</span> pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> 订阅者线程模式<span class="token operator">:</span> ASYNC  发布者所在线程<span class="token operator">:</span>main<span class="token punctuation">,</span> 订阅者所在线程<span class="token operator">:</span> main<span class="token punctuation">,</span> 订阅者线程模式<span class="token operator">:</span> POSTING  发布者所在线程<span class="token operator">:</span>main<span class="token punctuation">,</span> 订阅者所在线程<span class="token operator">:</span> main<span class="token punctuation">,</span> 订阅者线程模式<span class="token operator">:</span> MAIN_ORDERED </code></pre><h3 id="9-4-订阅者优先级"><a href="#9-4-订阅者优先级" class="headerlink" title="9.4 订阅者优先级"></a>9.4 订阅者优先级</h3><p>订阅者优先级影响事件传递的顺序。 在同一个交付线程 ( ThreadMode ) 中，较高优先级的订阅者将在其他具有较低优先级的订阅者之前收到事件。 默认优先级为 0。注意：优先级不影响具有不同ThreadMode的订阅者之间的传递顺序！</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Subscribe</span><span class="token punctuation">(</span>threadMode <span class="token operator">=</span> ThreadMode<span class="token punctuation">.</span>POSTING<span class="token punctuation">,</span> priority <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">onMessageEvent_POSTING1</span><span class="token punctuation">(</span>event<span class="token operator">:</span> MessageEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">showMsg</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> <span class="token string">"POSTING1"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token annotation builtin">@Subscribe</span><span class="token punctuation">(</span>threadMode <span class="token operator">=</span> ThreadMode<span class="token punctuation">.</span>POSTING<span class="token punctuation">,</span> priority <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">onMessageEvent_POSTING2</span><span class="token punctuation">(</span>event<span class="token operator">:</span> MessageEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">showMsg</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> <span class="token string">"POSTING2"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token annotation builtin">@Subscribe</span><span class="token punctuation">(</span>threadMode <span class="token operator">=</span> ThreadMode<span class="token punctuation">.</span>MAIN<span class="token punctuation">,</span> priority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">onMessageEvent_MAIN1</span><span class="token punctuation">(</span>event<span class="token operator">:</span> MessageEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">showMsg</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> <span class="token string">"MAIN1"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token annotation builtin">@Subscribe</span><span class="token punctuation">(</span>threadMode <span class="token operator">=</span> ThreadMode<span class="token punctuation">.</span>MAIN<span class="token punctuation">,</span> priority <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">onMessageEvent_MAIN2</span><span class="token punctuation">(</span>event<span class="token operator">:</span> MessageEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">showMsg</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> <span class="token string">"MAIN2"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//打印结果</span> 发布者所在线程<span class="token operator">:</span>main<span class="token punctuation">,</span> 订阅者所在线程<span class="token operator">:</span> main<span class="token punctuation">,</span> 订阅者线程模式<span class="token operator">:</span> POSTING2  发布者所在线程<span class="token operator">:</span>main<span class="token punctuation">,</span> 订阅者所在线程<span class="token operator">:</span> main<span class="token punctuation">,</span> 订阅者线程模式<span class="token operator">:</span> MAIN2  发布者所在线程<span class="token operator">:</span>main<span class="token punctuation">,</span> 订阅者所在线程<span class="token operator">:</span> main<span class="token punctuation">,</span> 订阅者线程模式<span class="token operator">:</span> POSTING1  发布者所在线程<span class="token operator">:</span>main<span class="token punctuation">,</span> 订阅者所在线程<span class="token operator">:</span> main<span class="token punctuation">,</span> 订阅者线程模式<span class="token operator">:</span> MAIN1 </code></pre><p><strong>取消事件传递</strong></p><p>您可以通过从订阅者的事件处理方法调用cancelEventDelivery ( Object event ) 来取消事件传递过程。任何进一步的事件传递都将被取消，后续订阅者将不会收到该事件。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Prevent delivery to other subscribers*</span>EventBus<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cancelEventDelivery</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre><p>事件通常由更高优先级的订阅者取消。取消仅限于在发布线程 ( ThreadMode . PostThread ) 中运行的事件处理方法。</p><h3 id="9-5-粘性事件"><a href="#9-5-粘性事件" class="headerlink" title="9.5 粘性事件"></a>9.5 粘性事件</h3><p>普通事件都是需要先注册(register)，再post才能接受到事件；如果你使用 postSticky 发送事件，那么可以不需要先注册，也能接受到事件，也就是一个延迟注册的过程。 </p><p>普通的事件我们通过post发送给EventBus，发送过后之后当前已经订阅过的方法可以收到。但是如果有些事件需要所有订阅了该事件的方法都能执行呢？例如一个Activity，要求它管理的所有Fragment都能执行某一个事件，但是当前我只初始化了3个Fragment，如果这时候通过post发送了事件，那么当前的3个Fragment当然能收到。但是这个时候又初始化了2个Fragment，那么我必须重新发送事件，这两个Fragment才能执行到订阅方法。 </p><p>粘性事件就是为了解决这个问题，通过 postSticky 发送粘性事件，这个事件不会只被消费一次就消失，而是一直存在系统中，直到被 removeStickyEvent 删除掉。那么只要订阅了该粘性事件的所有方法，只要被register 的时候就会被检测到并且执行。订阅的方法需要添加 sticky = true 属性。</p><pre class=" language-kotlin"><code class="language-kotlin">EventBus<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">postSticky</span><span class="token punctuation">(</span><span class="token function">MessageEvent</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//消费粘性事件方式一：</span><span class="token keyword">val</span> stickyEvent <span class="token operator">=</span> EventBus<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStickyEvent</span><span class="token punctuation">(</span>MessageEvent<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 最好检查之前是否实际发布过事件</span><span class="token keyword">if</span> <span class="token punctuation">(</span>stickyEvent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 消费掉粘性事件</span>    EventBus<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeStickyEvent</span><span class="token punctuation">(</span>stickyEvent<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//消费粘性事件方式二：</span><span class="token keyword">val</span> stickyEvent2 <span class="token operator">=</span> EventBus<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeStickyEvent</span><span class="token punctuation">(</span>MessageEvent<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 最好检查之前是否实际发布过事件</span><span class="token keyword">if</span> <span class="token punctuation">(</span>stickyEvent2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//已经消费了</span><span class="token punctuation">}</span><span class="token annotation builtin">@Subscribe</span><span class="token punctuation">(</span>threadMode <span class="token operator">=</span> ThreadMode<span class="token punctuation">.</span>MAIN<span class="token punctuation">,</span> sticky <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">onMessageEvent_sticky</span><span class="token punctuation">(</span>event<span class="token operator">:</span> MessageEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">showMsg</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> <span class="token string">"MAIN"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//消费粘性事件方式三：</span>    EventBus<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeStickyEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="9-6-异步执行器"><a href="#9-6-异步执行器" class="headerlink" title="9.6 异步执行器"></a>9.6 异步执行器</h3><p>AsyncExecutor 就像一个线程池，但具有失败（异常）处理功能。失败会引发异常，AsyncExecutor 会将这些异常包装在一个事件中，该事件会自动发布。</p><p> <em>AsyncExecutor 是一个非核心实用程序类。它可能会为您节省一些在后台线程中进行错误处理的代码，但它不是核心 EventBus 类。</em></p><p>调用 AsyncExecutor.create() 来创建一个实例并将其保存在应用程序范围内。然后要执行某些操作，请实现 RunnableEx接口并将其传递给AsyncExecutor的execute方法。与Runnable不同，RunnableEx可能抛出异常。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//AsyncExecutor类似于线程池，但具有失败(异常)处理。失败是抛出异常，AsyncExecutor将把这些异常封装在一个事件中，该事件将自动发布。</span>AsyncExecutor<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span> <span class="token punctuation">{</span>    EventBus<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">postSticky</span><span class="token punctuation">(</span>SubEvent<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//线程池中发出的时间</span><span class="token annotation builtin">@Subscribe</span><span class="token punctuation">(</span>threadMode <span class="token operator">=</span> ThreadMode<span class="token punctuation">.</span>MAIN<span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">handleLoginEvent</span><span class="token punctuation">(</span>event<span class="token operator">:</span> SubEvent<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// do something</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//线程池中任务异常时发出的时间</span><span class="token annotation builtin">@Subscribe</span><span class="token punctuation">(</span>threadMode <span class="token operator">=</span> ThreadMode<span class="token punctuation">.</span>MAIN<span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">handleFailureEvent</span><span class="token punctuation">(</span>event<span class="token operator">:</span> ThrowableFailureEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// do something</span><span class="token punctuation">}</span></code></pre><h2 id="10-EventBus-原理"><a href="#10-EventBus-原理" class="headerlink" title="10 EventBus 原理"></a>10 EventBus 原理</h2><p>了解框架之前我们先定义几个核心角色用于描述整个流程</p><ul><li><p>发布者类：调用 post/postSticky 发布事件的类</p></li><li><p>发布者方法：调用 post/postSticky 发布事件的方法</p></li><li><p>事件类： post/postSticky 方法参数类以及订阅者方法参数类型</p></li><li><p>订阅者类：订阅者方法所在的类</p></li><li><p>订阅者方法：通过注解标注的订阅者方法</p></li></ul><p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20211111000627.png" alt="image-20211111000620374"></p><h3 id="10-1-编译时部分-通过-APT-收集订阅者注解并生成索引类"><a href="#10-1-编译时部分-通过-APT-收集订阅者注解并生成索引类" class="headerlink" title="10.1 编译时部分-通过 APT 收集订阅者注解并生成索引类"></a>10.1 编译时部分-通过 APT 收集订阅者注解并生成索引类</h3><p>注解类 Subscribe 用于标注订阅者方法</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Subscribe</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//用来指定指定订阅者方法所在的线程。</span>    ThreadMode <span class="token function">threadMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> ThreadMode<span class="token punctuation">.</span>POSTING<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果为 true，则将最近的粘性事件（通过EventBus.postSticky(Object) ）传递给该订阅者。</span>    <span class="token keyword">boolean</span> <span class="token function">sticky</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//订阅者优先级影响事件传递的顺序。</span>    <span class="token comment" spellcheck="true">// 在同一个交付线程 ( ThreadMode ) 中，较高优先级的订阅者将在其他具有较低优先级的订阅者之前收到事件。 默认优先级为 0。</span>    <span class="token comment" spellcheck="true">// 注意：优先级不会影响具有不同ThreadMode的订阅者之间的传递顺序！</span>    <span class="token keyword">int</span> <span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>收集那些代码元素：订阅者类&amp;订阅者方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">BusTestActivity</span> <span class="token operator">:</span> <span class="token function">Activity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//定义一个订阅者方法</span>    <span class="token annotation punctuation">@Subscribe</span><span class="token punctuation">(</span>sticky <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> threadMode <span class="token operator">=</span> ThreadMode<span class="token punctuation">.</span>POSTING<span class="token punctuation">,</span> priority <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span>    fun <span class="token function">onMessageEvent_POSTING1</span><span class="token punctuation">(</span>event<span class="token operator">:</span> MessageEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">showMsg</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> <span class="token string">"POSTING1"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>注解处理器通过继承 Java AbstractProcessor 抽象类并配置注解和选项参数实现</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SupportedAnnotationTypes</span><span class="token punctuation">(</span><span class="token string">"org.greenrobot.eventbus.Subscribe"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SupportedOptions</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"eventBusIndex"</span><span class="token punctuation">,</span> <span class="token string">"verbose"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@IncrementalAnnotationProcessor</span><span class="token punctuation">(</span>AGGREGATING<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EventBusAnnotationProcessor</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProcessor</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><ul><li>通过处理器参数获取配置的订阅者索引全类名，没有配置该参数但是却依赖了注解处理组件会抛异常</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//设置apt参数</span>javaCompileOptions <span class="token punctuation">{</span>    annotationProcessorOptions <span class="token punctuation">{</span>        arguments <span class="token operator">=</span> <span class="token punctuation">[</span>                eventBusIndex<span class="token operator">:</span> <span class="token string">'org.greenrobot.eventbusperf.MyEventBusIndex'</span><span class="token punctuation">,</span>                verbose<span class="token operator">:</span> <span class="token string">'true'</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//获取apt参数</span>String index <span class="token operator">=</span> processingEnv<span class="token punctuation">.</span><span class="token function">getOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>OPTION_EVENT_BUS_INDEX<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    messager<span class="token punctuation">.</span><span class="token function">printMessage</span><span class="token punctuation">(</span>Diagnostic<span class="token punctuation">.</span>Kind<span class="token punctuation">.</span>ERROR<span class="token punctuation">,</span> <span class="token string">"No option "</span> <span class="token operator">+</span> OPTION_EVENT_BUS_INDEX <span class="token operator">+</span>            <span class="token string">" passed to annotation processor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//没有配置的错误信息</span><span class="token operator">></span> Task <span class="token operator">:</span>EventBusPerformance<span class="token operator">:</span>compileDebugJavaWithJavac FAILED错误<span class="token operator">:</span> No option eventBusIndex passed to annotation processor</code></pre><ul><li>收集注解流程</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">collectSubscribers</span><span class="token punctuation">(</span>Set<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">TypeElement</span><span class="token operator">></span> annotations<span class="token punctuation">,</span> RoundEnvironment env<span class="token punctuation">,</span> Messager messager<span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>TypeElement annotation <span class="token operator">:</span> annotations<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取目标注解标注的所有元素，这里是所有的订阅者方法</span>        Set<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Element</span><span class="token operator">></span> elements <span class="token operator">=</span> env<span class="token punctuation">.</span><span class="token function">getElementsAnnotatedWith</span><span class="token punctuation">(</span>annotation<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Element element <span class="token operator">:</span> elements<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//ExecutableElement 可执行元素指的是方法类型</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>element <span class="token keyword">instanceof</span> <span class="token class-name">ExecutableElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ExecutableElement method <span class="token operator">=</span> <span class="token punctuation">(</span>ExecutableElement<span class="token punctuation">)</span> element<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//检查方法:正好只有一个参数的非静态的公开的方法</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkHasNoErrors</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> messager<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//获取方法所在的类元素</span>                    TypeElement classElement <span class="token operator">=</span> <span class="token punctuation">(</span>TypeElement<span class="token punctuation">)</span> method<span class="token punctuation">.</span><span class="token function">getEnclosingElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//存入容器</span>                    methodsByClass<span class="token punctuation">.</span><span class="token function">putElement</span><span class="token punctuation">(</span>classElement<span class="token punctuation">,</span> method<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                messager<span class="token punctuation">.</span><span class="token function">printMessage</span><span class="token punctuation">(</span>Diagnostic<span class="token punctuation">.</span>Kind<span class="token punctuation">.</span>ERROR<span class="token punctuation">,</span> <span class="token string">"@Subscribe is only valid for methods"</span><span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>校验某个类对索引类包是否可访问</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isVisible</span><span class="token punctuation">(</span>String myPackage<span class="token punctuation">,</span> TypeElement typeElement<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//类的修饰符</span>    Set<span class="token operator">&lt;</span>Modifier<span class="token operator">></span> modifiers <span class="token operator">=</span> typeElement<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> visible<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>Modifier<span class="token punctuation">.</span>PUBLIC<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        visible <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>Modifier<span class="token punctuation">.</span>PRIVATE<span class="token punctuation">)</span> <span class="token operator">||</span> modifiers<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>Modifier<span class="token punctuation">.</span>PROTECTED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        visible <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//类所在的包</span>        String subscriberPackage <span class="token operator">=</span> <span class="token function">getPackageElement</span><span class="token punctuation">(</span>typeElement<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQualifiedName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//处理器参数没有指定索引类</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>myPackage <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//todo 没有包名什么情况</span>            visible <span class="token operator">=</span> subscriberPackage<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//索引类和观察者包名一样</span>            visible <span class="token operator">=</span> myPackage<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>subscriberPackage<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> visible<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>校验收集到的注解元素信息是否符合预期</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">checkForSubscribersToSkip</span><span class="token punctuation">(</span>Messager messager<span class="token punctuation">,</span> String myPackage<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//遍历所有订阅者方法所在的类</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>TypeElement skipCandidate <span class="token operator">:</span> methodsByClass<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//方法所在的类，</span>        TypeElement subscriberClass <span class="token operator">=</span> skipCandidate<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//循环获取父类</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>subscriberClass <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//所有观察者</span>            <span class="token comment" spellcheck="true">//校验某个类类对索引类包是否可访问</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isVisible</span><span class="token punctuation">(</span>myPackage<span class="token punctuation">,</span> subscriberClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//索引类访问不到观察者类，跳过</span>                <span class="token keyword">boolean</span> added <span class="token operator">=</span> classesToSkip<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>skipCandidate<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>added<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//存在不可访问观察者</span>                    String msg<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//由于类不是公开的，所以回退到反射</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>subscriberClass<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>skipCandidate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//没有继承关系存在</span>                        msg <span class="token operator">=</span> <span class="token string">"Falling back to reflection because class is not public"</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//父类</span>                        msg <span class="token operator">=</span> <span class="token string">"Falling back to reflection because "</span> <span class="token operator">+</span> skipCandidate <span class="token operator">+</span>                                <span class="token string">" has a non-public super class"</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    messager<span class="token punctuation">.</span><span class="token function">printMessage</span><span class="token punctuation">(</span>Diagnostic<span class="token punctuation">.</span>Kind<span class="token punctuation">.</span>NOTE<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> subscriberClass<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//观察者类中的所有观察方法</span>            List<span class="token operator">&lt;</span>ExecutableElement<span class="token operator">></span> methods <span class="token operator">=</span> methodsByClass<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>subscriberClass<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>methods <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>ExecutableElement method <span class="token operator">:</span> methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    String skipReason <span class="token operator">=</span> null<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//方法第一个参数</span>                    VariableElement param <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//参数类型</span>                    TypeMirror typeMirror <span class="token operator">=</span> <span class="token function">getParamTypeMirror</span><span class="token punctuation">(</span>param<span class="token punctuation">,</span> messager<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//不是类类型报错</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>typeMirror <span class="token keyword">instanceof</span> <span class="token class-name">DeclaredType</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>DeclaredType<span class="token punctuation">)</span> typeMirror<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">TypeElement</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        skipReason <span class="token operator">=</span> <span class="token string">"event type cannot be processed"</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">//是类类型但是对索引类不可见</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>skipReason <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        TypeElement eventTypeElement <span class="token operator">=</span> <span class="token punctuation">(</span>TypeElement<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>DeclaredType<span class="token punctuation">)</span> typeMirror<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//参数类对索引类不可见</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isVisible</span><span class="token punctuation">(</span>myPackage<span class="token punctuation">,</span> eventTypeElement<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            skipReason <span class="token operator">=</span> <span class="token string">"event type is not public"</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">//存在观察者方法但是不可见先存下来，用于过滤</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>skipReason <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">boolean</span> added <span class="token operator">=</span> classesToSkip<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>skipCandidate<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>added<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            String msg <span class="token operator">=</span> <span class="token string">"Falling back to reflection because "</span> <span class="token operator">+</span> skipReason<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>subscriberClass<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>skipCandidate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                msg <span class="token operator">+=</span> <span class="token string">" (found in super class for "</span> <span class="token operator">+</span> skipCandidate <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            messager<span class="token punctuation">.</span><span class="token function">printMessage</span><span class="token punctuation">(</span>Diagnostic<span class="token punctuation">.</span>Kind<span class="token punctuation">.</span>NOTE<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//获取观察者类的父类，继续循环</span>            subscriberClass <span class="token operator">=</span> <span class="token function">getSuperclass</span><span class="token punctuation">(</span>subscriberClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>将收集到的索引信息写入索引类中的 map 容器中</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeIndexLines</span><span class="token punctuation">(</span>BufferedWriter writer<span class="token punctuation">,</span> String myPackage<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>TypeElement subscriberTypeElement <span class="token operator">:</span> methodsByClass<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//只生成可访问的</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>classesToSkip<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>subscriberTypeElement<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String subscriberClass <span class="token operator">=</span> <span class="token function">getClassString</span><span class="token punctuation">(</span>subscriberTypeElement<span class="token punctuation">,</span> myPackage<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isVisible</span><span class="token punctuation">(</span>myPackage<span class="token punctuation">,</span> subscriberTypeElement<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">writeLine</span><span class="token punctuation">(</span>writer<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span>                    <span class="token string">"putIndex(new SimpleSubscriberInfo("</span> <span class="token operator">+</span> subscriberClass <span class="token operator">+</span> <span class="token string">".class,"</span><span class="token punctuation">,</span>                    <span class="token string">"true,"</span><span class="token punctuation">,</span> <span class="token string">"new SubscriberMethodInfo[] {"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>ExecutableElement<span class="token operator">></span> methods <span class="token operator">=</span> methodsByClass<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>subscriberTypeElement<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">writeCreateSubscriberMethods</span><span class="token punctuation">(</span>writer<span class="token punctuation">,</span> methods<span class="token punctuation">,</span> <span class="token string">"new SubscriberMethodInfo"</span><span class="token punctuation">,</span> myPackage<span class="token punctuation">)</span><span class="token punctuation">;</span>            writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"        }));\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"        // Subscriber not visible to index: "</span> <span class="token operator">+</span> subscriberClass <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>生成的 MyEventBusIndex 文件</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//通过注释处理创建的生成索引类的接口。</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SubscriberInfo</span> <span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getSubscriberClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SubscriberMethod<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getSubscriberMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SubscriberInfo <span class="token function">getSuperSubscriberInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">shouldCheckSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyEventBusIndex</span> <span class="token keyword">implements</span> <span class="token class-name">SubscriberInfoIndex</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">,</span> SubscriberInfo<span class="token operator">></span> SUBSCRIBER_INDEX<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        SUBSCRIBER_INDEX <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">,</span> SubscriberInfo<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">putIndex</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleSubscriberInfo</span><span class="token punctuation">(</span>org<span class="token punctuation">.</span>greenrobot<span class="token punctuation">.</span>eventbusperf<span class="token punctuation">.</span>testsubject<span class="token punctuation">.</span>PerfTestEventBus<span class="token punctuation">.</span>SubscriberClassEventBusAsync<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SubscriberMethodInfo</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">SubscriberMethodInfo</span><span class="token punctuation">(</span><span class="token string">"onEventAsync"</span><span class="token punctuation">,</span> TestEvent<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> ThreadMode<span class="token punctuation">.</span>ASYNC<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//其它索引信息......</span>      <span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">putIndex</span><span class="token punctuation">(</span>SubscriberInfo info<span class="token punctuation">)</span> <span class="token punctuation">{</span>    SUBSCRIBER_INDEX<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span><span class="token function">getSubscriberClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> SubscriberInfo <span class="token function">getSubscriberInfo</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> subscriberClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>    SubscriberInfo info <span class="token operator">=</span> SUBSCRIBER_INDEX<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>subscriberClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>info <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> info<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="编译时APT流程总结"><a href="#编译时APT流程总结" class="headerlink" title="编译时APT流程总结"></a>编译时APT流程总结</h4><p>EventBus 中订阅者的收集是通过两种方式，一种是运行时反射收集，另一种是通过注解处理器收集。通过apt收集相比通过运行时反射的方式可以减少因为反射带来的性能开销，但是会影响编译时的时间。综合考量必然还是推荐通过APT方式。</p><p>通过APT方式收集订阅者的大体流程如下：</p><ul><li>在编码阶段添加订阅者方法时我们需要通过 <strong>@Subscribe</strong> 注解类标注订阅者，该注解类提供三个参数用来个性化配置订阅者，三个参数分别是：<strong>enum ThreadMode、boolean sticky，int priority</strong> 。注解处理器所做的工作就是收集订阅者方法以及这些方法所在的类信息。</li><li>EventBus 规定生成的索引类的全类名是由开发者自行定义传入的，所以在编译之前还模块的 build.gradle 中需要配置索引类，否则会编译错误。</li><li>注解处理器注解处理流程主要分为：<strong>收集订阅者、校验订阅者、生成索引类</strong>三个过程。<ul><li>收集订阅者：遍历所有可执行元素 ExecutableElement，校验订阅者方法签名，订阅者方法签名需要满足 <strong>正好只有一个参数的非静态的公开的方法</strong> 的规则。然后将找到的订阅者方法和订阅者类存入 *<em>ListMap&lt;TypeElement, ExecutableElement&gt; methodsByClass *</em>  容器中。该容器的数据结构是：<code>HashMap&lt;K, List&lt;V&gt;&gt;()</code> key 存入的是订阅者类，value 是该类中所有订阅者方法的集合。</li><li>校验订阅者（包括订阅者类/订阅者类的父类和订阅者方法）：<ul><li>校验订阅者类：遍历所有上一步收集到的订阅者类，校验订阅者类，订阅者类需要满足<strong>public/default+索引类和订阅者类的包名一样</strong> 的规则，不满足的订阅者类需要添加到 <strong>Set<typeelement> classesToSkip</typeelement></strong> 容器中标记。</li><li>校验订阅者类中的方法：满足上一步的订阅者类中任何一个订阅者方法满足以下情况的直接将对应的订阅者类需要添加到 <strong>Set<typeelement> classesToSkip</typeelement></strong> 容器中标记。<ul><li>订阅者方法的参数类型(也就是Event 类型)不是 DeclaredType 或者是 DeclaredType 但不是 TypeElement。</li><li>订阅者方法的参数类型是类类型但是对索引类不可见。</li></ul></li></ul></li><li>生成索引类：遍历最终收集到的 <strong>methodsByClass</strong> 订阅者信息通过字符串拼接的方式生成索引类。这里换成Javapoet的方式更容易维护，EventBus 可能是为了节省框架包的体积没有采用Javapoet的方式生成java文件。</li></ul></li></ul><h3 id="10-2-运行时部分-初始化、注册-查找订阅者等"><a href="#10-2-运行时部分-初始化、注册-查找订阅者等" class="headerlink" title="10.2 运行时部分-初始化、注册/查找订阅者等"></a>10.2 运行时部分-初始化、注册/查找订阅者等</h3><h4 id="10-2-1-初始化EventBus"><a href="#10-2-1-初始化EventBus" class="headerlink" title="10.2.1 初始化EventBus"></a>10.2.1 初始化EventBus</h4><p>构建 EventBus 实例的三种方式：</p><ul><li><p>EventBus.getDefault() + 默认Builder</p></li><li><p>EventBus.builder().installDefaultEventBus() + 自定义配置</p></li><li><p>EventBus.builder().build() + 自定义配置</p></li></ul><p>方式一：DCL单例方式创建进程唯一实例</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">volatile</span> EventBus defaultInstance<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用进程范围的 EventBus 实例的应用程序的便捷单例。</span><span class="token keyword">public</span> <span class="token keyword">static</span> EventBus <span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//通过局部变量中转可节省性能</span>    EventBus instance <span class="token operator">=</span> defaultInstance<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>EventBus<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> EventBus<span class="token punctuation">.</span>defaultInstance<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                instance <span class="token operator">=</span> EventBus<span class="token punctuation">.</span>defaultInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventBus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> instance<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其它两种方式</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//EventBus.builder().build() + 自定义配置</span>EventBus<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">throwSubscriberException</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">logNoSubscriberMessages</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//添加索引类，减少运行时反射</span>    <span class="token punctuation">.</span><span class="token function">addIndex</span><span class="token punctuation">(</span><span class="token function">MyEventBusIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> EventBus <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">EventBus</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//EventBus.builder().installDefaultEventBus() + 自定义配置</span>EventBus<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">throwSubscriberException</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">logNoSubscriberMessages</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//添加索引类，减少运行时反射</span>    <span class="token punctuation">.</span><span class="token function">addIndex</span><span class="token punctuation">(</span><span class="token function">MyEventBusIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">installDefaultEventBus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> EventBus <span class="token function">installDefaultEventBus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>EventBus<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>EventBus<span class="token punctuation">.</span>defaultInstance <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EventBusException</span><span class="token punctuation">(</span><span class="token string">"Default instance already exists."</span> <span class="token operator">+</span>                    <span class="token string">" It may be only set once before it's used the first time to ensure consistent behavior."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        EventBus<span class="token punctuation">.</span>defaultInstance <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> EventBus<span class="token punctuation">.</span>defaultInstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>构建EventBus时的默认配置</strong></p><pre class=" language-java"><code class="language-java"><span class="token function">EventBus</span><span class="token punctuation">(</span>EventBusBuilder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>    logger <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过事件类找所有该事件的订阅者，</span>    subscriptionsByEventType <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过订阅者类找所有Event</span>    typesBySubscriber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过粘性事件类查找所有粘性事件对象</span>    stickyEvents <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构建 AndroidHandlerMainThreadSupport</span>    mainThreadSupport <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">getMainThreadSupport</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构建 HandlerPoster</span>    mainThreadPoster <span class="token operator">=</span> mainThreadSupport <span class="token operator">!=</span> null <span class="token operator">?</span> mainThreadSupport<span class="token punctuation">.</span><span class="token function">createPoster</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在后台发布事件</span>    backgroundPoster <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BackgroundPoster</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在后台发布事件</span>    asyncPoster <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AsyncPoster</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    indexCount <span class="token operator">=</span> builder<span class="token punctuation">.</span>subscriberInfoIndexes <span class="token operator">!=</span> null <span class="token operator">?</span> builder<span class="token punctuation">.</span>subscriberInfoIndexes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过反射或APT查找订阅者</span>    subscriberMethodFinder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubscriberMethodFinder</span><span class="token punctuation">(</span>            <span class="token comment" spellcheck="true">//添加由 EventBus 的注释预处理器生成的索引。默认空集合</span>            builder<span class="token punctuation">.</span>subscriberInfoIndexes<span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">//启用严格的方法验证（默认值：false）</span>            builder<span class="token punctuation">.</span>strictMethodVerification<span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">//即使有生成的索引也强制使用反射（默认值：false）</span>            builder<span class="token punctuation">.</span>ignoreGeneratedIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//无法分发事件时是否打印错误信息</span>    logSubscriberExceptions <span class="token operator">=</span> builder<span class="token punctuation">.</span>logSubscriberExceptions<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//没有订阅者注册事件是否打印错误信息</span>    logNoSubscriberMessages <span class="token operator">=</span> builder<span class="token punctuation">.</span>logNoSubscriberMessages<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在调用订阅者时如果发生异常是否 发送一个 SubscriberExceptionEvent 通知订阅者</span>    sendSubscriberExceptionEvent <span class="token operator">=</span> builder<span class="token punctuation">.</span>sendSubscriberExceptionEvent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//没有订阅者注册事件是否是否通知订阅者类的父类</span>    sendNoSubscriberEvent <span class="token operator">=</span> builder<span class="token punctuation">.</span>sendNoSubscriberEvent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在调用订阅者时如果发生异常是否抛出 RuntimeException</span>    throwSubscriberException <span class="token operator">=</span> builder<span class="token punctuation">.</span>throwSubscriberException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//是否通知订阅者类的父类中的订阅者方法</span>    eventInheritance <span class="token operator">=</span> builder<span class="token punctuation">.</span>eventInheritance<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//订阅者执行在工作线程时用到的线程池：Executors.newCachedThreadPool()</span>    executorService <span class="token operator">=</span> builder<span class="token punctuation">.</span>executorService<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="初始化EventBus-总结"><a href="#初始化EventBus-总结" class="headerlink" title="初始化EventBus 总结"></a>初始化EventBus 总结</h5><p>总的来说 EventBus 的初始化流程不是很复杂， EventBus 对象的创建结合了单例模式和构建者模式。</p><p>单例模式常用于构建全局唯一类并提供全局唯一访问点。</p><p>构建者模式常用于构建可以通过设置不同的可选参数，定制化地创建一个复杂对象。</p><p>EventBus 恰好需要全局唯一且配置复杂，此时就可以结合两个设计模式应对不同的构建场景。</p><p>需要全局唯一默认配置的实例直接通过单例获取，需要为前面的单例个性化定制也可以通过构建者模式配置参数。</p><p>你自己维护全局唯一或者需要局部唯一的场景也可以通过构建者模式个性化定制。</p><p>可能是因为 EventBus  的应用场景多样，他的DCL单例模式并没有显示私有构造方法和静态实例变量，也就是说直接 new EventBus 也是可以的。</p><h4 id="10-2-2-注册订阅者：查找订阅者方法"><a href="#10-2-2-注册订阅者：查找订阅者方法" class="headerlink" title="10.2.2 注册订阅者：查找订阅者方法"></a>10.2.2 注册订阅者：查找订阅者方法</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> override fun <span class="token function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    EventBus<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//注册给定的订阅者以接收事件。 订阅者一旦对接收事件不再感兴趣，须调用 unregister(Object) 。</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span>Object subscriber<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> subscriberClass <span class="token operator">=</span> subscriber<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过订阅者类找出该类中所有的订阅者方法</span>    List<span class="token operator">&lt;</span>SubscriberMethod<span class="token operator">></span> subscriberMethods <span class="token operator">=</span> subscriberMethodFinder<span class="token punctuation">.</span><span class="token function">findSubscriberMethods</span><span class="token punctuation">(</span>subscriberClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//01</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>SubscriberMethod subscriberMethod <span class="token operator">:</span> subscriberMethods<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">subscribe</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">,</span> subscriberMethod<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//02</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>01查找订阅者方法流程：通过APT或反射方式查找订阅者方法并内存缓存</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//ConcurrentHashMap 内存缓存保证线程安全</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">,</span> List<span class="token operator">&lt;</span>SubscriberMethod<span class="token operator">>></span> METHOD_CACHE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//通过订阅者类查找订阅者方法</span>List<span class="token operator">&lt;</span>SubscriberMethod<span class="token operator">></span> <span class="token function">findSubscriberMethods</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> subscriberClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//先从内存缓存尝试取，节省查找开销</span>    List<span class="token operator">&lt;</span>SubscriberMethod<span class="token operator">></span> subscriberMethods <span class="token operator">=</span> METHOD_CACHE<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>subscriberClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>subscriberMethods <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> subscriberMethods<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ignoreGeneratedIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//运行时反射查找</span>        subscriberMethods <span class="token operator">=</span> <span class="token function">findUsingReflection</span><span class="token punctuation">(</span>subscriberClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//从APT中收集的备选中查找</span>        subscriberMethods <span class="token operator">=</span> <span class="token function">findUsingInfo</span><span class="token punctuation">(</span>subscriberClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>subscriberMethods<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//订阅者类中至少有一个订阅者方法，否则运行时报错</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EventBusException</span><span class="token punctuation">(</span><span class="token string">"Subscriber "</span> <span class="token operator">+</span> subscriberClass                <span class="token operator">+</span> <span class="token string">" and its super classes have no public methods with the @Subscribe annotation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//找到后缓存到内存</span>        METHOD_CACHE<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>subscriberClass<span class="token punctuation">,</span> subscriberMethods<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> subscriberMethods<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>运行时反射查找</strong> </p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> List<span class="token operator">&lt;</span>SubscriberMethod<span class="token operator">></span> <span class="token function">findUsingReflection</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> subscriberClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//准备一个 FindState 实例，如果对象池中没有就new,一个FindState对应一个订阅者类，用于表示查找状态</span>    FindState findState <span class="token operator">=</span> <span class="token function">prepareFindState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//存入订阅者 class</span>    findState<span class="token punctuation">.</span><span class="token function">initForSubscriber</span><span class="token punctuation">(</span>subscriberClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历subscriberClass的超类体系，调用findUsingReflectionInSingleClass查找当前clazz的所有订阅函数</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>findState<span class="token punctuation">.</span>clazz <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//在订阅者类中通过反射的方式查找订阅者方法</span>        <span class="token function">findUsingReflectionInSingleClass</span><span class="token punctuation">(</span>findState<span class="token punctuation">)</span><span class="token punctuation">;</span>        findState<span class="token punctuation">.</span><span class="token function">moveToSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取父类继续查找</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//循环结束 findState.subscriberMethods 中保存了这个类中的所有订阅者方法</span>    <span class="token keyword">return</span> <span class="token function">getMethodsAndRelease</span><span class="token punctuation">(</span>findState<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在订阅者类中通过反射的方式查找订阅者方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">findUsingReflectionInSingleClass</span><span class="token punctuation">(</span>FindState findState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Method<span class="token punctuation">[</span><span class="token punctuation">]</span> methods<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//getDeclaredMethods 在某些设备上也会出现 NoClassDefFoundError</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//getDeclaredMethods 要比 getMethods 快，尤其是当订阅者是像 Activities 这样的胖类时</span>        methods <span class="token operator">=</span> findState<span class="token punctuation">.</span>clazz<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> th<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//getMethods 在某些设备上也会出现 NoClassDefFoundError，可能会在 getMethods 周围添加 catch</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            methods <span class="token operator">=</span> findState<span class="token punctuation">.</span>clazz<span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">LinkageError</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// super class of NoClassDefFoundError to be a bit more broad...</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EventBusException</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//clazz.getDeclaredMethods()只返回当前clazz中声明的函数，</span>        <span class="token comment" spellcheck="true">// 而clazz.getMethods()将返回clazz的所有函数(包括继承自父类和接口的函数)，</span>        <span class="token comment" spellcheck="true">// 因此，此时skipSuperClasses被置为true，阻止递归查找父类。</span>        findState<span class="token punctuation">.</span>skipSuperClasses <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//遍历所有方法</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Method method <span class="token operator">:</span> methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> modifiers <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//修饰符</span>        <span class="token comment" spellcheck="true">//MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;</span>        <span class="token comment" spellcheck="true">//校验订阅者方法：must be public, non-static, and non-abstract"</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>modifiers <span class="token operator">&amp;</span> Modifier<span class="token punctuation">.</span>PUBLIC<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>modifiers <span class="token operator">&amp;</span> MODIFIERS_IGNORE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> parameterTypes <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//参数类型</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parameterTypes<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//正好一个参数</span>                Subscribe subscribeAnnotation <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>Subscribe<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>subscribeAnnotation <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 恰好一个参数的非静态的公开类并且有Subscribe注解标记</span>                    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> eventType <span class="token operator">=</span> parameterTypes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 参数为事件类</span>                    <span class="token comment" spellcheck="true">//检查重名方法（本类或父类之间可能重复）用于控制findState.subscriberMethods是否添加找到的method</span>                    <span class="token comment" spellcheck="true">//如果不校验，如果子类重写订阅者方法会导致执行两次子类的订阅者方法</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>findState<span class="token punctuation">.</span><span class="token function">checkAdd</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> eventType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        ThreadMode threadMode <span class="token operator">=</span> subscribeAnnotation<span class="token punctuation">.</span><span class="token function">threadMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//收集订阅者方法，封装 SubscriberMethod</span>                        findState<span class="token punctuation">.</span>subscriberMethods<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SubscriberMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> eventType<span class="token punctuation">,</span> threadMode<span class="token punctuation">,</span>                                subscribeAnnotation<span class="token punctuation">.</span><span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> subscribeAnnotation<span class="token punctuation">.</span><span class="token function">sticky</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>strictMethodVerification <span class="token operator">&amp;&amp;</span> method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>Subscribe<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String methodName <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EventBusException</span><span class="token punctuation">(</span><span class="token string">"@Subscribe method "</span> <span class="token operator">+</span> methodName <span class="token operator">+</span>                        <span class="token string">"must have exactly 1 parameter but has "</span> <span class="token operator">+</span> parameterTypes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>strictMethodVerification <span class="token operator">&amp;&amp;</span> method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>Subscribe<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String methodName <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EventBusException</span><span class="token punctuation">(</span>methodName <span class="token operator">+</span>                    <span class="token string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>为啥不直接用Class.getMethods直接获取该类的全部方法呢？</p><p>如果这个类比较庞大，用getMethods查找所有的方法就显得很笨重了，<br>如果使用的是getDeclaredMethods（该类声明的方法不包括从父类那里继承来的public方法），速度就会快一些，因为找的方法变少了，没有什么 equals,toString,hashCode等Object类的方法。</p><p>Class#getMethods()，不检查方法签名（对于诸如不存在的参数类型之类的东西）。这已更改为 use Class#getDeclaredMethods()，它会检查并在出现问题时抛出异常。</p><p>FindState 对象和对象池</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> POOL_SIZE <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> FindState<span class="token punctuation">[</span><span class="token punctuation">]</span> FIND_STATE_POOL <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FindState</span><span class="token punctuation">[</span>POOL_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">private</span> List<span class="token operator">&lt;</span>SubscriberMethod<span class="token operator">></span> <span class="token function">getMethodsAndRelease</span><span class="token punctuation">(</span>FindState findState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>SubscriberMethod<span class="token operator">></span> subscriberMethods <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>findState<span class="token punctuation">.</span>subscriberMethods<span class="token punctuation">)</span><span class="token punctuation">;</span>    findState<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//findState 回收数据</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>FIND_STATE_POOL<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> POOL_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>FIND_STATE_POOL<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//将当前用过的 findState 缓存回去，下次注册时不用 new</span>                FIND_STATE_POOL<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> findState<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> subscriberMethods<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//先从对象池中随便找一个，没有才创建</span><span class="token keyword">private</span> FindState <span class="token function">prepareFindState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//用的时候隔离开，用完了放回去。</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>FIND_STATE_POOL<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//FindState[] FIND_STATE_POOL</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> POOL_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//POOL_SIZE = 4</span>            FindState state <span class="token operator">=</span> FIND_STATE_POOL<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                FIND_STATE_POOL<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在原来的位置用null占位</span>                <span class="token keyword">return</span> state<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 遍历FindState对象池，只要找到一个空对象就返回，</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FindState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">FindState</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> List<span class="token operator">&lt;</span>SubscriberMethod<span class="token operator">></span> subscriberMethods <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>Class<span class="token punctuation">,</span> Object<span class="token operator">></span> anyMethodByEventType <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Class<span class="token operator">></span> subscriberClassByMethodKey <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> StringBuilder methodKeyBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> subscriberClass<span class="token punctuation">;</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> skipSuperClasses<span class="token punctuation">;</span>    SubscriberInfo subscriberInfo<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">initForSubscriber</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> subscriberClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subscriberClass <span class="token operator">=</span> clazz <span class="token operator">=</span> subscriberClass<span class="token punctuation">;</span>        skipSuperClasses <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        subscriberInfo <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        subscriberMethods<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        anyMethodByEventType<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        subscriberClassByMethodKey<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        methodKeyBuilder<span class="token punctuation">.</span><span class="token function">setLength</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        subscriberClass <span class="token operator">=</span> null<span class="token punctuation">;</span>        clazz <span class="token operator">=</span> null<span class="token punctuation">;</span>        skipSuperClasses <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        subscriberInfo <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 检查是否已经添加过这个订阅者方法</span>    <span class="token keyword">boolean</span> <span class="token function">checkAdd</span><span class="token punctuation">(</span>Method method<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> eventType<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//2 级检查：仅具有事件类型的第一级（快速），在需要时具有完整签名的第二级。</span>        <span class="token comment" spellcheck="true">// 通常订阅者没有侦听相同事件类型的方法。</span>        <span class="token comment" spellcheck="true">//第一层判断有无method监听此eventType,如果没有则可直接把找到的method加到subscriberMethods中。</span>        <span class="token comment" spellcheck="true">//第二层检查的是从MethodSignature（方法签名）判断能否把找到的method加进去。是为了防止在找父类时覆盖了子类的方法，因为此方法是子类是重写，方法名参数名完全一样（方法签名）；另一个原因是可能是当一个类有多个方法监听同一个event(尽管一般不会这样做)，也能将这些方法加进去。</span>        Object existing <span class="token operator">=</span> anyMethodByEventType<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> method<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>existing <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//没有添加过，</span>            <span class="token comment" spellcheck="true">//anyMethodByEventType存储&lt;eventType, method>映射关系，</span>            <span class="token comment" spellcheck="true">// 若existing为空，则表示eventType第一次出现。</span>            <span class="token comment" spellcheck="true">// 一般情况下，一个对象只会有一个订阅函数处理特定eventType。</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//一个类有多个方法监听同一个事件类型</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>existing <span class="token keyword">instanceof</span> <span class="token class-name">Method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//处理一个对象有多个订阅函数处理eventType的情况，</span>                <span class="token comment" spellcheck="true">// 此时，anyMethodByEventType中eventType被映射到一个非Method对象(即this)。</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">checkAddWithMethodSignature</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Method<span class="token punctuation">)</span> existing<span class="token punctuation">,</span> eventType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Paranoia check</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Put any non-Method object to "consume" the existing Method</span>                <span class="token comment" spellcheck="true">//将任何非 Method 对象“使用”现有的 Method</span>                anyMethodByEventType<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token function">checkAddWithMethodSignature</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> eventType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//由于存在多个订阅函数处理eventType，此时，单纯使用eventType作为key已经无法满足要求了，</span>    <span class="token comment" spellcheck="true">// 因此，使用method.getName() + ">" + eventType.getName()作为methodKey，</span>    <span class="token comment" spellcheck="true">// 并使用subscriberClassByMethodKey存储&lt;methodKey, methodClass>的映射关系。</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">checkAddWithMethodSignature</span><span class="token punctuation">(</span>Method method<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> eventType<span class="token punctuation">)</span> <span class="token punctuation">{</span>        methodKeyBuilder<span class="token punctuation">.</span><span class="token function">setLength</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        methodKeyBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        methodKeyBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'>'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>eventType<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//onEvent>TestEvent</span>        String methodKey <span class="token operator">=</span> methodKeyBuilder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//getDeclaringClass: 返回表示类或接口的 Class 对象，该类或接口声明了由此对象表示的可执行文件。</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> methodClass <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//map["onEvent>TestEvent"]=</span>        <span class="token comment" spellcheck="true">//如果methodClassOld或者methodClass是methodClassOld的子类，</span>        <span class="token comment" spellcheck="true">// 则将&lt;methodKey, methodClass>放入，否则不放入。</span>        <span class="token comment" spellcheck="true">// 满足函数名相同、参数类型相同且被@Subscribe修饰的函数，</span>        <span class="token comment" spellcheck="true">// 在一个类中不可能存在两个；考虑类继承体系，若这样的两个函数分别来自父类和子类，</span>        <span class="token comment" spellcheck="true">// 则最终被加入的是子类的函数。</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> methodClassOld <span class="token operator">=</span> subscriberClassByMethodKey<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>methodKey<span class="token punctuation">,</span> methodClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//确定此Class对象表示的类或接口是否与指定的Class参数表示的类或接口相同，或者是其超类或超接口。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>methodClassOld <span class="token operator">==</span> null <span class="token operator">||</span> methodClassOld<span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>methodClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Only add if not already found in a sub class</span>            <span class="token comment" spellcheck="true">//仅在子类中未找到时才添加</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Revert the put, old class is further down the class hierarchy</span>            <span class="token comment" spellcheck="true">//还原放置，旧类在类层次结构中更靠后</span>            subscriberClassByMethodKey<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>methodKey<span class="token punctuation">,</span> methodClassOld<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">moveToSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>skipSuperClasses<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//反射方法时是通过getMethod 方式，已经包含父类方法了</span>            clazz <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            clazz <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String clazzName <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Skip system classes, this degrades performance.</span>            <span class="token comment" spellcheck="true">// Also we might avoid some ClassNotFoundException (see FAQ for background).</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>clazzName<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"java."</span><span class="token punctuation">)</span> <span class="token operator">||</span> clazzName<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"javax."</span><span class="token punctuation">)</span> <span class="token operator">||</span>                    clazzName<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"android."</span><span class="token punctuation">)</span> <span class="token operator">||</span> clazzName<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"androidx."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                clazz <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>通过APT中收集数据中查找</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> List<span class="token operator">&lt;</span>SubscriberMethod<span class="token operator">></span> <span class="token function">findUsingInfo</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> subscriberClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>    FindState findState <span class="token operator">=</span> <span class="token function">prepareFindState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    findState<span class="token punctuation">.</span><span class="token function">initForSubscriber</span><span class="token punctuation">(</span>subscriberClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>findState<span class="token punctuation">.</span>clazz <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//通过订阅者类从索引类中查找订阅者方法信息:subscriberInfo</span>        findState<span class="token punctuation">.</span>subscriberInfo <span class="token operator">=</span> <span class="token function">getSubscriberInfo</span><span class="token punctuation">(</span>findState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>findState<span class="token punctuation">.</span>subscriberInfo <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            SubscriberMethod<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> findState<span class="token punctuation">.</span>subscriberInfo<span class="token punctuation">.</span><span class="token function">getSubscriberMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>SubscriberMethod subscriberMethod <span class="token operator">:</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 检查重名方法（本类或父类之间都可能重复</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>findState<span class="token punctuation">.</span><span class="token function">checkAdd</span><span class="token punctuation">(</span>subscriberMethod<span class="token punctuation">.</span>method<span class="token punctuation">,</span> subscriberMethod<span class="token punctuation">.</span>eventType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    findState<span class="token punctuation">.</span>subscriberMethods<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>subscriberMethod<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//apt 没有正常收集该类，降级为反射方式查找</span>            <span class="token function">findUsingReflectionInSingleClass</span><span class="token punctuation">(</span>findState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        findState<span class="token punctuation">.</span><span class="token function">moveToSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">getMethodsAndRelease</span><span class="token punctuation">(</span>findState<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> SubscriberInfo <span class="token function">getSubscriberInfo</span><span class="token punctuation">(</span>FindState findState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//找完子类找父类</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>findState<span class="token punctuation">.</span>subscriberInfo <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> findState<span class="token punctuation">.</span>subscriberInfo<span class="token punctuation">.</span><span class="token function">getSuperSubscriberInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SubscriberInfo superclassInfo <span class="token operator">=</span> findState<span class="token punctuation">.</span>subscriberInfo<span class="token punctuation">.</span><span class="token function">getSuperSubscriberInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>findState<span class="token punctuation">.</span>clazz <span class="token operator">==</span> superclassInfo<span class="token punctuation">.</span><span class="token function">getSubscriberClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> superclassInfo<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//apt 收集的索引类</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>subscriberInfoIndexes <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//通过订阅者类从索引类中查找订阅者方法信息</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>SubscriberInfoIndex index <span class="token operator">:</span> subscriberInfoIndexes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            SubscriberInfo info <span class="token operator">=</span> index<span class="token punctuation">.</span><span class="token function">getSubscriberInfo</span><span class="token punctuation">(</span>findState<span class="token punctuation">.</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>info <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> info<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>查找流程小结</strong></p><p>注册订阅者分为查找和订阅两个过程</p><p>查找过程具体是通过当前订阅者类找出该类中声明的所有订阅者方法。查找逻辑封装在 SubscriberMethodFinder 类中，查找方式有两中，如果使用了注解处理器模块就可以通过生成的索引类查找，这种方式不需要通过反射就能收集到所有订阅者方法，效率较高。</p><p>还有一种就是运行时通过反射订阅者类的getMethods 或者getDeclaredMethods这两个方法收集订阅者方法，这种方式效率低，不推荐使用。</p><p>亮点整理：</p><ul><li>METHOD_CACHE 缓存了查找过的进程内所有订阅者的键值对(订阅者类，类中的订阅者方法)信息，使用ConcurrentHashMap即保证的查找效率也避免了线程安全问题。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">,</span> List<span class="token operator">&lt;</span>SubscriberMethod<span class="token operator">>></span> METHOD_CACHE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>FIND_STATE_POOL 是 FindState 对象池的一维静态数组，FindState 对查找的状态值做了一些封装以及对订阅者方法的检查逻辑。<ul><li>为什么要使用FindState呢？首先是面向对象封装的采用</li><li>在JVM系统中频繁地创建对象，是非常消耗资源的，在jvm垃圾回收时候，有可能会出现内存抖动的问题。使用对象池数组就有效的避免了内存抖动的问题。</li><li>对 FIND_STATE_POOL  的操作需要考虑线程同步问题，这里使用了<code>synchronized</code>关键字来保证线程安全。</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> FindState<span class="token punctuation">[</span><span class="token punctuation">]</span> FIND_STATE_POOL <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FindState</span><span class="token punctuation">[</span>POOL_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p><strong>订阅流程</strong></p><p>查找到当前注册的订阅者类中的所有订阅者方法后，下一步就是为每一个订阅者方法执行订阅流程了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span>Object subscriber<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> subscriberClass <span class="token operator">=</span> subscriber<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 01查找订阅者方法流程</span>    <span class="token comment" spellcheck="true">// 通过订阅者类找出该类中所有的订阅者方法</span>    List<span class="token operator">&lt;</span>SubscriberMethod<span class="token operator">></span> subscriberMethods <span class="token operator">=</span> subscriberMethodFinder<span class="token punctuation">.</span><span class="token function">findSubscriberMethods</span><span class="token punctuation">(</span>subscriberClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//遍历该订阅者类中所有订阅者方法，执行订阅操作</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>SubscriberMethod subscriberMethod <span class="token operator">:</span> subscriberMethods<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 02订阅流程</span>            <span class="token comment" spellcheck="true">// 收集订阅者，事件类，分发粘性事件等</span>            <span class="token function">subscribe</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">,</span> subscriberMethod<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>订阅流程大题分为三步</p><ul><li>通过事件类找所有已经订阅过该事件的订阅者们，目的是为了进行优先级排序,全局缓存已注册订阅者等</li><li>通过订阅者类找所有已经注册过的 Event 们， 用于判断是否注册、解注册等</li><li>当前订阅者中有粘性事件，在 register 的时候根据当前订阅者方法的 event 直接执行分发</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">subscribe</span><span class="token punctuation">(</span>Object subscriber<span class="token punctuation">,</span> SubscriberMethod subscriberMethod<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//事件类</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> eventType <span class="token operator">=</span> subscriberMethod<span class="token punctuation">.</span>eventType<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//封装订阅者</span>    Subscription newSubscription <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subscription</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">,</span> subscriberMethod<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Map&lt;Class&lt;?>, CopyOnWriteArrayList&lt;Subscription>> subscriptionsByEventType;</span>    <span class="token comment" spellcheck="true">//通过事件类找所有该事件的订阅者，</span>    CopyOnWriteArrayList<span class="token operator">&lt;</span>Subscription<span class="token operator">></span> subscriptions <span class="token operator">=</span> subscriptionsByEventType<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>eventType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//还没缓存该事件就存且只能存一次</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>subscriptions <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        subscriptions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        subscriptionsByEventType<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> subscriptions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//不能有重复订阅者</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>subscriptions<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>newSubscription<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EventBusException</span><span class="token punctuation">(</span><span class="token string">"Subscriber "</span> <span class="token operator">+</span> subscriber<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" already registered to event "</span>                    <span class="token operator">+</span> eventType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> subscriptions<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//优先级排序，要么最小查到最后，要么之前的某个位置</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> size <span class="token operator">||</span> subscriberMethod<span class="token punctuation">.</span>priority <span class="token operator">></span> subscriptions<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>subscriberMethod<span class="token punctuation">.</span>priority<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//向事件对应的订阅者列表中添加当前订阅者，完成排序操作</span>            subscriptions<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> newSubscription<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//Map&lt;Object, List&lt;Class&lt;?>>> typesBySubscriber;</span>    <span class="token comment" spellcheck="true">//通过订阅者类找所有Event</span>    List<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> subscribedEvents <span class="token operator">=</span> typesBySubscriber<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>subscribedEvents <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        subscribedEvents <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        typesBySubscriber<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">,</span> subscribedEvents<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//将当前订阅者方法的 event 存到指定订阅者类下的列表里</span>    subscribedEvents<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>eventType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//粘性事件：先pst 后 订阅</span>    <span class="token comment" spellcheck="true">//当前订阅者中有粘性事件，在 register 的时候根据当前订阅者方法的 event 直接执行分发</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>subscriberMethod<span class="token punctuation">.</span>sticky<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//eventInheritance: 默认true</span>        <span class="token comment" spellcheck="true">// 默认情况下，EventBus 考虑事件类层次结构（将通知超类的订阅者）。 关闭此功能将改进事件的发布。</span>        <span class="token comment" spellcheck="true">// 对于直接扩展 Object 的简单事件类，我们测得事件发布速度提高了 20%。 对于更复杂的事件层次结构，加速应该大于 20%。</span>        <span class="token comment" spellcheck="true">//但是，请记住，事件发布通常只消耗应用程序内一小部分 CPU 时间，除非它以高速率发布，例如每秒数百/数千个事件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventInheritance<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//</span>            <span class="token comment" spellcheck="true">//必须考虑 eventType 的所有子类的现有粘性事件。注意：对于大量粘性事件，迭代所有事件可能效率低下，</span>            <span class="token comment" spellcheck="true">// 因此应更改数据结构以允许更有效的查找（例如，存储超类的子类的附加映射：Class -> List&lt;Class>）。</span>            <span class="token comment" spellcheck="true">//stickyEvents = new ConcurrentHashMap&lt;>();</span>            Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">,</span> Object<span class="token operator">>></span> entries <span class="token operator">=</span> stickyEvents<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">,</span> Object<span class="token operator">></span> entry <span class="token operator">:</span> entries<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//key: event.getClass(), value: event</span>                Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> candidateEventType <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//isAssignableFrom: 确定此Class对象表示的类或接口是否与指定的Class参数表示的类或接口相同，或者是其超类或超接口。 如果是，则返回true ； 否则返回false 。 如果此Class对象表示原始类型，则如果指定的Class参数正是此Class对象，则此方法返回true ； 否则返回false 。</span>                <span class="token comment" spellcheck="true">//具体来说，此方法测试是否可以通过标识转换或通过扩展引用转换将指定Class参数表示的类型转换为此Class对象表示的类型。 有关详细信息，请参阅Java 语言规范5.1.1 和 5.1.4 节</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>eventType<span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>candidateEventType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//比较class</span>                    Object stickyEvent <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">checkPostStickyEventToSubscription</span><span class="token punctuation">(</span>newSubscription<span class="token punctuation">,</span> stickyEvent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//通过粘性事件类查找所有粘性事件对象</span>            Object stickyEvent <span class="token operator">=</span> stickyEvents<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>eventType<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">checkPostStickyEventToSubscription</span><span class="token punctuation">(</span>newSubscription<span class="token punctuation">,</span> stickyEvent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">checkPostStickyEventToSubscription</span><span class="token punctuation">(</span>Subscription newSubscription<span class="token punctuation">,</span> Object stickyEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>stickyEvent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)</span>        <span class="token comment" spellcheck="true">// --> Strange corner case, which we don't take care of here.</span>        <span class="token comment" spellcheck="true">//如果订阅者试图中止事件，它将失败（事件在发布状态下不被跟踪）--> 奇怪的极端情况，我们在这里不处理。</span>        <span class="token function">postToSubscription</span><span class="token punctuation">(</span>newSubscription<span class="token punctuation">,</span> stickyEvent<span class="token punctuation">,</span> <span class="token function">isMainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="注册订阅者流程总结"><a href="#注册订阅者流程总结" class="headerlink" title="注册订阅者流程总结"></a>注册订阅者流程总结</h5><p>注册订阅者分为查找和订阅两个过程</p><p>查找过程具体是通过当前订阅者类找出该类中声明的所有订阅者方法。查找逻辑封装在 SubscriberMethodFinder 类中，查找方式有两中，如果使用了注解处理器模块就可以通过生成的索引类查找，这种方式不需要通过反射就能收集到所有订阅者方法，效率较高。</p><p>还有一种就是运行时通过反射订阅者类的getMethods 或者getDeclaredMethods这两个方法收集订阅者方法，这种方式效率低，不推荐使用。</p><p>订阅过程具体是针对当前订阅者的每一个订阅者方法（查找流程得到）以事件类为范围进行全局排序，收集当前订阅者类的所有事件以及对粘性事件的分发。</p><p>亮点整理：</p><ul><li>CopyOnWriteArrayList 保证线程安全</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">,</span> CopyOnWriteArrayList<span class="token operator">&lt;</span>Subscription<span class="token operator">>></span> subscriptionsByEventType<span class="token punctuation">;</span></code></pre><ul><li>ConcurrentHashMap 保证了效率和安全</li></ul><pre class=" language-java"><code class="language-java">stickyEvents <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="10-2-3-事件发布"><a href="#10-2-3-事件发布" class="headerlink" title="10.2.3 事件发布"></a>10.2.3 事件发布</h4><p>发布粘性事件，粘性事件特别之处在于发布前存到了一个map中，当注册时直接执行粘性事件的发布</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postSticky</span><span class="token punctuation">(</span>Object event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>stickyEvents<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stickyEvents<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//放置后应发布，以防订阅者想立即删除</span>    <span class="token function">post</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>发布普通事件，通过ThreadLocal保证发送时的同步问题</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">post</span><span class="token punctuation">(</span>Object event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//currentPostingThreadState = new ThreadLocal&lt;PostingThreadState>()</span>    <span class="token comment" spellcheck="true">//每个线程都有一份 postingState 实例，</span>    <span class="token comment" spellcheck="true">//封装 PostingThreadState 对于 ThreadLocal，设置（并获得多个值）要快得多。</span>    PostingThreadState postingState <span class="token operator">=</span> currentPostingThreadState<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Object<span class="token operator">></span> eventQueue <span class="token operator">=</span> postingState<span class="token punctuation">.</span>eventQueue<span class="token punctuation">;</span>    eventQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>postingState<span class="token punctuation">.</span>isPosting<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 默认 false</span>        postingState<span class="token punctuation">.</span>isMainThread <span class="token operator">=</span> <span class="token function">isMainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//判断主线程还是子线程</span>        postingState<span class="token punctuation">.</span>isPosting <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里保证 cancelEventDelivery 是在同一个线程调用的</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>postingState<span class="token punctuation">.</span>canceled<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//cancelEventDelivery</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EventBusException</span><span class="token punctuation">(</span><span class="token string">"Internal error. Abort state was not reset"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//可能发送了多个事件</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>eventQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//发送队列依次取出第一个事件执行发布</span>                <span class="token function">postSingleEvent</span><span class="token punctuation">(</span>eventQueue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> postingState<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//发送完事件后重置标志位</span>            postingState<span class="token punctuation">.</span>isPosting <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            postingState<span class="token punctuation">.</span>isMainThread <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>事件发布时考虑事件的继承关系</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//发送队列的第一个事件</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">postSingleEvent</span><span class="token punctuation">(</span>Object event<span class="token punctuation">,</span> PostingThreadState postingState<span class="token punctuation">)</span> <span class="token keyword">throws</span> Error <span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> eventClass <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> subscriptionFound <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//是否考虑订阅者的继承关系</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>eventInheritance<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//事件类和事件类的父类们</span>        List<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> eventTypes <span class="token operator">=</span> <span class="token function">lookupAllEventTypes</span><span class="token punctuation">(</span>eventClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> countTypes <span class="token operator">=</span> eventTypes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> h <span class="token operator">&lt;</span> countTypes<span class="token punctuation">;</span> h<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz <span class="token operator">=</span> eventTypes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//当前类和父类有一个没收到就算失败</span>            subscriptionFound <span class="token operator">|=</span> <span class="token function">postSingleEventForEventType</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> postingState<span class="token punctuation">,</span> clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        subscriptionFound <span class="token operator">=</span> <span class="token function">postSingleEventForEventType</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> postingState<span class="token punctuation">,</span> eventClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>subscriptionFound<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>logNoSubscriberMessages<span class="token punctuation">)</span> <span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Level<span class="token punctuation">.</span>FINE<span class="token punctuation">,</span> <span class="token string">"No subscribers registered for event "</span> <span class="token operator">+</span> eventClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//兜底方案，发送一个通知事件，告诉订阅者刚才的事件没发送成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sendNoSubscriberEvent <span class="token operator">&amp;&amp;</span> eventClass <span class="token operator">!=</span> NoSubscriberEvent<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">&amp;&amp;</span>                eventClass <span class="token operator">!=</span> SubscriberExceptionEvent<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">post</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NoSubscriberEvent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过单事件，找到所有观察者，遍历所有观察该事件的观察者，执行发布操作</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">postSingleEventForEventType</span><span class="token punctuation">(</span>Object event<span class="token punctuation">,</span> PostingThreadState postingState<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> eventClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>    CopyOnWriteArrayList<span class="token operator">&lt;</span>Subscription<span class="token operator">></span> subscriptions<span class="token punctuation">;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//通过单事件，找到所有观察者</span>        subscriptions <span class="token operator">=</span> subscriptionsByEventType<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>eventClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>subscriptions <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>subscriptions<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Subscription subscription <span class="token operator">:</span> subscriptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//存入线程</span>            postingState<span class="token punctuation">.</span>event <span class="token operator">=</span> event<span class="token punctuation">;</span>            postingState<span class="token punctuation">.</span>subscription <span class="token operator">=</span> subscription<span class="token punctuation">;</span>            <span class="token keyword">boolean</span> aborted<span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">postToSubscription</span><span class="token punctuation">(</span>subscription<span class="token punctuation">,</span> event<span class="token punctuation">,</span> postingState<span class="token punctuation">.</span>isMainThread<span class="token punctuation">)</span><span class="token punctuation">;</span>                aborted <span class="token operator">=</span> postingState<span class="token punctuation">.</span>canceled<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//重置状态</span>                postingState<span class="token punctuation">.</span>event <span class="token operator">=</span> null<span class="token punctuation">;</span>                postingState<span class="token punctuation">.</span>subscription <span class="token operator">=</span> null<span class="token punctuation">;</span>                postingState<span class="token punctuation">.</span>canceled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>aborted<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>发布时会根据订阅者的线程模型做出不同处理</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//发布到订阅</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">postToSubscription</span><span class="token punctuation">(</span>Subscription subscription<span class="token punctuation">,</span> Object event<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isMainThread<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//根据线程模型不同处理</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>subscription<span class="token punctuation">.</span>subscriberMethod<span class="token punctuation">.</span>threadMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> POSTING<span class="token operator">:</span> <span class="token comment" spellcheck="true">//订阅和发布是同一个线程</span>            <span class="token function">invokeSubscriber</span><span class="token punctuation">(</span>subscription<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> MAIN<span class="token operator">:</span> <span class="token comment" spellcheck="true">//订阅在主线程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>isMainThread<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">invokeSubscriber</span><span class="token punctuation">(</span>subscription<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//通过Handler 发送到主线程</span>                mainThreadPoster<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>subscription<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> MAIN_ORDERED<span class="token operator">:</span> <span class="token comment" spellcheck="true">//订阅在主线程排队</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mainThreadPoster <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                mainThreadPoster<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>subscription<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//临时：技术上不正确，因为海报没有与订阅者分离</span>                <span class="token comment" spellcheck="true">// temporary: technically not correct as poster not decoupled from subscriber</span>                <span class="token function">invokeSubscriber</span><span class="token punctuation">(</span>subscription<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> BACKGROUND<span class="token operator">:</span><span class="token operator">/</span><span class="token comment" spellcheck="true">///如果发帖线程非主线程则订阅者的处理会在工作线程中执行否则和发布者同一个线程处理。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>isMainThread<span class="token punctuation">)</span> <span class="token punctuation">{</span>                backgroundPoster<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>subscription<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">invokeSubscriber</span><span class="token punctuation">(</span>subscription<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> ASYNC<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>无论事件在哪个线程发布，订阅者都会在新建的工作线程中执行。            asyncPoster<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>subscription<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Unknown thread mode: "</span> <span class="token operator">+</span> subscription<span class="token punctuation">.</span>subscriberMethod<span class="token punctuation">.</span>threadMode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>三个发布器 mainThreadPoster,backgroundPoster,asyncPoster  对应四种线程模型</p><p>反射调用观察者</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//同一个线程执行订阅者方法</span><span class="token keyword">void</span> <span class="token function">invokeSubscriber</span><span class="token punctuation">(</span>Subscription subscription<span class="token punctuation">,</span> Object event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//方法、类、参数</span>        subscription<span class="token punctuation">.</span>subscriberMethod<span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>subscription<span class="token punctuation">.</span>subscriber<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">handleSubscriberException</span><span class="token punctuation">(</span>subscription<span class="token punctuation">,</span> event<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Unexpected exception"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="事件发布流程总结"><a href="#事件发布流程总结" class="headerlink" title="事件发布流程总结"></a>事件发布流程总结</h5><p>发布事件通过ThreadLocal保证发送时的同步问题，粘性事件就是发布前存到一个map中，当订阅者注册时会遍历该map执行粘性事件的发布，事件发布时默认会考虑事件的继承关系即订阅事件的父类的订阅者也会收到事件。</p><p>具体发布过程为：通过单事件，找到所有观察者，遍历所有观察该事件的观察者，执行发布操作，发布时会根据订阅者的线程模型做出不同处理，通过三个发布器 mainThreadPoster,backgroundPoster,asyncPoster  完成四种线程模型的切换，最后通过反射调用观察者。</p><h4 id="10-2-4-注销订阅者"><a href="#10-2-4-注销订阅者" class="headerlink" title="10.2.4 注销订阅者"></a>10.2.4 注销订阅者</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> override fun <span class="token function">onStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    EventBus<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unregister</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>根据订阅者类找该类的所有事件</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">unregister</span><span class="token punctuation">(</span>Object subscriber<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//找到订阅者类对应的事件类列表</span>    List<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> subscribedTypes <span class="token operator">=</span> typesBySubscriber<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>subscribedTypes <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//根据每个事件类解除每个订阅者</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> eventType <span class="token operator">:</span> subscribedTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">unsubscribeByEventType</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">,</span> eventType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//从内存map 移除</span>        typesBySubscriber<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Level<span class="token punctuation">.</span>WARNING<span class="token punctuation">,</span> <span class="token string">"Subscriber to unregister was not registered before: "</span> <span class="token operator">+</span> subscriber<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>根据每个事件找对应的所有订阅者，如果订阅者中的订阅者类和当前类一样才执行解除订阅</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unsubscribeByEventType</span><span class="token punctuation">(</span>Object subscriber<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> eventType<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//根据每个事件类找到所有该事件的订阅者</span>    List<span class="token operator">&lt;</span>Subscription<span class="token operator">></span> subscriptions <span class="token operator">=</span> subscriptionsByEventType<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>eventType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>subscriptions <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> subscriptions<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//每个订阅者：类+方法</span>            Subscription subscription <span class="token operator">=</span> subscriptions<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//确认是当前类的订阅者</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>subscription<span class="token punctuation">.</span>subscriber <span class="token operator">==</span> subscriber<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//修改解除订阅标志位</span>                subscription<span class="token punctuation">.</span>active <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                subscriptions<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                i<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//防止越界</span>                size<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="注销订阅者流程总结"><a href="#注销订阅者流程总结" class="headerlink" title="注销订阅者流程总结"></a>注销订阅者流程总结</h5><p>注销流程就是先通过订阅者类找所有事件，遍历每一个事件找所有订阅者，判断订阅者中的订阅者类是否和当前类一致，一致就将订阅者中的 active 标记为false 用来阻止继续发布事件，并从内存map中移除。</p><h2 id="11-参考"><a href="#11-参考" class="headerlink" title="11. 参考"></a>11. 参考</h2><p><strong><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">Github | EventBus</a></strong></p><p><a href="https://greenrobot.org/eventbus/documentation/" target="_blank" rel="noopener">EventBus Documentation</a></p><p><a href="https://time.geekbang.org/column/intro/250?code=Grxvvkczx9tydhzn0RhJfNfwaF2RgJA9qeUWd8orIYo%3D" target="_blank" rel="noopener">极客时间| 设计模式之美</a></p><p><a href="https://cloud.tencent.com/developer/article/1383971" target="_blank" rel="noopener">EventBus 如何使用及一些常见场景</a></p><p><a href="https://blog.csdn.net/f552126367/article/details/86571012" target="_blank" rel="noopener">EventBus使用总结和使用场景</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观察者模式 </tag>
            
            <tag> EventBus </tag>
            
            <tag> 事件总线 </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筑基系列-JVM基础知识小抄版</title>
      <link href="2020/07/31/java-jvm/"/>
      <url>2020/07/31/java-jvm/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/post_banner_jay.png" alt=""></p><h1 id="筑基系列-JVM基础知识小抄版"><a href="#筑基系列-JVM基础知识小抄版" class="headerlink" title="筑基系列-JVM基础知识小抄版"></a>筑基系列-JVM基础知识小抄版</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p><h2 id="1-JVM-内存结构"><a href="#1-JVM-内存结构" class="headerlink" title="1.JVM 内存结构"></a>1.JVM 内存结构</h2><p>Java 虚拟机的内存空间分为 5 个部分：</p><ul><li>程序计数器</li><li>Java 虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>方法区</li></ul><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/jvm-memory-structure.jpg" alt="jvm-memory-structure"></p><p>JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。</p><h3 id="1-1-程序计数器（PC-寄存器）"><a href="#1-1-程序计数器（PC-寄存器）" class="headerlink" title="1.1 程序计数器（PC 寄存器）"></a>1.1 程序计数器（PC 寄存器）</h3><h4 id="程序计数器的定义"><a href="#程序计数器的定义" class="headerlink" title="程序计数器的定义"></a>程序计数器的定义</h4><p>程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为<code>Undefined</code>。</p><h4 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h4><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。</li><li>在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。</li></ul><h4 id="程序计数器的特点"><a href="#程序计数器的特点" class="headerlink" title="程序计数器的特点"></a>程序计数器的特点</h4><ul><li>是一块较小的内存空间。</li><li>线程私有，每条线程都有自己的程序计数器。</li><li>生命周期：随着线程的创建而创建，随着线程的结束而销毁。</li><li>是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域。</li></ul><h3 id="1-2-Java-虚拟机栈（Java-栈）"><a href="#1-2-Java-虚拟机栈（Java-栈）" class="headerlink" title="1.2 Java 虚拟机栈（Java 栈）"></a>1.2 Java 虚拟机栈（Java 栈）</h3><h4 id="Java-虚拟机栈的定义"><a href="#Java-虚拟机栈的定义" class="headerlink" title="Java 虚拟机栈的定义"></a>Java 虚拟机栈的定义</h4><p>Java 虚拟机栈是描述 Java 方法运行过程的内存模型。</p><p>Java 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：</p><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法出口信息</li><li>……</li></ul><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/jvm-stack.jpg" alt="jvm-stack"></p><h4 id="压栈出栈过程"><a href="#压栈出栈过程" class="headerlink" title="压栈出栈过程"></a>压栈出栈过程</h4><p>当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。</p><p>Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。</p><p>方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。</p><blockquote><p>由于 Java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。</p></blockquote><h4 id="Java-虚拟机栈的特点"><a href="#Java-虚拟机栈的特点" class="headerlink" title="Java 虚拟机栈的特点"></a>Java 虚拟机栈的特点</h4><ul><li>局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。</li><li>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。<ul><li>StackOverFlowError 若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。</li><li>OutOfMemoryError 若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。</li></ul></li><li>Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。</li></ul><blockquote><p>出现 StackOverFlowError 时，内存空间可能还有很多。</p></blockquote><h3 id="1-3-本地方法栈（C-栈）"><a href="#1-3-本地方法栈（C-栈）" class="headerlink" title="1.3 本地方法栈（C 栈）"></a>1.3 本地方法栈（C 栈）</h3><h4 id="本地方法栈的定义"><a href="#本地方法栈的定义" class="headerlink" title="本地方法栈的定义"></a>本地方法栈的定义</h4><p>本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。</p><h4 id="栈帧变化过程"><a href="#栈帧变化过程" class="headerlink" title="栈帧变化过程"></a>栈帧变化过程</h4><p>本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。</p><p>方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。</p><blockquote><p>如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。</p></blockquote><h3 id="1-4-堆"><a href="#1-4-堆" class="headerlink" title="1.4 堆"></a>1.4 堆</h3><h4 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h4><p>堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。</p><h4 id="堆的特点"><a href="#堆的特点" class="headerlink" title="堆的特点"></a>堆的特点</h4><ul><li>线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。</li><li>在虚拟机启动时创建。</li><li>是垃圾回收的主要场所。</li><li>进一步可分为：新生代（Eden 区：<code>From Survior</code>，<code>To Survivor</code>）、老年代。</li></ul><p>不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。</p><p>堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。</p><blockquote><p>Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。</p></blockquote><h3 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h3><h4 id="方法区的定义"><a href="#方法区的定义" class="headerlink" title="方法区的定义"></a>方法区的定义</h4><p>Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：</p><ul><li>已经被虚拟机加载的类信息</li><li>常量</li><li>静态变量</li><li>即时编译器编译后的代码</li></ul><h4 id="方法区的特点"><a href="#方法区的特点" class="headerlink" title="方法区的特点"></a>方法区的特点</h4><ul><li>线程共享。 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。</li><li>永久代。 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。</li><li>内存回收效率低。 方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。</li><li>Java 虚拟机规范对方法区的要求比较宽松。 和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。</li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。</p><p>当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 <code>intern()</code> 方法就能在运行期间向常量池中添加字符串常量。</p><h3 id="1-6-直接内存（堆外内存）"><a href="#1-6-直接内存（堆外内存）" class="headerlink" title="1.6 直接内存（堆外内存）"></a>1.6 直接内存（堆外内存）</h3><p>直接内存是除 Java 虚拟机之外的内存，但也可能被 Java 使用。</p><h4 id="操作直接内存"><a href="#操作直接内存" class="headerlink" title="操作直接内存"></a>操作直接内存</h4><p>在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的<code>DirectByteBuffer</code>对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。</p><p>直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。</p><h4 id="直接内存与堆内存比较"><a href="#直接内存与堆内存比较" class="headerlink" title="直接内存与堆内存比较"></a>直接内存与堆内存比较</h4><ul><li>直接内存申请空间耗费更高的性能</li><li>直接内存读取 IO 的性能要优于普通的堆内存。</li><li>直接内存作用链： 本地 IO -&gt; 直接内存 -&gt; 本地 IO</li><li>堆内存作用链：本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地 IO</li></ul><blockquote><p>服务器管理员在配置虚拟机参数时，会根据实际内存设置<code>-Xmx</code>等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现<code>OutOfMemoryError</code>异常。</p></blockquote><h2 id="2-HotSpot-虚拟机对象探秘"><a href="#2-HotSpot-虚拟机对象探秘" class="headerlink" title="2.HotSpot 虚拟机对象探秘"></a>2.HotSpot 虚拟机对象探秘</h2><h3 id="2-1-对象的内存布局"><a href="#2-1-对象的内存布局" class="headerlink" title="2.1 对象的内存布局"></a>2.1 对象的内存布局</h3><p>在 HotSpot 虚拟机中，对象的内存布局分为以下 3 块区域：</p><ul><li>对象头（Header）</li><li>实例数据（Instance Data）</li><li>对齐填充（Padding）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/object-memory-layout.png" alt="object-memory-layout.png"></p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>对象头记录了对象在运行过程中所需要使用的一些数据：</p><ul><li>哈希码</li><li>GC 分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程 ID</li><li>偏向时间戳</li></ul><p>对象头可能包含类型指针，通过该指针能确定对象属于哪个类。如果对象是一个数组，那么对象头还会包括数组长度。</p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>实例数据部分就是成员变量的值，其中包括父类成员变量和本类成员变量。</p><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>用于确保对象的总长度为 8 字节的整数倍。</p><p>HotSpot VM 的自动内存管理系统要求对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><blockquote><p>对齐填充并不是必然存在，也没有特别的含义，它仅仅起着占位符的作用。</p></blockquote><h3 id="2-2-对象的创建过程"><a href="#2-2-对象的创建过程" class="headerlink" title="2.2 对象的创建过程"></a>2.2 对象的创建过程</h3><h4 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h4><p>虚拟机在解析<code>.class</code>文件时，若遇到一条 new 指令，首先它会去检查常量池中是否有这个类的符号引用，并且检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程。</p><h4 id="为新生对象分配内存"><a href="#为新生对象分配内存" class="headerlink" title="为新生对象分配内存"></a>为新生对象分配内存</h4><p>对象所需内存的大小在类加载完成后便可完全确定，接下来从堆中划分一块对应大小的内存空间给新的对象。分配堆中内存有两种方式：</p><ul><li><p><strong>指针碰撞</strong><br><br>如果 Java <strong>堆中内存绝对规整</strong>（说明采用的是“<strong>复制算法</strong>”或“<strong>标记整理法</strong>”），空闲内存和已使用内存中间放着一个指针作为分界点指示器，那么分配内存时只需要把指针向空闲内存挪动一段与对象大小一样的距离，这种分配方式称为“<strong>指针碰撞</strong>”。</p></li><li><p><strong>空闲列表</strong><br><br>如果 Java <strong>堆中内存并不规整</strong>，已使用的内存和空闲内存交错（说明采用的是<strong>标记-清除法</strong>，有碎片），此时没法简单进行指针碰撞， VM 必须维护一个列表，记录其中哪些内存块空闲可用。分配之时从空闲列表中找到一块足够大的内存空间划分给对象实例。这种方式称为“<strong>空闲列表</strong>”。</p></li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>分配完内存后，为对象中的成员变量赋上初始值，设置对象头信息，调用对象的构造函数方法进行初始化。</p><p>至此，整个对象的创建过程就完成了。</p><h3 id="2-3-对象的访问方式"><a href="#2-3-对象的访问方式" class="headerlink" title="2.3 对象的访问方式"></a>2.3 对象的访问方式</h3><p>所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配的。也就是说在建立一个对象时两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针（引用）而已。 那么根据引用存放的地址类型的不同，对象有不同的访问方式。</p><h4 id="句柄访问方式"><a href="#句柄访问方式" class="headerlink" title="句柄访问方式"></a>句柄访问方式</h4><p>堆中需要有一块叫做“句柄池”的内存空间，句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p><p>引用类型的变量存放的是该对象的句柄地址（reference）。访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址找到对象。</p><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/handle-access.jpg" alt="handle-access"></p><h4 id="直接指针访问方式"><a href="#直接指针访问方式" class="headerlink" title="直接指针访问方式"></a>直接指针访问方式</h4><p>引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。但对象所在的内存空间需要额外的策略存储对象所属的类信息的地址。</p><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/direct-pointer.jpg" alt="direct-pointer"></p><p>需要说明的是，HotSpot 采用第二种方式，即直接指针方式来访问对象，只需要一次寻址操作，所以在性能上比句柄访问方式快一倍。但像上面所说，它需要<strong>额外的策略</strong>来存储对象在方法区中类信息的地址。</p><h2 id="3-垃圾收集策略与算法"><a href="#3-垃圾收集策略与算法" class="headerlink" title="3.垃圾收集策略与算法"></a>3.垃圾收集策略与算法</h2><p>程序计数器、虚拟机栈、本地方法栈随线程而生，也随线程而灭；栈帧随着方法的开始而入栈，随着方法的结束而出栈。这几个区域的内存分配和回收都具有确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p><p>而对于 Java 堆和方法区，我们只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的正是这部分内存。</p><h3 id="3-1-判定对象是否存活"><a href="#3-1-判定对象是否存活" class="headerlink" title="3.1 判定对象是否存活"></a>3.1 判定对象是否存活</h3><p>若一个对象不被任何对象或变量引用，那么它就是无效对象，需要被回收。</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>在对象头维护着一个 counter 计数器，对象被引用一次则计数器 +1；若引用失效则计数器 -1。当计数器为 0 时，就认为该对象无效了。</p><p>引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是主流的 Java 虚拟机里没有选用引用计数算法来管理内存，主要是因为它很难解决对象之间循环引用的问题。</p><blockquote><p>举个栗子 👉 对象 objA 和 objB 都有字段 instance，令 objA.instance = objB 并且 objB.instance = objA，由于它们互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通知 GC 收集器回收它们。</p></blockquote><h4 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h4><p>所有和 GC Roots 直接或间接关联的对象都是有效对象，和 GC Roots 没有关联的对象就是无效对象。</p><p>GC Roots 是指：</p><ul><li>Java 虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中常量引用的对象</li><li>方法区中类静态属性引用的对象</li></ul><p>GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。</p><h3 id="3-2-引用的种类"><a href="#3-2-引用的种类" class="headerlink" title="3.2 引用的种类"></a>3.2 引用的种类</h3><p>判定对象是否存活与“引用”有关。在 JDK 1.2 以前，Java 中的引用定义很传统，一个对象只有被引用或者没有被引用两种状态，我们希望能描述这一类对象：当内存空间还足够时，则保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。</p><p>在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为了以下四种。不同的引用类型，主要体现的是对象不同的可达性状态<code>reachable</code>和垃圾收集的影响。</p><h4 id="强引用（Strong-Reference）"><a href="#强引用（Strong-Reference）" class="headerlink" title="强引用（Strong Reference）"></a>强引用（Strong Reference）</h4><p>类似 “<code>Object obj = new Object()</code>“ 这类的引用，就是强引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。但是，如果我们<strong>错误地保持了强引用</strong>，比如：赋值给了 static 变量，那么对象在很长一段时间内不会被回收，会产生内存泄漏。</p><h4 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h4><p>软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来<strong>实现内存敏感的缓存</strong>，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><h4 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h4><p>弱引用的<strong>强度比软引用更弱</strong>一些。当 JVM 进行垃圾回收时，<strong>无论内存是否充足，都会回收</strong>只被弱引用关联的对象。</p><h4 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h4><p>虚引用也称幽灵引用或者幻影引用，它是<strong>最弱</strong>的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。它仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制。</p><h3 id="3-3-回收堆中无效对象"><a href="#3-3-回收堆中无效对象" class="headerlink" title="3.3 回收堆中无效对象"></a>3.3 回收堆中无效对象</h3><p>对于可达性分析中不可达的对象，也并不是没有存活的可能。</p><h4 id="判定-finalize-是否有必要执行"><a href="#判定-finalize-是否有必要执行" class="headerlink" title="判定 finalize() 是否有必要执行"></a>判定 finalize() 是否有必要执行</h4><p>JVM 会判断此对象是否有必要执行 finalize() 方法，如果对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么视为“没有必要执行”。那么对象基本上就真的被回收了。</p><p>如果对象被判定为有必要执行 finalize() 方法，那么对象会被放入一个 F-Queue 队列中，虚拟机会以较低的优先级执行这些 finalize()方法，但不会确保所有的 finalize() 方法都会执行结束。如果 finalize() 方法出现耗时操作，虚拟机就直接停止指向该方法，将对象清除。</p><h4 id="对象重生或死亡"><a href="#对象重生或死亡" class="headerlink" title="对象重生或死亡"></a>对象重生或死亡</h4><p>如果在执行 finalize() 方法时，将 this 赋给了某一个引用，那么该对象就重生了。如果没有，那么就会被垃圾收集器清除。</p><blockquote><p>任何一个对象的 finalize() 方法只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize() 方法不会被再次执行，想继续在 finalize() 中自救就失效了。</p></blockquote><h3 id="3-3-回收方法区内存"><a href="#3-3-回收方法区内存" class="headerlink" title="3.3 回收方法区内存"></a>3.3 回收方法区内存</h3><p>方法区中存放生命周期较长的类信息、常量、静态变量，每次垃圾收集只有少量的垃圾被清除。方法区中主要清除两种垃圾：</p><ul><li>废弃常量</li><li>无用的类</li></ul><h4 id="判定废弃常量"><a href="#判定废弃常量" class="headerlink" title="判定废弃常量"></a>判定废弃常量</h4><p>只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉。比如，一个字符串 “bingo” 进入了常量池，但是当前系统没有任何一个 String 对象引用常量池中的 “bingo” 常量，也没有其它地方引用这个字面量，必要的话，”bingo”常量会被清理出常量池。</p><h4 id="判定无用的类"><a href="#判定无用的类" class="headerlink" title="判定无用的类"></a>判定无用的类</h4><p>判定一个类是否是“无用的类”，条件较为苛刻。</p><ul><li>该类的所有对象都已经被清除</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><blockquote><p>一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：java.lang.Class。这个对象在类被加载进方法区时创建，在方法区该类被删除时清除。</p></blockquote><h3 id="3-4-垃圾收集算法"><a href="#3-4-垃圾收集算法" class="headerlink" title="3,4 垃圾收集算法"></a>3,4 垃圾收集算法</h3><p>学会了如何判定无效对象、无用类、废弃常量之后，剩余工作就是回收这些垃圾。常见的垃圾收集算法有以下几个：</p><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p><strong>标记</strong>的过程是：遍历所有的 <code>GC Roots</code>，然后将所有 <code>GC Roots</code> 可达的对象<strong>标记为存活的对象</strong>。</p><p><strong>清除</strong>的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。与此同时，清除那些被标记过的对象的标记，以便下次的垃圾回收。</p><p>这种方法有两个<strong>不足</strong>：</p><ul><li>效率问题：标记和清除两个过程的效率都不高。</li><li>空间问题：标记清除之后会产生大量不连续的内存碎片，碎片太多可能导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h4 id="复制算法（新生代）"><a href="#复制算法（新生代）" class="headerlink" title="复制算法（新生代）"></a>复制算法（新生代）</h4><p>为了解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完，需要进行垃圾收集时，就将存活者的对象复制到另一块上面，然后将第一块内存全部清除。这种算法有优有劣：</p><ul><li>优点：不会有内存碎片的问题。</li><li>缺点：内存缩小为原来的一半，浪费空间。</li></ul><p>为了解决空间利用率问题，可以将内存分为三块： Eden、From Survivor、To Survivor，比例是 8:1:1，每次使用 Eden 和其中一块 Survivor。回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费。</p><p>但是我们无法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够，需要依赖其他内存（指老年代）进行分配担保。</p><h4 id="分配担保"><a href="#分配担保" class="headerlink" title="分配担保"></a>分配担保</h4><p>为对象分配内存空间时，如果 Eden+Survivor 中空闲区域无法装下该对象，会触发 MinorGC 进行垃圾收集。但如果 Minor GC 过后依然有超过 10% 的对象存活，这样存活的对象直接通过分配担保机制进入老年代，然后再将新对象存入 Eden 区。</p><h4 id="标记-整理算法（老年代）"><a href="#标记-整理算法（老年代）" class="headerlink" title="标记-整理算法（老年代）"></a>标记-整理算法（老年代）</h4><p><strong>标记</strong>：它的第一个阶段与<strong>标记/清除算法</strong>是一模一样的，均是遍历 <code>GC Roots</code>，然后将存活的对象标记。</p><p><strong>整理</strong>：移动所有<strong>存活的对象</strong>，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。</p><p>这是一种老年代的垃圾收集算法。老年代的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，如果采用复制算法，每次需要复制大量存活的对象，效率很低。</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>根据对象存活周期的不同，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，针对各个年代的特点采用最适当的收集算法。</p><ul><li>新生代：复制算法</li><li>老年代：标记-清除算法、标记-整理算法</li></ul><h2 id="4-HotSpot-垃圾收集器"><a href="#4-HotSpot-垃圾收集器" class="headerlink" title="4.HotSpot 垃圾收集器"></a>4.HotSpot 垃圾收集器</h2><p>HotSpot 虚拟机提供了多种垃圾收集器，每种收集器都有各自的特点，虽然我们要对各个收集器进行比较，但并非为了挑选出一个最好的收集器。我们选择的只是对具体应用最合适的收集器。</p><h3 id="4-1-新生代垃圾收集器"><a href="#4-1-新生代垃圾收集器" class="headerlink" title="4.1 新生代垃圾收集器"></a>4.1 新生代垃圾收集器</h3><h4 id="Serial-垃圾收集器（单线程）"><a href="#Serial-垃圾收集器（单线程）" class="headerlink" title="Serial 垃圾收集器（单线程）"></a>Serial 垃圾收集器（单线程）</h4><p>只开启<strong>一条</strong> GC 线程进行垃圾回收，并且在垃圾收集过程中停止一切用户线程(Stop The World)。</p><p>一般客户端应用所需内存较小，不会创建太多对象，而且堆内存不大，因此垃圾收集器回收时间短，即使在这段时间停止一切用户线程，也不会感觉明显卡顿。因此 Serial 垃圾收集器<strong>适合客户端</strong>使用。</p><p>由于 Serial 收集器只使用一条 GC 线程，避免了线程切换的开销，从而简单高效。</p><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/serial.png" alt="Serial"></p><h4 id="ParNew-垃圾收集器（多线程）"><a href="#ParNew-垃圾收集器（多线程）" class="headerlink" title="ParNew 垃圾收集器（多线程）"></a>ParNew 垃圾收集器（多线程）</h4><p>ParNew 是 Serial 的多线程版本。由多条 GC 线程并行地进行垃圾清理。但清理过程依然需要 Stop The World。</p><p>ParNew 追求“<strong>低停顿时间</strong>”,与 Serial 唯一区别就是使用了多线程进行垃圾收集，在多 CPU 环境下性能比 Serial 会有一定程度的提升；但<strong>线程切换需要额外的开销</strong>，因此在单 CPU 环境中表现不如 Serial。</p><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/parnew.png" alt="ParNew"></p><h4 id="Parallel-Scavenge-垃圾收集器（多线程）"><a href="#Parallel-Scavenge-垃圾收集器（多线程）" class="headerlink" title="Parallel Scavenge 垃圾收集器（多线程）"></a>Parallel Scavenge 垃圾收集器（多线程）</h4><p>Parallel Scavenge 和 ParNew 一样，都是多线程、新生代垃圾收集器。但是两者有巨大的不同点：</p><ul><li>Parallel Scavenge：追求 CPU 吞吐量，能够在较短时间内完成指定任务，因此适合没有交互的后台计算。</li><li>ParNew：追求降低用户停顿时间，适合交互式应用。</li></ul><p>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)</p><p>追求高吞吐量，可以通过减少 GC 执行实际工作的时间，然而，仅仅偶尔运行 GC 意味着每当 GC 运行时将有许多工作要做，因为在此期间积累在堆中的对象数量很高。单个 GC 需要花更多的时间来完成，从而导致更高的暂停时间。而考虑到低暂停时间，最好频繁运行 GC 以便更快速完成，反过来又导致吞吐量下降。</p><ul><li>通过参数 -XX:GCTimeRadio 设置垃圾回收时间占总 CPU 时间的百分比。</li><li>通过参数 -XX:MaxGCPauseMillis 设置垃圾处理过程最久停顿时间。</li><li>通过命令 -XX:+UseAdaptiveSizePolicy 开启自适应策略。我们只要设置好堆的大小和 MaxGCPauseMillis 或 GCTimeRadio，收集器会自动调整新生代的大小、Eden 和 Survivor 的比例、对象进入老年代的年龄，以最大程度上接近我们设置的 MaxGCPauseMillis 或 GCTimeRadio。</li></ul><h3 id="4-2-老年代垃圾收集器"><a href="#4-2-老年代垃圾收集器" class="headerlink" title="4.2 老年代垃圾收集器"></a>4.2 老年代垃圾收集器</h3><h4 id="Serial-Old-垃圾收集器（单线程）"><a href="#Serial-Old-垃圾收集器（单线程）" class="headerlink" title="Serial Old 垃圾收集器（单线程）"></a>Serial Old 垃圾收集器（单线程）</h4><p>Serial Old 收集器是 Serial 的老年代版本，都是单线程收集器，只启用一条 GC 线程，都适合客户端应用。它们唯一的区别就是：Serial Old 工作在老年代，使用“标记-整理”算法；Serial 工作在新生代，使用“复制”算法。</p><h4 id="Parallel-Old-垃圾收集器（多线程）"><a href="#Parallel-Old-垃圾收集器（多线程）" class="headerlink" title="Parallel Old 垃圾收集器（多线程）"></a>Parallel Old 垃圾收集器（多线程）</h4><p>Parallel Old 收集器是 Parallel Scavenge 的老年代版本，追求 CPU 吞吐量。</p><h4 id="CMS-垃圾收集器"><a href="#CMS-垃圾收集器" class="headerlink" title="CMS 垃圾收集器"></a>CMS 垃圾收集器</h4><p>CMS(Concurrent Mark Sweep，并发标记清除)收集器是以获取最短回收停顿时间为目标的收集器（追求低停顿），它在垃圾收集时使得用户线程和 GC 线程并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。</p><ul><li>初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。</li><li>并发标记：使用<strong>多条</strong>标记线程，与用户线程并发执行。此过程进行可达性分析，标记出所有废弃对象。速度很慢。</li><li>重新标记：Stop The World，使用多条标记线程并发执行，将刚才并发标记过程中新出现的废弃对象标记出来。</li><li>并发清除：只使用一条 GC 线程，与用户线程并发执行，清除刚才标记的对象。这个过程非常耗时。</li></ul><p>并发标记与并发清除过程耗时最长，且可以与用户线程一起工作，因此，<strong>总体上说</strong>，CMS 收集器的内存回收过程是与用户线程<strong>一起并发执行</strong>的。</p><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/cms.png" alt="CMS"></p><p>CMS 的缺点：</p><ul><li>吞吐量低</li><li>无法处理浮动垃圾，导致频繁 Full GC</li><li>使用“标记-清除”算法产生碎片空间</li></ul><p>对于产生碎片空间的问题，可以通过开启 -XX:+UseCMSCompactAtFullCollection，在每次 Full GC 完成后都会进行一次内存压缩整理，将零散在各处的对象整理到一块。设置参数 -XX:CMSFullGCsBeforeCompaction 告诉 CMS，经过了 N 次 Full GC 之后再进行一次内存整理。</p><h3 id="4-3-G1-通用垃圾收集器"><a href="#4-3-G1-通用垃圾收集器" class="headerlink" title="4.3 G1 通用垃圾收集器"></a>4.3 G1 通用垃圾收集器</h3><p>G1 是一款面向服务端应用的垃圾收集器，它没有新生代和老年代的概念，而是将堆划分为一块块独立的 Region。当要进行垃圾收集时，首先估计每个 Region 中垃圾的数量，每次都从垃圾回收价值最大的 Region 开始回收，因此可以获得最大的回收效率。</p><p>从整体上看， G1 是基于“标记-整理”算法实现的收集器，从局部（两个 Region 之间）上看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</p><p>这里抛个问题 👇<br><br>一个对象和它内部所引用的对象可能不在同一个 Region 中，那么当垃圾回收时，是否需要扫描整个堆内存才能完整地进行一次可达性分析？</p><p>并不！每个 Region 都有一个 Remembered Set，用于记录本区域中所有对象引用的对象所在的区域，进行可达性分析时，只要在 GC Roots 中再加上 Remembered Set 即可防止对整个堆内存进行遍历。</p><p>如果不计算维护 Remembered Set 的操作，G1 收集器的工作过程分为以下几个步骤：</p><ul><li>初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。</li><li>并发标记：使用<strong>一条</strong>标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢。</li><li>最终标记：Stop The World，使用多条标记线程并发执行。</li><li>筛选回收：回收废弃对象，此时也要 Stop The World，并使用多条筛选回收线程并发执行。</li></ul><h2 id="5-内存分配与回收策略"><a href="#5-内存分配与回收策略" class="headerlink" title="5.内存分配与回收策略"></a>5.内存分配与回收策略</h2><p>对象的内存分配，就是在堆上分配（也可能经过 JIT 编译后被拆散为标量类型并间接在栈上分配），对象主要分配在新生代的 Eden 区上，少数情况下可能直接分配在老年代，<strong>分配规则不固定</strong>，取决于当前使用的垃圾收集器组合以及相关的参数配置。</p><p>以下列举几条最普遍的内存分配规则，供大家学习。</p><h3 id="5-1-对象优先在-Eden-分配"><a href="#5-1-对象优先在-Eden-分配" class="headerlink" title="5.1 对象优先在 Eden 分配"></a>5.1 对象优先在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><p>👇<strong>Minor GC</strong> vs <strong>Major GC</strong>/<strong>Full GC</strong>：</p><ul><li>Minor GC：回收新生代（包括 Eden 和 Survivor 区域），因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li><li>Major GC / Full GC: 回收老年代，出现了 Major GC，经常会伴随至少一次的 Minor GC，但这并非绝对。Major GC 的速度一般会比 Minor GC 慢 10 倍 以上。</li></ul><blockquote><p>在 JVM 规范中，Major GC 和 Full GC 都没有一个正式的定义，所以有人也简单地认为 Major GC 清理老年代，而 Full GC 清理整个内存堆。</p></blockquote><h3 id="5-2-大对象直接进入老年代"><a href="#5-2-大对象直接进入老年代" class="headerlink" title="5.2 大对象直接进入老年代"></a>5.2 大对象直接进入老年代</h3><p>大对象是指需要大量连续内存空间的 Java 对象，如很长的字符串或数据。</p><p>一个大对象能够存入 Eden 区的概率比较小，发生分配担保的概率比较大，而分配担保需要涉及大量的复制，就会造成效率低下。</p><p>虚拟机提供了一个 -XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制。（还记得吗，新生代采用复制算法回收垃圾）</p><h3 id="5-3-长期存活的对象将进入老年代"><a href="#5-3-长期存活的对象将进入老年代" class="headerlink" title="5.3 长期存活的对象将进入老年代"></a>5.3 长期存活的对象将进入老年代</h3><p>JVM 给每个对象定义了一个对象年龄计数器。当新生代发生一次 Minor GC 后，存活下来的对象年龄 +1，当年龄超过一定值时，就将超过该值的所有对象转移到老年代中去。</p><p>使用 <code>-XXMaxTenuringThreshold</code> 设置新生代的最大年龄，只要超过该参数的新生代对象都会被转移到老年代中去。</p><h3 id="5-4-动态对象年龄判定"><a href="#5-4-动态对象年龄判定" class="headerlink" title="5.4 动态对象年龄判定"></a>5.4 动态对象年龄判定</h3><p>如果当前新生代的 Survivor 中，相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄 &gt;= 该年龄的对象就可以直接进入老年代，无须等到 <code>MaxTenuringThreshold</code> 中要求的年龄。</p><h3 id="5-5-空间分配担保"><a href="#5-5-空间分配担保" class="headerlink" title="5.5 空间分配担保"></a>5.5 空间分配担保</h3><p>JDK 6 Update 24 之前的规则是这样的：<br> 在发生 Minor GC 之前，虚拟机会先检查<strong>老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>， 如果这个条件成立，Minor GC 可以确保是安全的； 如果不成立，则虚拟机会查看 <code>HandlePromotionFailure</code> 值是否设置为允许担保失败， 如果是，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于，将尝试进行一次 Minor GC,尽管这次 Minor GC 是有风险的； 如果小于，或者 <code>HandlePromotionFailure</code> 设置不允许冒险，那此时也要改为进行一次 Full GC。</p><p>JDK 6 Update 24 之后的规则变为：<br> 只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p><p>通过清除老年代中废弃数据来扩大老年代空闲空间，以便给新生代作担保。</p><p>这个过程就是分配担保。</p><hr><p>👇 总结一下有哪些情况可能会触发 JVM 进行 Full GC。</p><ol><li><strong><code>System.gc()</code> 方法的调用</strong><br>此方法的调用是建议 JVM 进行 Full GC，注意这<strong>只是建议而非一定</strong>，但在很多情况下它会触发 Full GC，从而增加 Full GC 的频率。通常情况下我们只需要让虚拟机自己去管理内存即可，我们可以通过 -XX:+ DisableExplicitGC 来禁止调用 <code>System.gc()</code>。</li><li><strong>老年代空间不足</strong><br>老年代空间不足会触发 Full GC 操作，若进行该操作后空间依然不足，则会抛出如下错误：<code>java.lang.OutOfMemoryError: Java heap space</code></li><li><strong>永久代空间不足</strong><br>JVM 规范中运行时数据区域中的方法区，在 HotSpot 虚拟机中也称为永久代（Permanet Generation），存放一些类信息、常量、静态变量等数据，当系统要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，会触发 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出如下错误信息：<code>java.lang.OutOfMemoryError: PermGen space</code></li><li><strong>CMS GC 时出现 <code>promotion failed</code> 和 <code>concurrent mode failure</code></strong><br>promotion failed，就是上文所说的担保失败，而 concurrent mode failure 是在执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足造成的。</li><li><strong>统计得到的 Minor GC 晋升到旧生代的平均大小大于老年代的剩余空间。</strong># JVM 性能调优</li></ol><p>在高性能硬件上部署程序，目前主要有两种方式：</p><ul><li>通过 64 位 JDK 来使用大内存；</li><li>使用若干个 32 位虚拟机建立逻辑集群来利用硬件资源。</li></ul><h3 id="5-6-使用-64-位-JDK-管理大内存"><a href="#5-6-使用-64-位-JDK-管理大内存" class="headerlink" title="5.6 使用 64 位 JDK 管理大内存"></a>5.6 使用 64 位 JDK 管理大内存</h3><p>堆内存变大后，虽然垃圾收集的频率减少了，但每次垃圾回收的时间变长。 如果堆内存为 14 G，那么每次 Full GC 将长达数十秒。如果 Full GC 频繁发生，那么对于一个网站来说是无法忍受的。</p><p>对于用户交互性强、对停顿时间敏感的系统，可以给 Java 虚拟机分配超大堆的前提是有把握把应用程序的 Full GC 频率控制得足够低，至少要低到不会影响用户使用。</p><p>可能面临的问题：</p><ul><li>内存回收导致的长时间停顿；</li><li>现阶段，64 位 JDK 的性能普遍比 32 位 JDK 低；</li><li>需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照（因为要产生超过 10GB 的 Dump 文件），哪怕产生了快照也几乎无法进行分析；</li><li>相同程序在 64 位 JDK 消耗的内存一般比 32 位 JDK 大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的。</li></ul><h3 id="5-7-使用-32-位-JVM-建立逻辑集群"><a href="#5-7-使用-32-位-JVM-建立逻辑集群" class="headerlink" title="5.7 使用 32 位 JVM 建立逻辑集群"></a>5.7 使用 32 位 JVM 建立逻辑集群</h3><p>在一台物理机器上启动多个应用服务器进程，每个服务器进程分配不同端口， 然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。</p><p>考虑到在一台物理机器上建立逻辑集群的目的仅仅是为了尽可能利用硬件资源，并不需要关心状态保留、热转移之类的高可用性能需求， 也不需要保证每个虚拟机进程有绝对的均衡负载，因此使用无 Session 复制的亲合式集群是一个不错的选择。 我们仅仅需要保障集群具备亲合性，也就是均衡器按一定的规则算法（一般根据 SessionID 分配） 将一个固定的用户请求永远分配到固定的一个集群节点进行处理即可。</p><p>可能遇到的问题：</p><ul><li>尽量避免节点竞争全局资源，如磁盘竞争，各个节点如果同时访问某个磁盘文件的话，很可能导致 IO 异常；</li><li>很难高效利用资源池，如连接池，一般都是在节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余；</li><li>各个节点受到 32 位的内存限制；</li><li>大量使用本地缓存的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点都有一份缓存，这时候可以考虑把本地缓存改成集中式缓存。</li></ul><h3 id="5-8-调优案例分析与实战"><a href="#5-8-调优案例分析与实战" class="headerlink" title="5.8 调优案例分析与实战"></a>5.8 调优案例分析与实战</h3><h4 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h4><p>一个小型系统，使用 32 位 JDK，4G 内存，测试期间发现服务端不定时抛出内存溢出异常。 加入 -XX:+HeapDumpOnOutOfMemoryError（添加这个参数后，堆内存溢出时就会输出异常日志）， 但再次发生内存溢出时，没有生成相关异常日志。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>在 32 位 JDK 上，1.6G 分配给堆，还有一部分分配给 JVM 的其他内存，直接内存最大也只能在剩余的 0.4G 空间中分出一部分， 如果使用了 NIO，JVM 会在 JVM 内存之外分配内存空间，那么就要小心“直接内存”不足时发生内存溢出异常了。</p><h4 id="直接内存的回收过程"><a href="#直接内存的回收过程" class="headerlink" title="直接内存的回收过程"></a>直接内存的回收过程</h4><p>直接内存虽然不是 JVM 内存空间，但它的垃圾回收也由 JVM 负责。</p><p>垃圾收集进行时，虚拟机虽然会对直接内存进行回收， 但是直接内存却不能像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收， 它只能等老年代满了后 Full GC，然后“顺便”帮它清理掉内存的废弃对象。 否则只能一直等到抛出内存溢出异常时，先 catch 掉，再在 catch 块里大喊 “<code>System.gc()</code>”。 要是虚拟机还是不听，那就只能眼睁睁看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。</p><h2 id="6-类文件结构"><a href="#6-类文件结构" class="headerlink" title="6.类文件结构"></a>6.类文件结构</h2><h3 id="6-1-JVM-的“无关性”"><a href="#6-1-JVM-的“无关性”" class="headerlink" title="6.1 JVM 的“无关性”"></a>6.1 JVM 的“无关性”</h3><p>谈论 JVM 的无关性，主要有以下两个：</p><ul><li>平台无关性：任何操作系统都能运行 Java 代码</li><li>语言无关性： JVM 能运行除 Java 以外的其他代码</li></ul><p>Java 源代码首先需要使用 Javac 编译器编译成 .class 文件，然后由 JVM 执行 .class 文件，从而程序开始运行。</p><p>JVM 只认识 .class 文件，它不关心是何种语言生成了 .class 文件，只要 .class 文件符合 JVM 的规范就能运行。 目前已经有 JRuby、Jython、Scala 等语言能够在 JVM 上运行。它们有各自的语法规则，不过它们的编译器 都能将各自的源码编译成符合 JVM 规范的 .class 文件，从而能够借助 JVM 运行它们。</p><blockquote><p>Java 语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的， 因此字节码命令所能提供的语义描述能力肯定会比 Java 语言本身更加强大。 因此，有一些 Java 语言本身无法有效支持的语言特性，不代表字节码本身无法有效支持。</p></blockquote><h3 id="6-2-Class-文件结构"><a href="#6-2-Class-文件结构" class="headerlink" title="6.2 Class 文件结构"></a>6.2 Class 文件结构</h3><p>Class 文件是二进制文件，它的内容具有严格的规范，文件中没有任何空格，全都是连续的 0/1。Class 文件 中的所有内容被分为两种类型：无符号数、表。</p><ul><li>无符号数 无符号数表示 Class 文件中的值，这些值没有任何类型，但有不同的长度。u1、u2、u4、u8 分别代表 1/2/4/8 字节的无符号数。</li><li>表 由多个无符号数或者其他表作为数据项构成的复合数据类型。</li></ul><p>Class 文件具体由以下几个构成:</p><ul><li>魔数</li><li>版本信息</li><li>常量池</li><li>访问标志</li><li>类索引、父类索引、接口索引集合</li><li>字段表集合</li><li>方法表集合</li><li>属性表集合</li></ul><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>Class 文件的头 4 个字节称为魔数，用来表示这个 Class 文件的类型。</p><p>Class 文件的魔数是用 16 进制表示的“CAFE BABE”，是不是很具有浪漫色彩？</p><blockquote><p>魔数相当于文件后缀名，只不过后缀名容易被修改，不安全，因此在 Class 文件中标识文件类型比较合适。</p></blockquote><h4 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h4><p>紧接着魔数的 4 个字节是版本信息，5-6 字节表示次版本号，7-8 字节表示主版本号，它们表示当前 Class 文件中使用的是哪个版本的 JDK。</p><p>高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件，即使文件格式并未发生任何变化，虚拟机也必需拒绝执行超过其版本号的 Class 文件。</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>版本信息之后就是常量池，常量池中存放两种类型的常量：</p><ul><li><p>字面值常量</p><p>字面值常量就是我们在程序中定义的字符串、被 final 修饰的值。</p></li><li><p>符号引用</p><p>符号引用就是我们定义的各种名字：类和接口的全限定名、字段的名字和描述符、方法的名字和描述符。</p></li></ul><h5 id="常量池的特点"><a href="#常量池的特点" class="headerlink" title="常量池的特点"></a>常量池的特点</h5><ul><li>常量池中常量数量不固定，因此常量池开头放置一个 u2 类型的无符号数，用来存储当前常量池的容量。</li><li>常量池的每一项常量都是一个表，表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量属于哪种常量类型。</li></ul><h5 id="常量池中常量类型"><a href="#常量池中常量类型" class="headerlink" title="常量池中常量类型"></a>常量池中常量类型</h5><table><thead><tr><th>类型</th><th>tag</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_utf8_info</td><td>1</td><td>UTF-8 编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>标识方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><p>对于 CONSTANT_Class_info（此类型的常量代表一个类或者接口的符号引用），它的二维表结构如下：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u1</td><td>tag</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr></tbody></table><p>tag 是标志位，用于区分常量类型；name_index 是一个索引值，它指向常量池中一个 CONSTANT_Utf8_info 类型常量，此常量代表这个类（或接口）的全限定名，这里 name_index 值若为 0x0002，也即是指向了常量池中的第二项常量。</p><p>CONSTANT_Utf8_info 型常量的结构如下：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u1</td><td>tag</td><td>1</td></tr><tr><td>u2</td><td>length</td><td>1</td></tr><tr><td>u1</td><td>bytes</td><td>length</td></tr></tbody></table><p>tag 是当前常量的类型；length 表示这个字符串的长度；bytes 是这个字符串的内容（采用缩略的 UTF8 编码）</p><h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否被 abstract/final 修饰。</p><h4 id="类索引、父类索引、接口索引集合"><a href="#类索引、父类索引、接口索引集合" class="headerlink" title="类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h4><p>类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</p><p>由于 Java 不允许多重继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。一个类可能实现了多个接口，因此用接口索引集合来描述。这个集合第一项为 u2 类型的数据，表示索引表的容量，接下来就是接口的名字索引。</p><p>类索引和父类索引用两个 u2 类型的索引值表示，它们各自指向一个类型为 CONSTANT_Class_info 的类描述符常量，通过该常量总的索引值可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串。</p><h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><p>字段表集合存储本类涉及到的成员变量，包括实例变量和类变量，但不包括方法中的局部变量。</p><p>每一个字段表只表示一个成员变量，本类中的所有成员变量构成了字段表集合。字段表结构如下：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>说明</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td><td>字段的访问标志，与类稍有不同</td></tr><tr><td>u2</td><td>name_index</td><td>1</td><td>字段名字的索引</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td><td>描述符，用于描述字段的数据类型。 基本数据类型用大写字母表示； 对象类型用“L 对象类型的全限定名”表示。</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td><td>属性表集合的长度</td></tr><tr><td>u2</td><td>attributes</td><td>attributes_count</td><td>属性表集合，用于存放属性的额外信息，如属性的值。</td></tr></tbody></table><blockquote><p>字段表集合中不会出现从父类（或接口）中继承而来的字段，但有可能出现原本 Java 代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</p></blockquote><h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><p>方法表结构与属性表类似。</p><p>volatile 关键字 和 transient 关键字不能修饰方法，所以方法表的访问标志中没有 ACC_VOLATILE 和 ACC_TRANSIENT 标志。</p><p>方法表的属性表集合中有一张 Code 属性表，用于存储当前方法经编译器编译后的字节码指令。</p><h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><p>每个属性对应一张属性表，属性表的结构如下：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u1</td><td>info</td><td>attribute_length</td></tr></tbody></table><h2 id="7-类加载的时机"><a href="#7-类加载的时机" class="headerlink" title="7.类加载的时机"></a>7.类加载的时机</h2><h3 id="7-1-类的生命周期"><a href="#7-1-类的生命周期" class="headerlink" title="7.1 类的生命周期"></a>7.1 类的生命周期</h3><p>类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括以下 7 个阶段：</p><ul><li>加载</li><li>验证</li><li>准备</li><li>解析</li><li>初始化</li><li>使用</li><li>卸载</li></ul><p>验证、准备、解析 3 个阶段统称为连接。</p><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/loadclass.png" alt="Load Class"></p><p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始（注意是“开始”，而不是“进行”或“完成”），而解析阶段则不一定：它在某些情况下可以在初始化后再开始，这是为了支持 Java 语言的运行时绑定。</p><h3 id="7-2-类加载过程中“初始化”开始的时机"><a href="#7-2-类加载过程中“初始化”开始的时机" class="headerlink" title="7.2 类加载过程中“初始化”开始的时机"></a>7.2 类加载过程中“初始化”开始的时机</h3><p>Java 虚拟机规范没有强制约束类加载过程的第一阶段（即：加载）什么时候开始，但对于“初始化”阶段，有着严格的规定。有且仅有 5 种情况必须立即对类进行“初始化”：</p><ul><li>在遇到 new、putstatic、getstatic、invokestatic 字节码指令时，如果类尚未初始化，则需要先触发其初始化。</li><li>对类进行反射调用时，如果类还没有初始化，则需要先触发其初始化。</li><li>初始化一个类时，如果其父类还没有初始化，则需要先初始化父类。</li><li>虚拟机启动时，用于需要指定一个包含 <code>main()</code> 方法的主类，虚拟机会先初始化这个主类。</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。</li></ul><p>这 5 种场景中的行为称为对一个类进行<strong>主动引用</strong>，除此之外，其它所有引用类的方式都不会触发初始化，称为<strong>被动引用</strong>。</p><h3 id="7-3-被动引用演示-Demo"><a href="#7-3-被动引用演示-Demo" class="headerlink" title="7.3 被动引用演示 Demo"></a>7.3 被动引用演示 Demo</h3><h4 id="Demo1"><a href="#Demo1" class="headerlink" title="Demo1"></a>Demo1</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 被动引用 Demo1: * 通过子类引用父类的静态字段，不会导致子类初始化。 * * @author ylb * */</span><span class="token keyword">class</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SuperClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SubClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SubClass<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// SuperClass init!</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><h4 id="Demo2"><a href="#Demo2" class="headerlink" title="Demo2"></a>Demo2</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 被动引用 Demo2: * 通过数组定义来引用类，不会触发此类的初始化。 * * @author ylb * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SuperClass<span class="token punctuation">[</span><span class="token punctuation">]</span> superClasses <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperClass</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码不会触发父类的初始化，但会触发“[L 全类名”这个类的初始化，它由虚拟机自动生成，直接继承自 java.lang.Object，创建动作由字节码指令 newarray 触发。</p><h4 id="Demo3"><a href="#Demo3" class="headerlink" title="Demo3"></a>Demo3</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 被动引用 Demo3: * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 * * @author ylb * */</span><span class="token keyword">class</span> <span class="token class-name">ConstClass</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConstClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String HELLO_BINGO <span class="token operator">=</span> <span class="token string">"Hello Bingo"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ConstClass<span class="token punctuation">.</span>HELLO_BINGO<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>编译通过之后，常量存储到 NotInitialization 类的常量池中，NotInitialization 的 Class 文件中并没有 ConstClass 类的符号引用入口，这两个类在编译成 Class 之后就没有任何联系了。</p><h3 id="7-4-接口的加载过程"><a href="#7-4-接口的加载过程" class="headerlink" title="7.4 接口的加载过程"></a>7.4 接口的加载过程</h3><p>接口加载过程与类加载过程稍有不同。</p><p>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。</p><h3 id="7-5-类加载的过程"><a href="#7-5-类加载的过程" class="headerlink" title="7.5 类加载的过程"></a>7.5 类加载的过程</h3><p>类加载过程包括 5 个阶段：加载、验证、准备、解析和初始化。</p><h3 id="7-6-加载"><a href="#7-6-加载" class="headerlink" title="7.6 加载"></a>7.6 加载</h3><h4 id="加载的过程"><a href="#加载的过程" class="headerlink" title="加载的过程"></a>加载的过程</h4><p>“加载”是“类加载”过程的一个阶段，不能混淆这两个名词。在加载阶段，虚拟机需要完成 3 件事：</p><ul><li>通过类的全限定名获取该类的二进制字节流。</li><li>将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。</li><li>在内存中创建一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li></ul><h4 id="获取二进制字节流"><a href="#获取二进制字节流" class="headerlink" title="获取二进制字节流"></a>获取二进制字节流</h4><p>对于 Class 文件，虚拟机没有指明要从哪里获取、怎样获取。除了直接从编译好的 .class 文件中读取，还有以下几种方式：</p><ul><li>从 zip 包中读取，如 jar、war 等</li><li>从网络中获取，如 Applet</li><li>通过动态代理技术生成代理类的二进制字节流</li><li>由 JSP 文件生成对应的 Class 类</li><li>从数据库中读取，如 有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li></ul><h4 id="“非数组类”与“数组类”加载比较"><a href="#“非数组类”与“数组类”加载比较" class="headerlink" title="“非数组类”与“数组类”加载比较"></a>“非数组类”与“数组类”加载比较</h4><ul><li>非数组类加载阶段可以使用系统提供的引导类加载器，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器控制字节流的获取方式（如重写一个类加载器的 <code>loadClass()</code> 方法）</li><li>数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的，再由类加载器创建数组中的元素类。</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>虚拟机规范未规定 Class 对象的存储位置，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但存放在方法区中。</li><li>加载阶段与连接阶段的部分内容交叉进行，加载阶段尚未完成，连接阶段可能已经开始了。但这两个阶段的开始时间仍然保持着固定的先后顺序。</li></ul><h3 id="7-7-验证"><a href="#7-7-验证" class="headerlink" title="7.7 验证"></a>7.7 验证</h3><h4 id="验证的重要性"><a href="#验证的重要性" class="headerlink" title="验证的重要性"></a>验证的重要性</h4><p>验证阶段确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><h4 id="验证的过程"><a href="#验证的过程" class="headerlink" title="验证的过程"></a>验证的过程</h4><ul><li>文件格式验证 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下：<ul><li>是否以魔数 0XCAFEBABE 开头</li><li>主次版本号是否在当前虚拟机处理范围内</li><li>常量池是否有不被支持的常量类型</li><li>指向常量的索引值是否指向了不存在的常量</li><li>CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据</li><li>……</li></ul></li><li>元数据验证 对字节码描述信息进行语义分析，确保其符合 Java 语法规范。</li><li>字节码验证 本阶段是验证过程中最复杂的一个阶段，是对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。</li><li>符号引用验证 本阶段发生在解析阶段，确保解析正常执行。</li></ul><h3 id="7-8-准备"><a href="#7-8-准备" class="headerlink" title="7.8 准备"></a>7.8 准备</h3><p>准备阶段是正式为类变量（或称“静态成员变量”）分配内存并设置初始值的阶段。这些变量（不包括实例变量）所使用的内存都在方法区中进行分配。</p><p>初始值“通常情况下”是数据类型的零值（0, null…），假设一个类变量的定义为：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></code></pre><p>那么变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法。</p><p>存在“特殊情况”：如果类字段的字段属性表中存在 ConstantValue 属性，那么在准备阶段 value 就会被初始化为 ConstantValue 属性所指定的值，假设上面类变量 value 的定义变为：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></code></pre><p>那么在准备阶段虚拟机会根据 ConstantValue 的设置将 value 赋值为 123。</p><h3 id="7-9-解析"><a href="#7-9-解析" class="headerlink" title="7.9 解析"></a>7.9 解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><h3 id="7-10-初始化"><a href="#7-10-初始化" class="headerlink" title="7.10 初始化"></a>7.10 初始化</h3><p>类初始化阶段是类加载过程的最后一步，是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。</p><p><code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。</p><p>静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。如下方代码所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 给变量赋值可以正常编译通过</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 这句编译器会提示“非法向前引用”</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>&lt;clinit&gt;()</code> 方法不需要显式调用父类构造器，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</p><p>由于父类的 <code>&lt;clinit&gt;()</code> 方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。如下方代码所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        A <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> B <span class="token operator">=</span> A<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Sub<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 2</span><span class="token punctuation">}</span></code></pre><p><code>&lt;clinit&gt;()</code> 方法不是必需的，如果一个类没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成 <code>&lt;clinit&gt;()</code> 方法。</p><p>接口中不能使用静态代码块，但接口也需要通过 <code>&lt;clinit&gt;()</code> 方法为接口中定义的静态成员变量显式初始化。但接口与类不同，接口的 <code>&lt;clinit&gt;()</code> 方法不需要先执行父类的 <code>&lt;clinit&gt;()</code> 方法，只有当父接口中定义的变量使用时，父接口才会初始化。</p><p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> 方法。</p><h2 id="8-类加载器"><a href="#8-类加载器" class="headerlink" title="8.类加载器"></a>8.类加载器</h2><h3 id="8-1-类与类加载器"><a href="#8-1-类与类加载器" class="headerlink" title="8.1 类与类加载器"></a>8.1 类与类加载器</h3><h4 id="判断类是否“相等”"><a href="#判断类是否“相等”" class="headerlink" title="判断类是否“相等”"></a>判断类是否“相等”</h4><p>任意一个类，都由<strong>加载它的类加载器</strong>和这个<strong>类本身</strong>一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都有一个独立的类名称空间。</p><p>因此，比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类就必定不相等。</p><p>这里的“相等”，包括代表类的 Class 对象的 <code>equals()</code> 方法、<code>isInstance()</code> 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。</p><h4 id="加载器种类"><a href="#加载器种类" class="headerlink" title="加载器种类"></a>加载器种类</h4><p>系统提供了 3 种类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader）： 负责将存放在 <code>&lt;JAVA_HOME&gt;\lib</code> 目录中的，并且能被虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。</li><li>扩展类加载器（Extension ClassLoader）： 负责加载 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录中的所有类库，开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器（Application ClassLoader）： 由于这个类加载器是 ClassLoader 中的 <code>getSystemClassLoader()</code> 方法的返回值，所以一般也称它为“系统类加载器”。它负责加载用户类路径（classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/classloader.png" alt="ClassLoader"></p><p>当然，如果有必要，还可以加入自己定义的类加载器。</p><h3 id="8-2-双亲委派模型"><a href="#8-2-双亲委派模型" class="headerlink" title="8.2 双亲委派模型"></a>8.2 双亲委派模型</h3><h4 id="什么是双亲委派模型"><a href="#什么是双亲委派模型" class="headerlink" title="什么是双亲委派模型"></a>什么是双亲委派模型</h4><p>双亲委派模型是描述类加载器之间的层次关系。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码）</p><h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。</p><p>在 java.lang.ClassLoader 中的 <code>loadClass</code> 方法中实现该过程。</p><h4 id="为什么使用双亲委派模型"><a href="#为什么使用双亲委派模型" class="headerlink" title="为什么使用双亲委派模型"></a>为什么使用双亲委派模型</h4><p>像 java.lang.Object 这些存放在 rt.jar 中的类，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的 Object 类都是同一个。</p><p>相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在 classpath 下，那么系统将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客框架使用简介</title>
      <link href="2018/09/07/hexo-intro/"/>
      <url>2018/09/07/hexo-intro/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/post_banner_jay.png" alt=""></p><h1 id="Hexo-博客框架"><a href="#Hexo-博客框架" class="headerlink" title="Hexo 博客框架"></a>Hexo 博客框架</h1><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="1-主题：hexo-theme-matery"><a href="#1-主题：hexo-theme-matery" class="headerlink" title="1. 主题：hexo-theme-matery"></a>1. 主题：hexo-theme-matery</h2><p>matery 这是一个采用 <code>Material Design</code> 和响应式设计的 Hexo 博客主题。</p><h3 id="1-1-特性"><a href="#1-1-特性" class="headerlink" title="1.1 特性"></a>1.1 特性</h3><ul><li><p>简单漂亮，文章内容美观易读</p></li><li><p><a href="https://material.io/" target="_blank" rel="noopener">Material Design</a> 设计</p></li><li><p>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</p></li><li><p>首页轮播文章及每天动态切换 <code>Banner</code> 图片</p></li><li><p>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</p></li><li><p>时间轴式的归档页</p></li><li><p><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</p></li><li><p>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</p></li><li><p>可自定义的数据的友情链接页面</p></li><li><p>支持文章置顶和文章打赏</p></li><li><p>支持 <code>MathJax</code></p></li><li><p><code>TOC</code> 目录</p></li><li><p>可设置复制文章内容时追加版权信息</p></li><li><p>可设置阅读文章时做密码验证</p></li><li><p><a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk</a>、<a href="https://imsun.github.io/gitment/" target="_blank" rel="noopener">Gitment</a>、<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> 和 <a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</p></li><li><p>集成了<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</p></li><li><p>支持在首页的音乐播放和视频播放功能</p></li><li><p>支持<code>emoji</code>表情，用<code>markdown emoji</code>语法书写直接生成对应的能<strong>跳跃</strong>的表情。</p></li><li><p>支持 <a href="http://www.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a>、<a href="https://www.tidio.com/" target="_blank" rel="noopener">Tidio</a> 在线聊天功能。</p></li></ul><h3 id="1-2-下载"><a href="#1-2-下载" class="headerlink" title="1.2 下载"></a>1.2 下载</h3><p>当你看到这里的时候，应该已经有一个自己的 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 博客了。如果还没有的话，不妨使用 Hexo 和 <a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown</a> 来写博客和文章。</p><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master" target="_blank" rel="noopener">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可。</p><p>当然你也可以在你的 <code>themes</code> 文件夹下使用 <code>Git clone</code> 命令来下载:</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre><h3 id="1-3-配置"><a href="#1-3-配置" class="headerlink" title="1.3 配置"></a>1.3 配置</h3><h4 id="1-3-1-切换主题"><a href="#1-3-1-切换主题" class="headerlink" title="1.3.1 切换主题"></a>1.3.1 切换主题</h4><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的  <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><p><code>_config.yml</code> 文件的其它修改建议:</p><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h4 id="1-3-2-新建分类-categories-页"><a href="#1-3-2-新建分类-categories-页" class="headerlink" title="1.3.2 新建分类 categories 页"></a>1.3.2 新建分类 categories 页</h4><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span></code></pre><h4 id="1-3-3-新建标签-tags-页"><a href="#1-3-3-新建标签-tags-页" class="headerlink" title="1.3.3 新建标签 tags 页"></a>1.3.3 新建标签 tags 页</h4><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span></code></pre><h4 id="1-3-4-新建关于我-about-页"><a href="#1-3-4-新建关于我-about-页" class="headerlink" title="1.3.4 新建关于我 about 页"></a>1.3.4 新建关于我 about 页</h4><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"about"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token punctuation">---</span></code></pre><h4 id="1-3-5-新建留言板-contact-页（可选的）"><a href="#1-3-5-新建留言板-contact-页（可选的）" class="headerlink" title="1.3.5 新建留言板 contact 页（可选的）"></a>1.3.5 新建留言板 contact 页（可选的）</h4><p><code>contact</code> 页是用来展示<strong>留言板</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>contact/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"contact"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/contact/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> contact<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"contact"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"contact"</span><span class="token punctuation">---</span></code></pre><blockquote><p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p></blockquote><h4 id="1-3-6-新建友情链接-friends-页（可选的）"><a href="#1-3-6-新建友情链接-friends-页（可选的）" class="headerlink" title="1.3.6 新建友情链接 friends 页（可选的）"></a>1.3.6 新建友情链接 friends 页（可选的）</h4><p><code>friends</code> 页是用来展示<strong>友情链接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"friends"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> friends<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-12-12 21:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token punctuation">---</span></code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"码酱"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"我不是大佬，只是在追寻大佬的脚步"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://luokangyuan.com/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/4027734.jpeg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"闪烁之狐"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://blinkfox.github.io/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ja_rome"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"平凡的脚步也可以走出伟大的行程"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://me.csdn.net/jlh912008548"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><h4 id="1-3-7-新建-404-页"><a href="#1-3-7-新建-404-页" class="headerlink" title="1.3.7 新建 404 页"></a>1.3.7 新建 404 页</h4><p>如果在你的博客 <code>source</code> 目录下还没有 <code>404.md</code> 文件，那么你就需要新建一个</p><p>编辑你刚刚新建的页面文件 <code>/source/404.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> <span class="token number">404</span><span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"404"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"404"</span><span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"Oops～，我崩溃了！找不到你想要的页面 :("</span><span class="token punctuation">---</span></code></pre><h4 id="1-3-8-菜单导航配置"><a href="#1-3-8-菜单导航配置" class="headerlink" title="1.3.8 菜单导航配置"></a>1.3.8 菜单导航配置</h4><p>配置基本菜单导航的名称、路径url和图标icon.</p><p>1.菜单导航名称可以是中文也可以是英文(如：<code>Index</code>或<code>主页</code>)<br>2.图标icon 可以在<a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a> 中查找   </p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>  <span class="token key atrule">Index</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>home  <span class="token key atrule">Tags</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /tags    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>tags  <span class="token key atrule">Categories</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /categories    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>bookmark  <span class="token key atrule">Archives</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /archives    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>archive  <span class="token key atrule">About</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /about    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>user<span class="token punctuation">-</span>circle  <span class="token key atrule">Friends</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /friends    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>address<span class="token punctuation">-</span>book</code></pre><h4 id="1-3-9-二级菜单配置方法"><a href="#1-3-9-二级菜单配置方法" class="headerlink" title="1.3.9 二级菜单配置方法"></a>1.3.9 二级菜单配置方法</h4><p>如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作<br>1.在需要添加二级菜单的一级菜单下添加<code>children</code>关键字(如:<code>About</code>菜单下添加<code>children</code>)<br>2.在<code>children</code>下创建二级菜单的 名称name,路径url和图标icon.<br>3.注意每个二级菜单模块前要加 <code>-</code>.<br>4.注意缩进格式  </p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>  <span class="token key atrule">Index</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>home  <span class="token key atrule">Tags</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /tags    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>tags  <span class="token key atrule">Categories</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /categories    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>bookmark  <span class="token key atrule">Archives</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /archives    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>archive  <span class="token key atrule">About</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /about    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>user<span class="token punctuation">-</span>circle<span class="token punctuation">-</span>o  <span class="token key atrule">Friends</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /friends    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>address<span class="token punctuation">-</span>book  <span class="token key atrule">Medias</span><span class="token punctuation">:</span>    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>list    <span class="token key atrule">children</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Musics        <span class="token key atrule">url</span><span class="token punctuation">:</span> /musics        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>music      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Movies        <span class="token key atrule">url</span><span class="token punctuation">:</span> /movies        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>film      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Books        <span class="token key atrule">url</span><span class="token punctuation">:</span> /books        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>book      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Galleries        <span class="token key atrule">url</span><span class="token punctuation">:</span> /galleries        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>image</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中对应位置看到你用<code>emoji</code>语法写的表情了。</p><h4 id="1-3-10-代码高亮"><a href="#1-3-10-代码高亮" class="headerlink" title="1.3.10 代码高亮"></a>1.3.10 代码高亮</h4><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i -S hexo-prism-plugin</code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prism_plugin</span><span class="token punctuation">:</span>  <span class="token key atrule">mode</span><span class="token punctuation">:</span> <span class="token string">'preprocess'</span>    <span class="token comment" spellcheck="true"># realtime/preprocess</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'tomorrow'</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">false    </span><span class="token comment" spellcheck="true"># default false</span>  custom_css<span class="token punctuation">:</span></code></pre><h4 id="1-3-11-搜索"><a href="#1-3-11-搜索" class="headerlink" title="1.3.11 搜索"></a>1.3.11 搜索</h4><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post</code></pre><h4 id="1-3-12-中文链接转拼音（建议安装）"><a href="#1-3-12-中文链接转拼音（建议安装）" class="headerlink" title="1.3.12 中文链接转拼音（建议安装）"></a>1.3.12 中文链接转拼音（建议安装）</h4><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment" spellcheck="true"># default: '-'</span></code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h4 id="1-3-13-文章字数统计插件（建议安装）"><a href="#1-3-13-文章字数统计插件（建议安装）" class="headerlink" title="1.3.13 文章字数统计插件（建议安装）"></a>1.3.13 文章字数统计插件（建议安装）</h4><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i --save hexo-wordcount</code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">postInfo</span><span class="token punctuation">:</span>  <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">update</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">wordCount</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 设置文章字数统计为 true.</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 设置站点文章总字数统计为 true.</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 阅读时长.</span>  <span class="token key atrule">readCount</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 阅读次数.</span></code></pre><h4 id="1-3-14-添加emoji表情支持（可选的）"><a href="#1-3-14-添加emoji表情支持（可选的）" class="headerlink" title="1.3.14 添加emoji表情支持（可选的）"></a>1.3.14 添加emoji表情支持（可选的）</h4><p>本主题新增了对<code>emoji</code>表情的支持，使用到了 <a href="https://npm.taobao.org/package/hexo-filter-github-emojis" target="_blank" rel="noopener">hexo-filter-github-emojis</a> 的 Hexo 插件来支持 <code>emoji</code>表情的生成，把对应的<code>markdown emoji</code>语法（<code>::</code>,例如：<code>:smile:</code>）转变成会跳跃的<code>emoji</code>表情，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-filter-github-emojis --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">githubEmojis</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">className</span><span class="token punctuation">:</span> github<span class="token punctuation">-</span>emoji  <span class="token key atrule">inject</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">styles</span><span class="token punctuation">:</span>  customEmojis<span class="token punctuation">:</span></code></pre><h4 id="1-3-15-添加-RSS-订阅支持（可选的）"><a href="#1-3-15-添加-RSS-订阅支持（可选的）" class="headerlink" title="1.3.15 添加 RSS 订阅支持（可选的）"></a>1.3.15 添加 RSS 订阅支持（可选的）</h4><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">' '</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h4 id="1-3-16-添加-DaoVoice-在线聊天功能（可选的）"><a href="#1-3-16-添加-DaoVoice-在线聊天功能（可选的）" class="headerlink" title="1.3.16 添加 DaoVoice 在线聊天功能（可选的）"></a>1.3.16 添加 <a href="http://www.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a> 在线聊天功能（可选的）</h4><p>前往 <a href="http://www.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a> 官网注册并且获取 <code>app_id</code>，并将 <code>app_id</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h4 id="1-3-17-添加-Tidio-在线聊天功能（可选的）"><a href="#1-3-17-添加-Tidio-在线聊天功能（可选的）" class="headerlink" title="1.3.17 添加 Tidio 在线聊天功能（可选的）"></a>1.3.17 添加 <a href="https://www.tidio.com/" target="_blank" rel="noopener">Tidio</a> 在线聊天功能（可选的）</h4><p>前往 <a href="https://www.tidio.com/" target="_blank" rel="noopener">Tidio</a> 官网注册并且获取 <code>Public Key</code>，并将 <code>Public Key</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h4 id="1-3-18-修改页脚"><a href="#1-3-18-修改页脚" class="headerlink" title="1.3.18 修改页脚"></a>1.3.18 修改页脚</h4><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h4 id="1-3-19-修改社交链接"><a href="#1-3-19-修改社交链接" class="headerlink" title="1.3.19 修改社交链接"></a>1.3.19 修改社交链接</h4><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱等的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">if</span> <span class="token attr-name">(theme.socialLink.github)</span> <span class="token attr-name">{</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>&lt;%<span class="token punctuation">=</span> theme.socialLink.github %<span class="token punctuation">></span><span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fab fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">}</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fab fa-facebook</code></li><li>Twitter: <code>fab fa-twitter</code></li><li>Google-plus: <code>fab fa-google-plus</code></li><li>Linkedin: <code>fab fa-linkedin</code></li><li>Tumblr: <code>fab fa-tumblr</code></li><li>Medium: <code>fab fa-medium</code></li><li>Slack: <code>fab fa-slack</code></li><li>Sina Weibo: <code>fab fa-weibo</code></li><li>Wechat: <code>fab fa-weixin</code></li><li>QQ: <code>fab fa-qq</code></li><li>Zhihu: <code>fab fa-zhihu</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>5.11.0</code>。</p></blockquote><h4 id="1-3-20-修改打赏的二维码图片"><a href="#1-3-20-修改打赏的二维码图片" class="headerlink" title="1.3.20 修改打赏的二维码图片"></a>1.3.20 修改打赏的二维码图片</h4><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h4 id="1-3-21-配置音乐播放器（可选的）"><a href="#1-3-21-配置音乐播放器（可选的）" class="headerlink" title="1.3.21 配置音乐播放器（可选的）"></a>1.3.21 配置音乐播放器（可选的）</h4><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 是否在首页显示音乐</span><span class="token key atrule">music</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">title</span><span class="token punctuation">:</span>             <span class="token comment" spellcheck="true"># 非吸底模式有效</span>    <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">show</span><span class="token punctuation">:</span> 听听音乐  <span class="token key atrule">server</span><span class="token punctuation">:</span> netease   <span class="token comment" spellcheck="true"># require music platform: netease, tencent, kugou, xiami, baidu</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> playlist    <span class="token comment" spellcheck="true"># require song, playlist, album, search, artist</span>  <span class="token key atrule">id</span><span class="token punctuation">:</span> <span class="token number">503838841     </span><span class="token comment" spellcheck="true"># require song id / playlist id / album id / search keyword</span>  <span class="token key atrule">fixed</span><span class="token punctuation">:</span> <span class="token boolean important">false      </span><span class="token comment" spellcheck="true"># 开启吸底模式</span>  <span class="token key atrule">autoplay</span><span class="token punctuation">:</span> <span class="token boolean important">false   </span><span class="token comment" spellcheck="true"># 是否自动播放</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> '<span class="token comment" spellcheck="true">#42b983'</span>  <span class="token key atrule">loop</span><span class="token punctuation">:</span> <span class="token string">'all'</span>       <span class="token comment" spellcheck="true"># 音频循环播放, 可选值: 'all', 'one', 'none'</span>  <span class="token key atrule">order</span><span class="token punctuation">:</span> <span class="token string">'random'</span>   <span class="token comment" spellcheck="true"># 音频循环顺序, 可选值: 'list', 'random'</span>  <span class="token key atrule">preload</span><span class="token punctuation">:</span> <span class="token string">'auto'</span>   <span class="token comment" spellcheck="true"># 预加载，可选值: 'none', 'metadata', 'auto'</span>  <span class="token key atrule">volume</span><span class="token punctuation">:</span> <span class="token number">0.7       </span><span class="token comment" spellcheck="true"># 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span>  <span class="token key atrule">listFolded</span><span class="token punctuation">:</span> <span class="token boolean important">true  </span><span class="token comment" spellcheck="true"># 列表默认折叠</span></code></pre><blockquote><p><code>server</code>可选<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p><p><code>baidu</code>（百度音乐）。</p><p><code>type</code>可选<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p><p><code>id</code>获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，<code>playlist</code>的<code>id</code></p><p>即为这串数字。</p></blockquote><h4 id="1-3-22-Front-matter-选项详解"><a href="#1-3-22-Front-matter-选项详解" class="headerlink" title="1.3.22  Front-matter 选项详解"></a>1.3.22  Front-matter 选项详解</h4><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><p>1.2 最简示例</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token punctuation">---</span></code></pre><p>1.3 最全示例</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span></code></pre><h2 id="2-Hexo-常用命令"><a href="#2-Hexo-常用命令" class="headerlink" title="2. Hexo 常用命令"></a>2. Hexo 常用命令</h2><h3 id="2-1-Create-a-new-post"><a href="#2-1-Create-a-new-post" class="headerlink" title="2.1 Create a new post"></a>2.1 Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="2-2-Run-server"><a href="#2-2-Run-server" class="headerlink" title="2.2 Run server"></a>2.2 Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="2-3-Generate-static-files"><a href="#2-3-Generate-static-files" class="headerlink" title="2.3 Generate static files"></a>2.3 Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="2-4-Deploy-to-remote-sites"><a href="#2-4-Deploy-to-remote-sites" class="headerlink" title="2.4 Deploy to remote sites"></a>2.4 Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo - Matery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
